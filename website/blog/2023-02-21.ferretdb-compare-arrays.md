---
title: "How MongoDB compares arrays in filtering"
slug: ferretdb-compare-arrays
authors: [chi]
description: In this article, we explore in detail how MongoDB BSON arrays are compared
in filter operators.
keywords:
  - MongoDB sorting
  - MongoDB array comparison
image: /img/blog/ferretdb-how-mongodb-compares-arrays.jpg
unlisted: true
---

In this article, we explore in detail how MongoDB BSON arrays are compared in filter operators.

![How MongoDB compares arrays](/img/blog/ferretdb-how-mongodb-compares-arrays.jpg)

<!--truncate-->

## Understanding BSON Comparison for Filtering

The purpose of comparing BSON values is to determine which value is
equal, greater or less than the other.
The comparison is used in various operations, such as sorting, filter operators,
as well as update operators.
When comparing values of different BSON types, the [BSON Comparison Order](#bson-comparison-order)
is used to determine the result.
However, in the case of array comparison against other BSON value,
the comparison may use the BSON comparison order or an element from the array.

In this blog post, we will discuss the comparison of BSON values used in filter operators,
with a focus on arrays.
We will provide examples to help clarify the process.

### BSON Comparison Order

BSON values have a defined order of comparison, listed from lowest to highest as follows:

1. Null
2. Numbers
3. String
4. Object
5. Array
6. BinData
7. ObjectId
8. Boolean
9. Date
10. Timestamp
11. Regular Expression

The numbers are the same BSON comparison order regardless of
`double`, `int32`, `int64` or `decimal`. So the value of the number is used for the comparison.

The BSON comparison order is used for comparing different BSON types. A BSON array
may use an element from an array to compare with other BSON type.
We will discuss in detail in the following section.

### Comparison Rules of Filter

When comparing BSON arrays, each index is iterated in order.
At each index, BSON comparison order is used when the values are different.
If the values at a particular index are not equal, that result is used as the final comparison result.
If there are no more elements in the array during the iteration,
then that array is considered smaller.

When using a filter argument, an array in a collection containing the element
would be selected.
This is the case for both implicit match and `$eq` operator.

For operators `$lt` and `$lte` the smallest element from the array in the collection
is used to compare against the filter argument.
For operators `$gt` and `$gte` the largest element is used for comparison instead.
Additionally, `$lt`, `$gt`, `$lte` and `$gte` uses BSON comparison order
to only select elements of the same BSON comparison order as the filter argument.
For example if the filter argument is string, only strings are selected.

Filtering used in [`$lt`](#lt-operator-comparison) and [`$gt`](#gt-operator-comparison) operators
applies the following rules to compare array and other BSON types.

* `$lt` uses the smallest element of the same BSON type as non-array from the array.
* `$gt` uses the largest element of the same BSON type as non-array from the array.
* Empty array should not match other BSON type.

### Example of Comparison Rules of Filter

#### Example of Comparing Arrays

To compare two arrays, we compare each element in the arrays until we discover a difference.
For instance, when comparing the arrays `[3, 1, 'b']` and `[3, 'b', 'a']`,
the following steps are taken:

1. Compare `[3, 1, 'b']` and `[3, 'b', 'a']` using comparison order.
   They have the same BSON type; both are arrays.
2. Compare first index `3` and `3` using comparison order, both are numbers, and they are the same.
3. Compare next index, `1` and `'b'` using comparison order,
`1` is a number and less than string `'b'`.

So `[3, 1, 'b']` is less than `[3, 'b', 'a']`.

If an array has no more element to compare, the one with no more element is less.
For the same reason empty array is less than arrays with elements.

#### Example of Comparing Array and Other BSON Type

The following steps show `$lt` filter for comparing `2` and `[3, 1]`:

1. It gets the smallest element of array `[3, 1]` which is `1`.
2. It compares `2` and `1`, `2` is greater than `1`.

Therefore, when using ascending sort, `2` is greater than `[3, 1]`.

The following steps show `$gt` filter for comparing  `2` and `[3, 1]`.

1. It gets the largest element of array `[3, 1]` which is `3`.
2. It compares `2` and `3`, `2` is less than `3`.

Therefore, when using descending sort,  `2` is less than `[3, 1]`.

It might seem confusing at first, but note that `$lt` uses the smallest element
from the array, and `$gt` uses the largest element from the array.

## Filter Operator Comparison

In this section, we use `mongosh` to show example of the comparison in filtering.

### Number Comparison

For the filter comparison, numbers `double`, `int32`, `int64` and `decimal` with
the same value are considered equal.

We use simple examples to demonstrate `int32` and `double` are selected by `$eq` operator and
implicit filter even though the type is different.

```js
db.numberexample.insertMany([
  { _id: 'scalar-int', v: Int32(1) },
  { _id: 'scalar-double', v: Double(1.0) },
])
```

In the following, the `$type` operator is used to fetch `double` type to ensure store type is
double and type conversion produced expected double.
It selected `scalar-double`.

```js
db.numberexample.find({v: {$type: "double"}})
[ { _id: 'scalar-double', v: 1 } ]
```

Similarly, we use `$type` operator to fetch `int` type, it selected `scalar-int`.

```js
db.numberexample.find({v: {$type: "int"}})
[ { _id: 'scalar-int', v: 1 } ]
```

We use implicit operator to select equal value from the collection.

```js
db.numberexample.find({ v: 1 })
[
  { _id: 'scalar-int', v: 1 },
  { _id: 'scalar-double', v: 1 }
]
```

It shows that `scalar-int` and `scalar-double` were selected.

The implicit operator is equivalent of `$eq` for the number comparison.

```js
db.numberexample.find({ v: {$eq: 1} })
[
  { _id: 'scalar-int', v: 1 },
  { _id: 'scalar-double', v: 1 }
]
```

For filter comparison, `double`, `int`, `long` and `decimal` are matched for the same value
regardless of the number type.

### `$eq` Operator Comparison

The operator `$eq` is equivalent of implicit operator except for usage on regular expression.

We use following collection to demonstrate selected collection based on the filter argument.

```js
db.eqxample.insertMany([
  { _id: 'scalar-int', v: 1 },
  { _id: 'array-number', v: [ 0.1, 1 ] },
  { _id: 'array-int', v: [ 1 ] },
  { _id: 'nested-int', v: [ [ 1, 2 ] ] },
  { _id: 'nested-arrays', v: [ [ 0.1 ], [ 1 ] ] },
  { _id: 'nested-double', v: [ [ Double(1.0) ] ] },
  { _id: 'nested-number', v: [ [ 1.0, 1 ] ] }
])
```

#### `$eq` Operator with Scalar Argument

The operator `$eq` selects documents from the collection which has an equal value
or an array which contains the equal value. 

```js
db.eqxample.find({v: {$eq: 1}})
[
  { _id: 'scalar-int', v: 1 },
  { _id: 'array-number', v: [ 0.1, 1 ] },
  { _id: 'array-int', v: [ 1 ] }
]
```

The selected `array-number` and `array-int` contains the filter argument in the array.
The location of the value in the array does not matter.
For instance, `array-number` contains the equal value in the second index.

#### `$eq` Operator with Array Argument

Using array filter argument `[1]`, it selects an array which has the same value as the filter argument.

```js
db.eqxample.find({v: [1]})
[
  { _id: 'array-int', v: [ 1 ] },
  { _id: 'nested-arrays', v: [ [ 0.1 ], [ 1 ] ] },
  { _id: 'nested-double', v: [ [ 1 ] ] }
]
```

The selected `array-int` is the same as the filter argument.
The selected `nested-arrays` and `nested-double` contains an array that is the same as
the filter argument.

It did not select `scalar-int`, it's because `$eq` operator selects array collections which contain
the filter argument, but not the other way.

#### Implicit Operator with Nested Array Argument

We demonstrate using nested array filter to select from the collection.

```js
db.eqxample.find({v: [[1]]})
[
  { _id: 'nested-double', v: [ [ 1 ] ] }
]
```

The selected `nested-double` is the same as the filter. It did not select `nested-number`
nor `nested-arrays` because the index to index comparison does not match exactly.

### `$lt` Operator Comparison

[$lt](https://docs.ferretdb.io/basic_operations/read/#retrieve-documents-using-operator-queries)
filter operators select records that are less than the query.
Let's insert records to apply `$lt` filter.

We use following collection to demonstrate selected collection based on the filter argument.

```js
db.ltexample.insertMany([
  { _id: 'scalar-null', v: null },
  { _id: 'scalar-number', v: 1 },
  { _id: 'scalar-string', v: 'a' },
  { _id: 'array-empty', v: [] },
  { _id: 'array-null', v: [ null ] },
  { _id: 'array-mixed', v: [ 1, 'z', 'b' ] },
  { _id: 'array-string', v: [ 'd' ] },
  { _id: 'array-bool', v: [ false ] },
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'c' ], [ 1, 'z', 'b' ] ] },
  { _id: 'nested-string', v: [ [ 'g', 'z' ] ] },
  { _id: 'nested-bool', v: [ [ true ] ] }
])
```

#### `$lt` Operator with Scalar Argument

The operator `$lt` selects records that are less than a specified value of the same BSON type
as the filter argument.
When the filter argument is string, collections with string records
that has less value would be selected.

```
db.ltexample.find({v: {$lt: 'c'}})
[
  { _id: 'scalar-string', v: 'a' },
  { _id: 'array-mixed', v: [ 1, 'z', 'b' ] }
]
```

The records selected are `scalar-string` and an array `array-mixed`.
The record `scalar-string` has smaller value than the filter argument.

An array record `array-mixed` was selected because the smallest element `b` is
less than the filter argument `c`. The operator `$lt` on array collection
only uses the smallest element for the comparison.

When the collection array does not contain
the same BSON type as the filter argument such as `array-null`, no selection is made.

#### `$lt` Operator with Array Argument

When the filter argument is an array, collections with array records
that has less is selected.
It also selects nested arrays if the inner array is less than the filter argument.

The following example shows applying `$lt` operator with an array argument `['c']`.

```js
db.ltexample.find({v: {$lt: ['c']}})
[
  { _id: 'array-empty', v: [] },
  { _id: 'array-null', v: [ null ] },
  { _id: 'array-mixed', v: [ 1, 'z', 'b' ] },
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'c' ], [ 1, 'z', 'b' ] ] }
]
```

No scalar values were selected, because array argument only compares arrays.

The filter argument selects array that is less
or nested array which contains an array that is less. Similarly to `$eq` operator,
an array argument is not compared to scalar value of the collection. So _contains_ condition
is applied on collection containing less than filter argument, but not the other way around

For an array, empty array is smaller than an array with items, so `array-empty` and
`nested-empty` was selected.

For `array-null` and `array-mixed` each indexes was compared against filter and both of them
are less than the filter argument.

For the selected `nested-mixed`, the smallest inner array `[ 1, 'z', 'b' ]` is used
to compare with the argument.

#### `$lt` Operator with Nested Array Argument

The following example shows applying `$lt` operator with a nested array argument `[['c']]`.

```js
db.filterexample.find({v: {$lt: [['c']]}})
[
  { _id: 'array-empty', v: [] },
  { _id: 'array-null', v: [ null ] },
  { _id: 'array-mixed', v: [ 1, 'z', 'b' ] },
  { _id: 'array-string', v: [ 'd' ] },
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'c' ], [ 1, 'z', 'b' ] ] },
  { _id: 'nested-string', v: [ [ 'g', 'z' ] ] }
]
```

No scalar values from the collection was selected as scalar values are not
array type.

For arrays and nested arrays selected, they are less than filter argument, upon comparing
each index. For instance `array-bool` and `nested-bool` were not selected.

For nested arrays, `nested-string` was selected even though the first element
within inner array is not less than the argument filter. This show that
nested array argument and nested array in collections are not compared index to index.
Instead, it takes the smallest array of from the nested array is used
to compare against the filter argument. In the case of `nested-string`, it is
the first inner array. So the comparison is between the filter argument `[['c']]` and 
smallest from the array `[ 1, 'z', 'b' ]`. Then it uses BSON comparison order to compare
the first element the number type of collection which is smaller than array type
of the filter argument.

An array that was not selected was `nested-bool` due to boolean type being not smaller than
array type in BSON comparison order. The argument `[['c']]` was compared with the smallest
element of the nested array of `nested-bool` which is `[true]`. 

### `$gt` Operator Comparison

[$gt](https://docs.ferretdb.io/basic_operations/read/#retrieve-documents-using-operator-queries)
filter operators select records that are greater than the query.

We use the same `filterexample` collection.

```js
db.ltexample.insertMany([
  { _id: 'scalar-null', v: null },
  { _id: 'scalar-number', v: 1 },
  { _id: 'scalar-string', v: 'a' },
  { _id: 'array-empty', v: [] },
  { _id: 'array-null', v: [ null ] },
  { _id: 'array-mixed', v: [ 1, 'z', 'b' ] },
  { _id: 'array-string', v: [ 'd' ] },
  { _id: 'array-bool', v: [ false ] },
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'c' ], [ 1, 'z', 'b' ] ] },
  { _id: 'nested-string', v: [ [ 'g', 'z' ] ] },
  { _id: 'nested-bool', v: [ [ true ] ] }
])
```

#### `$gt` Operator with Scalar Argument

Let's take a look at how `$gt` operator works with arrays.

`$gt` selects records that are greater than a specific value
and this is only applied to the same BSON type.
Let's look at filtering greater than `'c'`.

```js
db.filterexample.find({v: {$gt: 'c'}})
[
  { _id: 'array-mixed', v: [ 1, 'z', 'b' ] }, // 'z' the largest string is used for comparison.
  { _id: 'array-string', v: [ 'd' ] }         // 'd' the largest string is used for comparison.
]
```

The records selected are `array-mixed` and `array-string`.

The selected arrays contain string BSON value that is greater than the filter argument of `c`.

No nested arrays were selected because array is not the same BSON type as string.

* `array-mixed` was selected because it contains `'z'` which is greater than `'c'`.
* `array-string` was selected  because it contains `'d'` which is greater than `'c'`.
* It does not select `string` because `'b'` is not greater than `'c'`.
* It also does not select `null` because is it not string BSON type.
* It does not select `array-empty` and `array-number` because the array does not contain string BSON type.

#### `$gt` Operator with Array Argument

Let's look at filtering greater than `['c']`.

:::note
This example shows an uncertain result of `$gt` operator
:::

```js
db.filterexample.find({v: {$gt: ['c']}})
[
  { _id: 'array-string', v: [ 'd' ] },
  { _id: 'array-bool', v: [ false ] },
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'c' ], [ 1, 'z', 'b' ] ] },
  { _id: 'nested-string', v: [ [ 'g', 'z' ] ] },
  { _id: 'nested-bool', v: [ [ true ] ] }
]
```

No scalar collection was selected. Because they are not array type.

The selected arrays contain string BSON value that is greater than the filter argument of `c`.
This shows that like `$lt`, the array to array comparison compares each index of arrays with
BSON comparison order and value comparison.

Arrays collections and nested array collections were compare by index to index.
This is different behaviour from `$lt` filter with array argument. `$lt` used the
smallest element from the array. While `$gt` compares index to index.


For comparison with nested array, one would assume that the largest inner array would
be used for comparison. That was how `$lt` compared array filter argument with nested array collection.
However, we see that all nested array is selected including `nested-empty`.
This indicates that BSON comparison order is used compare argument with nested array collections.
Given that array is greater in BSON comparison order than that of string,
all nested arrays were selected, even including empty one.

```js
db.nestedfilter.find({v: {$gt: ['c']}})
[
  { _id: 'nested-empty', v: [ [] ] },            // [] is array and greater in comparison order than string 'c'.
  { _id: 'nested-mixed', v: [ [ 'a', 1 ] ] },    // [ 'a', 1 ] is array and greater comparison order than string 'c'.
  { _id: 'nested-string', v: [ [ 'g', 'a' ] ] }, // [ 'g', 'a' ] is array and greater comparison order than string 'c'.
  { _id: 'nested-number', v: [ [ 10, 1 ] ] },    // [ 10, 1 ] is array and greater comparison order than string 'c'.
  { _id: 'array-bool', v: [ true ] }             // true is greater in comparison order than 'c'.
]
```

The selected record is `array-string`.

* `array-string` is selected because comparing the first element `'d'` is greater than `'c'`.
* `array-empty` is not selected as empty array is the smallest array.
* `array-mixed` is not selected by comparing
  each element and first element `0` is not greater than `'c'` in comparison order.
* `array-number` is not selected by comparing
  each element and first element `10` is not greater than `'c'` in comparison order.
* `string` and `null` are not selected, they are not arrays.


Using array filter `['c']` on `$gt` operator, it selected
`array-bool`, `nested-empty`, `nested-mixed`, `nested-string` and `nested-number` from the collection.
This shows that all nested arrays were selected.
It selected `array-bool` which has boolean BSON type `true`
that is greater than string `'c'` in BSON comparison order.

The selected nested arrays `nested-empty`, `nested-mixed`, `nested-string` and `nested-number` were
unexpected since the empty array particularly is not greater than other arrays
when we use the same logic as `$lt` operator on nested array.
The potential explanation is that `$gt` on nested array works on BSON comparison order
when filter is an array.
However, this is different behaviour from `$lt`, which seems to compare
the smallest element of an array instead of applying BSON comparison order.

We are yet to fully understand how nested array is expected to work with filter comparison operator.

#### `$gt` Operator with Nested Array Argument

:::note
This example also shows an uncertain result of `$gt` operator
:::


```
db.filterexample.find({v: {$gt: [['c']]}})
[
  { _id: 'array-bool', v: [ false ] },
  { _id: 'nested-mixed', v: [ [ 'c' ], [ 1, 'z', 'b' ] ] },
  { _id: 'nested-string', v: [ [ 'g', 'z' ] ] },
  { _id: 'nested-bool', v: [ [ true ] ] }
]
```

No scalar values from the collection was selected since the scalar values are not array type.

An array that was selected was `array-bool`. It has boolean which greater BSON comparison order
than of array type, so comparison between `['c']` and the largest item from the array `false`
was used compare. Using the BSON comparison order, boolean is greater than an array hence it was
selected.

For nested arrays, `nested-mixed` was selected even though the greatest element
of inner array `['c']` is not greater than the argument filter. This show that
nested array argument and nested array in collections are compared index to index,
unlike `$lt` which takes the smallest element from the array.
In the case of `nested-string` and `nested-bool` compares iteratively.

An array that was not selected was `nested-empty` due to first index
comparison resulting less for the empty array.

## Nested Array at FerretDB

At FerretDB, we do not support nested array at the moment.
We did not initially support nested array due to complexities raised by
differences in the comparison of
[array and other BSON type](#understanding-bson-comparison-for-filtering).
In particular, differentiating cases where BSON comparison order of the array is used
verses an element from an array is used for comparison was not trivial at first.
Since then, we took time to understand under the hood of comparison for different operations.

Finally, we found out that nested array has not trivial behaviour on
[`$gt` operator](#gt-operator-with-array-argument).
A typical assumption
on how `$gt` may work with nested array would be similar to how `$lt` works
with nested array, but using the largest element.
This was not the case, and
we are yet to find out how it should function.
Perhaps using `$gt` in nested array is not a common usage and the result
we found was a corner case.

If you have any questions or feedback, please [let us know](https://docs.ferretdb.io/#community)!
We're always here to help you get the most out of FerretDB.
