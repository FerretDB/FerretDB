// Code generated by "genwrap -schemas=documentdb_api"; DO NOT EDIT.

package documentdb_api

import (
	"context"
	"log/slog"

	"github.com/FerretDB/wire/wirebson"
	"github.com/jackc/pgx/v5"
	"go.opentelemetry.io/otel"
	oteltrace "go.opentelemetry.io/otel/trace"

	"github.com/FerretDB/FerretDB/v2/internal/mongoerrors"
)

// AggregateCursorFirstPage is a wrapper for
//
//	documentdb_api.aggregate_cursor_first_page(database text, commandspec documentdb_core.bson, cursorid bigint DEFAULT 0, OUT cursorpage documentdb_core.bson, OUT continuation documentdb_core.bson, OUT persistconnection boolean, OUT cursorid bigint).
func AggregateCursorFirstPage(ctx context.Context, conn *pgx.Conn, l *slog.Logger, database string, commandSpec wirebson.RawDocument, cursorID int64) (outCursorPage wirebson.RawDocument, outContinuation wirebson.RawDocument, outPersistConnection bool, outCursorID int64, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.aggregate_cursor_first_page", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT cursorpage::bytea, continuation::bytea, persistconnection, cursorid FROM documentdb_api.aggregate_cursor_first_page($1, $2::bytea, $3)", database, commandSpec, cursorID)
	if err = row.Scan(&outCursorPage, &outContinuation, &outPersistConnection, &outCursorID); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.aggregate_cursor_first_page", l)
	}
	return
}

// BinaryExtendedVersion is a wrapper for
//
//	documentdb_api.binary_extended_version(OUT binary_extended_version text).
func BinaryExtendedVersion(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBinaryExtendedVersion string, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.binary_extended_version", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT binary_extended_version FROM documentdb_api.binary_extended_version()")
	if err = row.Scan(&outBinaryExtendedVersion); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.binary_extended_version", l)
	}
	return
}

// BinaryVersion is a wrapper for
//
//	documentdb_api.binary_version(OUT binary_version text).
func BinaryVersion(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBinaryVersion string, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.binary_version", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT binary_version FROM documentdb_api.binary_version()")
	if err = row.Scan(&outBinaryVersion); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.binary_version", l)
	}
	return
}

// CollMod is a wrapper for
//
//	documentdb_api.coll_mod(p_database_name text, p_collection_name text, p_spec documentdb_core.bson, OUT coll_mod documentdb_core.bson).
func CollMod(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, collectionName string, spec wirebson.RawDocument) (outCollMod wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.coll_mod", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT coll_mod::bytea FROM documentdb_api.coll_mod($1, $2, $3::bytea)", databaseName, collectionName, spec)
	if err = row.Scan(&outCollMod); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.coll_mod", l)
	}
	return
}

// CollStats is a wrapper for
//
//	documentdb_api.coll_stats(p_database_name text, p_collection_name text, p_scale double precision DEFAULT 1, OUT coll_stats documentdb_core.bson).
func CollStats(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, collectionName string, scale float64) (outCollStats wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.coll_stats", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT coll_stats::bytea FROM documentdb_api.coll_stats($1, $2, $3)", databaseName, collectionName, scale)
	if err = row.Scan(&outCollStats); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.coll_stats", l)
	}
	return
}

// Collection is a wrapper for
//
//	documentdb_api.collection(p_database_name text, p_collection_name text, OUT shard_key_value bigint, OUT object_id documentdb_core.bson, OUT document documentdb_core.bson, OUT creation_time timestamp with time zone).
func Collection(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, collectionName string) (outShardKeyValue int64, outObjectID wirebson.RawDocument, outDocument wirebson.RawDocument, outCreationTime []byte, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.collection", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT shard_key_value, object_id::bytea, document::bytea, creation_time FROM documentdb_api.collection($1, $2)", databaseName, collectionName)
	if err = row.Scan(&outShardKeyValue, &outObjectID, &outDocument, &outCreationTime); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.collection", l)
	}
	return
}

// CountQuery is a wrapper for
//
//	documentdb_api.count_query(database text, countspec documentdb_core.bson, OUT document documentdb_core.bson).
func CountQuery(ctx context.Context, conn *pgx.Conn, l *slog.Logger, database string, countSpec wirebson.RawDocument) (outDocument wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.count_query", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT document::bytea FROM documentdb_api.count_query($1, $2::bytea)", database, countSpec)
	if err = row.Scan(&outDocument); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.count_query", l)
	}
	return
}

// CreateCollection is a wrapper for
//
//	documentdb_api.create_collection(p_database_name text, p_collection_name text, OUT create_collection boolean).
func CreateCollection(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, collectionName string) (outCreateCollection bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.create_collection", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT create_collection FROM documentdb_api.create_collection($1, $2)", databaseName, collectionName)
	if err = row.Scan(&outCreateCollection); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.create_collection", l)
	}
	return
}

// CreateCollectionView is a wrapper for
//
//	documentdb_api.create_collection_view(dbname text, createspec documentdb_core.bson, OUT create_collection_view documentdb_core.bson).
func CreateCollectionView(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, createSpec wirebson.RawDocument) (outCreateCollectionView wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.create_collection_view", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT create_collection_view::bytea FROM documentdb_api.create_collection_view($1, $2::bytea)", databaseName, createSpec)
	if err = row.Scan(&outCreateCollectionView); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.create_collection_view", l)
	}
	return
}

// CreateIndexesBackground is a wrapper for
//
//	documentdb_api.create_indexes_background(p_database_name text, p_index_spec documentdb_core.bson, OUT retval documentdb_core.bson, OUT ok boolean, OUT requests documentdb_core.bson).
func CreateIndexesBackground(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, indexSpec wirebson.RawDocument) (outRetValue wirebson.RawDocument, outOk bool, outRequests wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.create_indexes_background", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT retval::bytea, ok, requests::bytea FROM documentdb_api.create_indexes_background($1, $2::bytea)", databaseName, indexSpec)
	if err = row.Scan(&outRetValue, &outOk, &outRequests); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.create_indexes_background", l)
	}
	return
}

// CreateUser is a wrapper for
//
//	documentdb_api.create_user(p_spec documentdb_core.bson, OUT create_user documentdb_core.bson).
func CreateUser(ctx context.Context, conn *pgx.Conn, l *slog.Logger, spec wirebson.RawDocument) (outCreateUser wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.create_user", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT create_user::bytea FROM documentdb_api.create_user($1::bytea)", spec)
	if err = row.Scan(&outCreateUser); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.create_user", l)
	}
	return
}

// CursorGetMore is a wrapper for
//
//	documentdb_api.cursor_get_more(database text, getmorespec documentdb_core.bson, continuationspec documentdb_core.bson, OUT cursorpage documentdb_core.bson, OUT continuation documentdb_core.bson).
func CursorGetMore(ctx context.Context, conn *pgx.Conn, l *slog.Logger, database string, getMoreSpec wirebson.RawDocument, continuationSpec wirebson.RawDocument) (outCursorPage wirebson.RawDocument, outContinuation wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.cursor_get_more", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT cursorpage::bytea, continuation::bytea FROM documentdb_api.cursor_get_more($1, $2::bytea, $3::bytea)", database, getMoreSpec, continuationSpec)
	if err = row.Scan(&outCursorPage, &outContinuation); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.cursor_get_more", l)
	}
	return
}

// DbStats is a wrapper for
//
//	documentdb_api.db_stats(p_database_name text, p_scale double precision DEFAULT 1, p_freestorage boolean DEFAULT false, OUT db_stats documentdb_core.bson).
func DbStats(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, scale float64, freestorage bool) (outDbStats wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.db_stats", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT db_stats::bytea FROM documentdb_api.db_stats($1, $2, $3)", databaseName, scale, freestorage)
	if err = row.Scan(&outDbStats); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.db_stats", l)
	}
	return
}

// Delete is a wrapper for
//
//	documentdb_api.delete(p_database_name text, p_delete documentdb_core.bson, p_insert_documents documentdb_core.bsonsequence DEFAULT NULL, OUT p_result documentdb_core.bson, OUT p_success boolean).
func Delete(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, delete wirebson.RawDocument, insertDocuments []byte) (outResult wirebson.RawDocument, outSuccess bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.delete", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT p_result::bytea, p_success FROM documentdb_api.delete($1, $2::bytea, $3::bytea)", databaseName, delete, insertDocuments)
	if err = row.Scan(&outResult, &outSuccess); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.delete", l)
	}
	return
}

// DistinctQuery is a wrapper for
//
//	documentdb_api.distinct_query(database text, distinctspec documentdb_core.bson, OUT document documentdb_core.bson).
func DistinctQuery(ctx context.Context, conn *pgx.Conn, l *slog.Logger, database string, distinctSpec wirebson.RawDocument) (outDocument wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.distinct_query", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT document::bytea FROM documentdb_api.distinct_query($1, $2::bytea)", database, distinctSpec)
	if err = row.Scan(&outDocument); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.distinct_query", l)
	}
	return
}

// DropCollection is a wrapper for
//
//	documentdb_api.drop_collection(p_database_name text, p_collection_name text, p_write_concern documentdb_core.bson DEFAULT NULL, p_collection_uuid uuid DEFAULT NULL, p_track_changes boolean DEFAULT true, OUT drop_collection boolean).
func DropCollection(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, collectionName string, writeConcern wirebson.RawDocument, collectionUuid []byte, trackChanges bool) (outDropCollection bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.drop_collection", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT drop_collection FROM documentdb_api.drop_collection($1, $2, $3::bytea, $4, $5)", databaseName, collectionName, writeConcern, collectionUuid, trackChanges)
	if err = row.Scan(&outDropCollection); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.drop_collection", l)
	}
	return
}

// DropDatabase is a wrapper for
//
//	documentdb_api.drop_database(p_database_name text, p_write_concern documentdb_core.bson DEFAULT NULL, OUT drop_database void).
func DropDatabase(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, writeConcern wirebson.RawDocument) (outDropDatabase string, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.drop_database", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT drop_database FROM documentdb_api.drop_database($1, $2::bytea)", databaseName, writeConcern)
	if err = row.Scan(&outDropDatabase); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.drop_database", l)
	}
	return
}

// DropIndexes is a wrapper for
//
//	documentdb_api.drop_indexes(p_database_name text, p_arg documentdb_core.bson, INOUT retval documentdb_core.bson DEFAULT NULL).
func DropIndexes(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, arg wirebson.RawDocument, retValue wirebson.RawDocument) (outRetValue wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.drop_indexes", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "CALL documentdb_api.drop_indexes($1, $2::bytea, $3::bytea)", databaseName, arg, retValue)
	if err = row.Scan(&outRetValue); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.drop_indexes", l)
	}
	return
}

// DropUser is a wrapper for
//
//	documentdb_api.drop_user(p_spec documentdb_core.bson, OUT drop_user documentdb_core.bson).
func DropUser(ctx context.Context, conn *pgx.Conn, l *slog.Logger, spec wirebson.RawDocument) (outDropUser wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.drop_user", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT drop_user::bytea FROM documentdb_api.drop_user($1::bytea)", spec)
	if err = row.Scan(&outDropUser); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.drop_user", l)
	}
	return
}

// FindAndModify is a wrapper for
//
//	documentdb_api.find_and_modify(p_database_name text, p_message documentdb_core.bson, OUT p_result documentdb_core.bson, OUT p_success boolean).
func FindAndModify(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, message wirebson.RawDocument) (outResult wirebson.RawDocument, outSuccess bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.find_and_modify", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT p_result::bytea, p_success FROM documentdb_api.find_and_modify($1, $2::bytea)", databaseName, message)
	if err = row.Scan(&outResult, &outSuccess); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.find_and_modify", l)
	}
	return
}

// FindCursorFirstPage is a wrapper for
//
//	documentdb_api.find_cursor_first_page(database text, commandspec documentdb_core.bson, cursorid bigint DEFAULT 0, OUT cursorpage documentdb_core.bson, OUT continuation documentdb_core.bson, OUT persistconnection boolean, OUT cursorid bigint).
func FindCursorFirstPage(ctx context.Context, conn *pgx.Conn, l *slog.Logger, database string, commandSpec wirebson.RawDocument, cursorID int64) (outCursorPage wirebson.RawDocument, outContinuation wirebson.RawDocument, outPersistConnection bool, outCursorID int64, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.find_cursor_first_page", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT cursorpage::bytea, continuation::bytea, persistconnection, cursorid FROM documentdb_api.find_cursor_first_page($1, $2::bytea, $3)", database, commandSpec, cursorID)
	if err = row.Scan(&outCursorPage, &outContinuation, &outPersistConnection, &outCursorID); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.find_cursor_first_page", l)
	}
	return
}

// Insert is a wrapper for
//
//	documentdb_api.insert(p_database_name text, p_insert documentdb_core.bson, p_insert_documents documentdb_core.bsonsequence DEFAULT NULL, OUT p_result documentdb_core.bson, OUT p_success boolean).
func Insert(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, insert wirebson.RawDocument, insertDocuments []byte) (outResult wirebson.RawDocument, outSuccess bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.insert", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT p_result::bytea, p_success FROM documentdb_api.insert($1, $2::bytea, $3::bytea)", databaseName, insert, insertDocuments)
	if err = row.Scan(&outResult, &outSuccess); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.insert", l)
	}
	return
}

// InsertOne is a wrapper for
//
//	documentdb_api.insert_one(p_database_name text, p_collection_name text, p_document documentdb_core.bson, OUT insert_one documentdb_core.bson).
func InsertOne(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, collectionName string, document wirebson.RawDocument) (outInsertOne wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.insert_one", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT insert_one::bytea FROM documentdb_api.insert_one($1, $2, $3::bytea)", databaseName, collectionName, document)
	if err = row.Scan(&outInsertOne); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.insert_one", l)
	}
	return
}

// ListCollectionsCursorFirstPage is a wrapper for
//
//	documentdb_api.list_collections_cursor_first_page(database text, commandspec documentdb_core.bson, cursorid bigint DEFAULT 0, OUT cursorpage documentdb_core.bson, OUT continuation documentdb_core.bson, OUT persistconnection boolean, OUT cursorid bigint).
func ListCollectionsCursorFirstPage(ctx context.Context, conn *pgx.Conn, l *slog.Logger, database string, commandSpec wirebson.RawDocument, cursorID int64) (outCursorPage wirebson.RawDocument, outContinuation wirebson.RawDocument, outPersistConnection bool, outCursorID int64, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.list_collections_cursor_first_page", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT cursorpage::bytea, continuation::bytea, persistconnection, cursorid FROM documentdb_api.list_collections_cursor_first_page($1, $2::bytea, $3)", database, commandSpec, cursorID)
	if err = row.Scan(&outCursorPage, &outContinuation, &outPersistConnection, &outCursorID); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.list_collections_cursor_first_page", l)
	}
	return
}

// ListIndexesCursorFirstPage is a wrapper for
//
//	documentdb_api.list_indexes_cursor_first_page(database text, commandspec documentdb_core.bson, cursorid bigint DEFAULT 0, OUT cursorpage documentdb_core.bson, OUT continuation documentdb_core.bson, OUT persistconnection boolean, OUT cursorid bigint).
func ListIndexesCursorFirstPage(ctx context.Context, conn *pgx.Conn, l *slog.Logger, database string, commandSpec wirebson.RawDocument, cursorID int64) (outCursorPage wirebson.RawDocument, outContinuation wirebson.RawDocument, outPersistConnection bool, outCursorID int64, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.list_indexes_cursor_first_page", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT cursorpage::bytea, continuation::bytea, persistconnection, cursorid FROM documentdb_api.list_indexes_cursor_first_page($1, $2::bytea, $3)", database, commandSpec, cursorID)
	if err = row.Scan(&outCursorPage, &outContinuation, &outPersistConnection, &outCursorID); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.list_indexes_cursor_first_page", l)
	}
	return
}

// RenameCollection is a wrapper for
//
//	documentdb_api.rename_collection(p_database_name text, p_collection_name text, p_target_name text, p_drop_target boolean DEFAULT false, OUT rename_collection void).
func RenameCollection(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, collectionName string, targetName string, dropTarget bool) (outRenameCollection string, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.rename_collection", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT rename_collection FROM documentdb_api.rename_collection($1, $2, $3, $4)", databaseName, collectionName, targetName, dropTarget)
	if err = row.Scan(&outRenameCollection); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.rename_collection", l)
	}
	return
}

// ReshardCollection is a wrapper for
//
//	documentdb_api.reshard_collection(p_shard_key_spec documentdb_core.bson, OUT reshard_collection void).
func ReshardCollection(ctx context.Context, conn *pgx.Conn, l *slog.Logger, shardKeySpec wirebson.RawDocument) (outReshardCollection string, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.reshard_collection", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT reshard_collection FROM documentdb_api.reshard_collection($1::bytea)", shardKeySpec)
	if err = row.Scan(&outReshardCollection); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.reshard_collection", l)
	}
	return
}

// ShardCollection is a wrapper for
//
//	documentdb_api.shard_collection(p_database_name text, p_collection_name text, p_shard_key documentdb_core.bson, p_is_reshard boolean DEFAULT true, OUT shard_collection void).
func ShardCollection(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, collectionName string, shardKey wirebson.RawDocument, isReshard bool) (outShardCollection string, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.shard_collection", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT shard_collection FROM documentdb_api.shard_collection($1, $2, $3::bytea, $4)", databaseName, collectionName, shardKey, isReshard)
	if err = row.Scan(&outShardCollection); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.shard_collection", l)
	}
	return
}

// ShardCollection1 is a wrapper for
//
//	documentdb_api.shard_collection(p_shard_key_spec documentdb_core.bson, OUT shard_collection void).
func ShardCollection1(ctx context.Context, conn *pgx.Conn, l *slog.Logger, shardKeySpec wirebson.RawDocument) (outShardCollection string, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.shard_collection", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT shard_collection FROM documentdb_api.shard_collection($1::bytea)", shardKeySpec)
	if err = row.Scan(&outShardCollection); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.shard_collection", l)
	}
	return
}

// UnshardCollection is a wrapper for
//
//	documentdb_api.unshard_collection(p_shard_key_spec documentdb_core.bson, OUT unshard_collection void).
func UnshardCollection(ctx context.Context, conn *pgx.Conn, l *slog.Logger, shardKeySpec wirebson.RawDocument) (outUnshardCollection string, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.unshard_collection", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT unshard_collection FROM documentdb_api.unshard_collection($1::bytea)", shardKeySpec)
	if err = row.Scan(&outUnshardCollection); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.unshard_collection", l)
	}
	return
}

// Update is a wrapper for
//
//	documentdb_api.update(p_database_name text, p_update documentdb_core.bson, p_insert_documents documentdb_core.bsonsequence DEFAULT NULL, OUT p_result documentdb_core.bson, OUT p_success boolean).
func Update(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, update wirebson.RawDocument, insertDocuments []byte) (outResult wirebson.RawDocument, outSuccess bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.update", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT p_result::bytea, p_success FROM documentdb_api.update($1, $2::bytea, $3::bytea)", databaseName, update, insertDocuments)
	if err = row.Scan(&outResult, &outSuccess); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.update", l)
	}
	return
}

// UpdateUser is a wrapper for
//
//	documentdb_api.update_user(p_spec documentdb_core.bson, OUT update_user documentdb_core.bson).
func UpdateUser(ctx context.Context, conn *pgx.Conn, l *slog.Logger, spec wirebson.RawDocument) (outUpdateUser wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.update_user", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT update_user::bytea FROM documentdb_api.update_user($1::bytea)", spec)
	if err = row.Scan(&outUpdateUser); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.update_user", l)
	}
	return
}

// UsersInfo is a wrapper for
//
//	documentdb_api.users_info(p_spec documentdb_core.bson, OUT users_info documentdb_core.bson).
func UsersInfo(ctx context.Context, conn *pgx.Conn, l *slog.Logger, spec wirebson.RawDocument) (outUsersInfo wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.users_info", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT users_info::bytea FROM documentdb_api.users_info($1::bytea)", spec)
	if err = row.Scan(&outUsersInfo); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.users_info", l)
	}
	return
}

// Validate is a wrapper for
//
//	documentdb_api.validate(database text, validatespec documentdb_core.bson, OUT document documentdb_core.bson).
func Validate(ctx context.Context, conn *pgx.Conn, l *slog.Logger, database string, validatespec wirebson.RawDocument) (outDocument wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.validate", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT document::bytea FROM documentdb_api.validate($1, $2::bytea)", database, validatespec)
	if err = row.Scan(&outDocument); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.validate", l)
	}
	return
}
