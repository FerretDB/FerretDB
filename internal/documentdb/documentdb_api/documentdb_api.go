// Code generated by "genwrap -debug -schemas=documentdb_api,documentdb_api_catalog,documentdb_api_internal,documentdb_core"; DO NOT EDIT.

package documentdb_api

import (
	"context"
	"log/slog"
	"time"

	"github.com/FerretDB/wire/wirebson"
	"github.com/jackc/pgx/v5"
	"go.opentelemetry.io/otel"
	oteltrace "go.opentelemetry.io/otel/trace"

	"github.com/FerretDB/FerretDB/v2/internal/mongoerrors"
)

// AggregateCursorFirstPage is a wrapper for
//
//	[Comment] documentdb_api.aggregate_cursor_first_page_19111.
func AggregateCursorFirstPage(ctx context.Context, conn *pgx.Conn, l *slog.Logger, database string, commandSpec wirebson.RawDocument, cursorID int64, cursorPage wirebson.RawDocument, continuation wirebson.RawDocument, persistConnection bool, cursorID int64) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.aggregate_cursor_first_page", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.aggregate_cursor_first_page([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.aggregate_cursor_first_page", l)
	}
	return
}

// BinaryExtendedVersion is a wrapper for
//
//	[Comment] documentdb_api.binary_extended_version_19132.
func BinaryExtendedVersion(ctx context.Context, conn *pgx.Conn, l *slog.Logger) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.binary_extended_version", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.binary_extended_version([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.binary_extended_version", l)
	}
	return
}

// BinaryVersion is a wrapper for
//
//	[Comment] documentdb_api.binary_version_19131.
func BinaryVersion(ctx context.Context, conn *pgx.Conn, l *slog.Logger) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.binary_version", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.binary_version([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.binary_version", l)
	}
	return
}

// CollMod is a wrapper for
//
//	[Comment] documentdb_api.coll_mod_19080.
func CollMod(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, collectionName string, spec wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.coll_mod", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.coll_mod([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.coll_mod", l)
	}
	return
}

// CollStats is a wrapper for
//
//	[Comment] documentdb_api.coll_stats_19133.
func CollStats(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, collectionName string, scale float64) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.coll_stats", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.coll_stats([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.coll_stats", l)
	}
	return
}

// Collection is a wrapper for
//
//	[Comment] documentdb_api.collection_19032.
func Collection(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, collectionName string, shardKeyValue int64, objectID wirebson.RawDocument, document wirebson.RawDocument, creationTime struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.collection", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.collection([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.collection", l)
	}
	return
}

// CountQuery is a wrapper for
//
//	[Comment] documentdb_api.count_query_19116.
func CountQuery(ctx context.Context, conn *pgx.Conn, l *slog.Logger, database string, countSpec wirebson.RawDocument, document wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.count_query", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.count_query([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.count_query", l)
	}
	return
}

// CreateCollection is a wrapper for
//
//	[Comment] documentdb_api.create_collection_19075.
func CreateCollection(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, collectionName string) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.create_collection", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.create_collection([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.create_collection", l)
	}
	return
}

// CreateCollectionView is a wrapper for
//
//	[Comment] documentdb_api.create_collection_view_19081.
func CreateCollectionView(ctx context.Context, conn *pgx.Conn, l *slog.Logger, database string, createSpec wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.create_collection_view", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.create_collection_view([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.create_collection_view", l)
	}
	return
}

// CreateIndexesBackground is a wrapper for
//
//	[Comment] documentdb_api.create_indexes_background_19093.
func CreateIndexesBackground(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, indexSpec wirebson.RawDocument, retValue wirebson.RawDocument, ok bool, requests wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.create_indexes_background", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.create_indexes_background([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.create_indexes_background", l)
	}
	return
}

// CreateUser is a wrapper for
//
//	[Comment] documentdb_api.create_user_19120.
func CreateUser(ctx context.Context, conn *pgx.Conn, l *slog.Logger, spec wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.create_user", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.create_user([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.create_user", l)
	}
	return
}

// CursorGetMore is a wrapper for
//
//	[Comment] documentdb_api.cursor_get_more_19115.
func CursorGetMore(ctx context.Context, conn *pgx.Conn, l *slog.Logger, database string, getMoreSpec wirebson.RawDocument, continuationSpec wirebson.RawDocument, cursorPage wirebson.RawDocument, continuation wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.cursor_get_more", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.cursor_get_more([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.cursor_get_more", l)
	}
	return
}

// DbStats is a wrapper for
//
//	[Comment] documentdb_api.db_stats_19136.
func DbStats(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, scale float64, freestorage bool) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.db_stats", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.db_stats([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.db_stats", l)
	}
	return
}

// Delete is a wrapper for
//
//	[Comment] documentdb_api.delete_19107.
func Delete(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, delete wirebson.RawDocument, insertDocuments []byte, transactionId string, result wirebson.RawDocument, success bool) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.delete", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.delete([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.delete", l)
	}
	return
}

// DistinctQuery is a wrapper for
//
//	[Comment] documentdb_api.distinct_query_19117.
func DistinctQuery(ctx context.Context, conn *pgx.Conn, l *slog.Logger, database string, distinctSpec wirebson.RawDocument, document wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.distinct_query", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.distinct_query([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.distinct_query", l)
	}
	return
}

// DropCollection is a wrapper for
//
//	[Comment] documentdb_api.drop_collection_19082.
func DropCollection(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, collectionName string, writeConcern wirebson.RawDocument, collectionUuid []byte, trackChanges bool) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.drop_collection", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.drop_collection([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.drop_collection", l)
	}
	return
}

// DropDatabase is a wrapper for
//
//	[Comment] documentdb_api.drop_database_19083.
func DropDatabase(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, writeConcern wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.drop_database", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.drop_database([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.drop_database", l)
	}
	return
}

// DropIndexes is a wrapper for
//
//	[Comment] documentdb_api.drop_indexes_19097.
func DropIndexes(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, arg wirebson.RawDocument, retValue wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.drop_indexes", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "CALL documentdb_api.drop_indexes([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.drop_indexes", l)
	}
	return
}

// DropUser is a wrapper for
//
//	[Comment] documentdb_api.drop_user_19121.
func DropUser(ctx context.Context, conn *pgx.Conn, l *slog.Logger, spec wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.drop_user", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.drop_user([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.drop_user", l)
	}
	return
}

// FindAndModify is a wrapper for
//
//	[Comment] documentdb_api.find_and_modify_19110.
func FindAndModify(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, message wirebson.RawDocument, transactionId string, result wirebson.RawDocument, success bool) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.find_and_modify", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.find_and_modify([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.find_and_modify", l)
	}
	return
}

// FindCursorFirstPage is a wrapper for
//
//	[Comment] documentdb_api.find_cursor_first_page_19112.
func FindCursorFirstPage(ctx context.Context, conn *pgx.Conn, l *slog.Logger, database string, commandSpec wirebson.RawDocument, cursorID int64, cursorPage wirebson.RawDocument, continuation wirebson.RawDocument, persistConnection bool, cursorID int64) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.find_cursor_first_page", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.find_cursor_first_page([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.find_cursor_first_page", l)
	}
	return
}

// Insert is a wrapper for
//
//	[Comment] documentdb_api.insert_19098.
func Insert(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, insert wirebson.RawDocument, insertDocuments []byte, transactionId string, result wirebson.RawDocument, success bool) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.insert", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.insert([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.insert", l)
	}
	return
}

// InsertOne is a wrapper for
//
//	[Comment] documentdb_api.insert_one_19101.
func InsertOne(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, collectionName string, document wirebson.RawDocument, transactionId string) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.insert_one", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.insert_one([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.insert_one", l)
	}
	return
}

// ListCollectionsCursorFirstPage is a wrapper for
//
//	[Comment] documentdb_api.list_collections_cursor_first_page_19113.
func ListCollectionsCursorFirstPage(ctx context.Context, conn *pgx.Conn, l *slog.Logger, database string, commandSpec wirebson.RawDocument, cursorID int64, cursorPage wirebson.RawDocument, continuation wirebson.RawDocument, persistConnection bool, cursorID int64) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.list_collections_cursor_first_page", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.list_collections_cursor_first_page([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.list_collections_cursor_first_page", l)
	}
	return
}

// ListIndexesCursorFirstPage is a wrapper for
//
//	[Comment] documentdb_api.list_indexes_cursor_first_page_19114.
func ListIndexesCursorFirstPage(ctx context.Context, conn *pgx.Conn, l *slog.Logger, database string, commandSpec wirebson.RawDocument, cursorID int64, cursorPage wirebson.RawDocument, continuation wirebson.RawDocument, persistConnection bool, cursorID int64) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.list_indexes_cursor_first_page", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.list_indexes_cursor_first_page([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.list_indexes_cursor_first_page", l)
	}
	return
}

// RenameCollection is a wrapper for
//
//	[Comment] documentdb_api.rename_collection_19084.
func RenameCollection(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, collectionName string, targetName string, dropTarget bool) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.rename_collection", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.rename_collection([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.rename_collection", l)
	}
	return
}

// ReshardCollection is a wrapper for
//
//	[Comment] documentdb_api.reshard_collection_19078.
func ReshardCollection(ctx context.Context, conn *pgx.Conn, l *slog.Logger, shardKeySpec wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.reshard_collection", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.reshard_collection([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.reshard_collection", l)
	}
	return
}

// ShardCollection is a wrapper for
//
//	[Comment] documentdb_api.shard_collection_19076.
func ShardCollection(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, collectionName string, shardKey wirebson.RawDocument, isReshard bool) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.shard_collection", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.shard_collection([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.shard_collection", l)
	}
	return
}

// ShardCollection19077 is a wrapper for
//
//	[Comment] documentdb_api.shard_collection_19077.
func ShardCollection19077(ctx context.Context, conn *pgx.Conn, l *slog.Logger, shardKeySpec wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.shard_collection", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.shard_collection([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.shard_collection", l)
	}
	return
}

// UnshardCollection is a wrapper for
//
//	[Comment] documentdb_api.unshard_collection_19079.
func UnshardCollection(ctx context.Context, conn *pgx.Conn, l *slog.Logger, shardKeySpec wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.unshard_collection", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.unshard_collection([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.unshard_collection", l)
	}
	return
}

// Update is a wrapper for
//
//	[Comment] documentdb_api.update_19103.
func Update(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, update wirebson.RawDocument, insertDocuments []byte, transactionId string, result wirebson.RawDocument, success bool) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.update", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.update([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.update", l)
	}
	return
}

// UpdateUser is a wrapper for
//
//	[Comment] documentdb_api.update_user_19122.
func UpdateUser(ctx context.Context, conn *pgx.Conn, l *slog.Logger, spec wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.update_user", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.update_user([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.update_user", l)
	}
	return
}

// UsersInfo is a wrapper for
//
//	[Comment] documentdb_api.users_info_19123.
func UsersInfo(ctx context.Context, conn *pgx.Conn, l *slog.Logger, spec wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.users_info", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.users_info([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.users_info", l)
	}
	return
}

// Validate is a wrapper for
//
//	[Comment] documentdb_api.validate_19140.
func Validate(ctx context.Context, conn *pgx.Conn, l *slog.Logger, database string, validateSpec wirebson.RawDocument, document wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api.validate", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_api.validate([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api.validate", l)
	}
	return
}
