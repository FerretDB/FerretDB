// Code generated by "genwrap -debug -schemas=documentdb_api,documentdb_api_catalog,documentdb_api_internal,documentdb_core"; DO NOT EDIT.

package documentdb_api_catalog

import (
	"context"
	"log/slog"

	"github.com/FerretDB/wire/wirebson"
	"github.com/jackc/pgx/v5"
	"go.opentelemetry.io/otel"
	oteltrace "go.opentelemetry.io/otel/trace"

	"github.com/FerretDB/FerretDB/v2/internal/mongoerrors"
)

// BsonAggregationCount is a wrapper for
//
//	documentdb_api_catalog.bson_aggregation_count(databasename text, countspec documentdb_core.bson, OUT document documentdb_core.bson).
func BsonAggregationCount(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databasename string, countSpec wirebson.RawDocument) (outDocument wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_aggregation_count", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT document::bytea FROM documentdb_api_catalog.bson_aggregation_count($1, $2::bytea)", databasename, countSpec)
	if err = row.Scan(&outDocument); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_aggregation_count", l)
	}
	return
}

// BsonAggregationDistinct is a wrapper for
//
//	documentdb_api_catalog.bson_aggregation_distinct(databasename text, distinctspec documentdb_core.bson, OUT document documentdb_core.bson).
func BsonAggregationDistinct(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databasename string, distinctSpec wirebson.RawDocument) (outDocument wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_aggregation_distinct", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT document::bytea FROM documentdb_api_catalog.bson_aggregation_distinct($1, $2::bytea)", databasename, distinctSpec)
	if err = row.Scan(&outDocument); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_aggregation_distinct", l)
	}
	return
}

// BsonAggregationFind is a wrapper for
//
//	documentdb_api_catalog.bson_aggregation_find(databasename text, findspec documentdb_core.bson, OUT document documentdb_core.bson).
func BsonAggregationFind(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databasename string, findSpec wirebson.RawDocument) (outDocument wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_aggregation_find", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT document::bytea FROM documentdb_api_catalog.bson_aggregation_find($1, $2::bytea)", databasename, findSpec)
	if err = row.Scan(&outDocument); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_aggregation_find", l)
	}
	return
}

// BsonAggregationPipeline is a wrapper for
//
//	documentdb_api_catalog.bson_aggregation_pipeline(databasename text, aggregationpipeline documentdb_core.bson, OUT document documentdb_core.bson).
func BsonAggregationPipeline(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databasename string, aggregationpipeline wirebson.RawDocument) (outDocument wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_aggregation_pipeline", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT document::bytea FROM documentdb_api_catalog.bson_aggregation_pipeline($1, $2::bytea)", databasename, aggregationpipeline)
	if err = row.Scan(&outDocument); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_aggregation_pipeline", l)
	}
	return
}

// BsonArrayAgg is a wrapper for
//
//	documentdb_api_catalog.bson_array_agg(anonymous documentdb_core.bson, anonymous1 text).
func BsonArrayAgg(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 string) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_array_agg", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.bson_array_agg($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_array_agg", l)
	}
	return
}

// BsonArrayAgg1 is a wrapper for
//
//	documentdb_api_catalog.bson_array_agg(anonymous documentdb_core.bson, anonymous1 text, anonymous12 boolean).
func BsonArrayAgg1(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 string, anonymous12 bool) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_array_agg", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.bson_array_agg($1::bytea, $2, $3)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_array_agg", l)
	}
	return
}

// BsonArrayAggFinal is a wrapper for
//
//	documentdb_api_catalog.bson_array_agg_final(anonymous bytea, OUT bson_array_agg_final documentdb_core.bson).
func BsonArrayAggFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonArrayAggFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_array_agg_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_array_agg_final::bytea FROM documentdb_api_catalog.bson_array_agg_final($1)", anonymous)
	if err = row.Scan(&outBsonArrayAggFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_array_agg_final", l)
	}
	return
}

// BsonArrayAggTransition is a wrapper for
//
//	documentdb_api_catalog.bson_array_agg_transition(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 text, OUT bson_array_agg_transition bytea).
func BsonArrayAggTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 string) (outBsonArrayAggTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_array_agg_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_array_agg_transition FROM documentdb_api_catalog.bson_array_agg_transition($1, $2::bytea, $3)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(&outBsonArrayAggTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_array_agg_transition", l)
	}
	return
}

// BsonArrayAggTransition1 is a wrapper for
//
//	documentdb_api_catalog.bson_array_agg_transition(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 text, anonymous123 boolean, OUT bson_array_agg_transition bytea).
func BsonArrayAggTransition1(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 string, anonymous123 bool) (outBsonArrayAggTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_array_agg_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_array_agg_transition FROM documentdb_api_catalog.bson_array_agg_transition($1, $2::bytea, $3, $4)", anonymous, anonymous1, anonymous12, anonymous123)
	if err = row.Scan(&outBsonArrayAggTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_array_agg_transition", l)
	}
	return
}

// BsonAvgFinal is a wrapper for
//
//	documentdb_api_catalog.bson_avg_final(anonymous bytea, OUT bson_avg_final documentdb_core.bson).
func BsonAvgFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonAvgFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_avg_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_avg_final::bytea FROM documentdb_api_catalog.bson_avg_final($1)", anonymous)
	if err = row.Scan(&outBsonAvgFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_avg_final", l)
	}
	return
}

// BsonBuildDistinctResponse is a wrapper for
//
//	documentdb_api_catalog.bson_build_distinct_response(anonymous ARRAY, OUT bson_build_distinct_response documentdb_core.bson).
func BsonBuildDistinctResponse(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonBuildDistinctResponse wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_build_distinct_response", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_build_distinct_response::bytea FROM documentdb_api_catalog.bson_build_distinct_response($1)", anonymous)
	if err = row.Scan(&outBsonBuildDistinctResponse); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_build_distinct_response", l)
	}
	return
}

// BsonDistinctAgg is a wrapper for
//
//	documentdb_api_catalog.bson_distinct_agg(anonymous documentdb_core.bson).
func BsonDistinctAgg(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_distinct_agg", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.bson_distinct_agg($1::bytea)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_distinct_agg", l)
	}
	return
}

// BsonDistinctUnwind is a wrapper for
//
//	documentdb_api_catalog.bson_distinct_unwind(anonymous documentdb_core.bson, anonymous1 text, OUT bson_distinct_unwind documentdb_core.bson).
func BsonDistinctUnwind(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 string) (outBsonDistinctUnwind wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_distinct_unwind", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_distinct_unwind::bytea FROM documentdb_api_catalog.bson_distinct_unwind($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDistinctUnwind); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_distinct_unwind", l)
	}
	return
}

// BsonDollarAddFields is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_add_fields(document documentdb_core.bson, pathspec documentdb_core.bson, OUT bson_dollar_add_fields documentdb_core.bson).
func BsonDollarAddFields(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, pathSpec wirebson.RawDocument) (outBsonDollarAddFields wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_add_fields", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_add_fields::bytea FROM documentdb_api_catalog.bson_dollar_add_fields($1::bytea, $2::bytea)", document, pathSpec)
	if err = row.Scan(&outBsonDollarAddFields); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_add_fields", l)
	}
	return
}

// BsonDollarAll is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_all(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_all boolean).
func BsonDollarAll(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarAll bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_all", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_all FROM documentdb_api_catalog.bson_dollar_all($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarAll); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_all", l)
	}
	return
}

// BsonDollarBitsAllClear is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_bits_all_clear(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_bits_all_clear boolean).
func BsonDollarBitsAllClear(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarBitsAllClear bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_bits_all_clear", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_bits_all_clear FROM documentdb_api_catalog.bson_dollar_bits_all_clear($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarBitsAllClear); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_bits_all_clear", l)
	}
	return
}

// BsonDollarBitsAllSet is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_bits_all_set(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_bits_all_set boolean).
func BsonDollarBitsAllSet(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarBitsAllSet bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_bits_all_set", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_bits_all_set FROM documentdb_api_catalog.bson_dollar_bits_all_set($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarBitsAllSet); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_bits_all_set", l)
	}
	return
}

// BsonDollarBitsAnyClear is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_bits_any_clear(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_bits_any_clear boolean).
func BsonDollarBitsAnyClear(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarBitsAnyClear bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_bits_any_clear", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_bits_any_clear FROM documentdb_api_catalog.bson_dollar_bits_any_clear($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarBitsAnyClear); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_bits_any_clear", l)
	}
	return
}

// BsonDollarBitsAnySet is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_bits_any_set(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_bits_any_set boolean).
func BsonDollarBitsAnySet(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarBitsAnySet bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_bits_any_set", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_bits_any_set FROM documentdb_api_catalog.bson_dollar_bits_any_set($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarBitsAnySet); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_bits_any_set", l)
	}
	return
}

// BsonDollarElemmatch is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_elemmatch(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_elemmatch boolean).
func BsonDollarElemmatch(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarElemmatch bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_elemmatch", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_elemmatch FROM documentdb_api_catalog.bson_dollar_elemmatch($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarElemmatch); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_elemmatch", l)
	}
	return
}

// BsonDollarEq is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_eq(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_eq boolean).
func BsonDollarEq(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarEq bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_eq", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_eq FROM documentdb_api_catalog.bson_dollar_eq($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarEq); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_eq", l)
	}
	return
}

// BsonDollarEq1 is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_eq(anonymous documentdb_core.bson, anonymous1 documentdb_core.bsonquery, OUT bson_dollar_eq boolean).
func BsonDollarEq1(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 struct{}) (outBsonDollarEq bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_eq", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_eq FROM documentdb_api_catalog.bson_dollar_eq($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarEq); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_eq", l)
	}
	return
}

// BsonDollarExists is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_exists(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_exists boolean).
func BsonDollarExists(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarExists bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_exists", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_exists FROM documentdb_api_catalog.bson_dollar_exists($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarExists); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_exists", l)
	}
	return
}

// BsonDollarExpr is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_expr(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_expr boolean).
func BsonDollarExpr(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarExpr bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_expr", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_expr FROM documentdb_api_catalog.bson_dollar_expr($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarExpr); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_expr", l)
	}
	return
}

// BsonDollarFacetProject is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_facet_project(anonymous documentdb_core.bson, anonymous1 boolean, OUT bson_dollar_facet_project documentdb_core.bson).
func BsonDollarFacetProject(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 bool) (outBsonDollarFacetProject wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_facet_project", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_facet_project::bytea FROM documentdb_api_catalog.bson_dollar_facet_project($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarFacetProject); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_facet_project", l)
	}
	return
}

// BsonDollarGeointersects is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_geointersects(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_geointersects boolean).
func BsonDollarGeointersects(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarGeointersects bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_geointersects", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_geointersects FROM documentdb_api_catalog.bson_dollar_geointersects($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarGeointersects); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_geointersects", l)
	}
	return
}

// BsonDollarGeowithin is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_geowithin(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_geowithin boolean).
func BsonDollarGeowithin(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarGeowithin bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_geowithin", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_geowithin FROM documentdb_api_catalog.bson_dollar_geowithin($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarGeowithin); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_geowithin", l)
	}
	return
}

// BsonDollarGt is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_gt(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_gt boolean).
func BsonDollarGt(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarGt bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_gt", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_gt FROM documentdb_api_catalog.bson_dollar_gt($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarGt); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_gt", l)
	}
	return
}

// BsonDollarGt1 is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_gt(anonymous documentdb_core.bson, anonymous1 documentdb_core.bsonquery, OUT bson_dollar_gt boolean).
func BsonDollarGt1(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 struct{}) (outBsonDollarGt bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_gt", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_gt FROM documentdb_api_catalog.bson_dollar_gt($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarGt); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_gt", l)
	}
	return
}

// BsonDollarGte is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_gte(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_gte boolean).
func BsonDollarGte(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarGte bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_gte", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_gte FROM documentdb_api_catalog.bson_dollar_gte($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarGte); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_gte", l)
	}
	return
}

// BsonDollarGte1 is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_gte(anonymous documentdb_core.bson, anonymous1 documentdb_core.bsonquery, OUT bson_dollar_gte boolean).
func BsonDollarGte1(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 struct{}) (outBsonDollarGte bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_gte", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_gte FROM documentdb_api_catalog.bson_dollar_gte($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarGte); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_gte", l)
	}
	return
}

// BsonDollarIn is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_in(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_in boolean).
func BsonDollarIn(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarIn bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_in", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_in FROM documentdb_api_catalog.bson_dollar_in($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarIn); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_in", l)
	}
	return
}

// BsonDollarJsonSchema is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_json_schema(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_json_schema boolean).
func BsonDollarJsonSchema(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarJsonSchema bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_json_schema", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_json_schema FROM documentdb_api_catalog.bson_dollar_json_schema($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarJsonSchema); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_json_schema", l)
	}
	return
}

// BsonDollarLt is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_lt(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_lt boolean).
func BsonDollarLt(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarLt bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_lt", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_lt FROM documentdb_api_catalog.bson_dollar_lt($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarLt); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_lt", l)
	}
	return
}

// BsonDollarLt1 is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_lt(anonymous documentdb_core.bson, anonymous1 documentdb_core.bsonquery, OUT bson_dollar_lt boolean).
func BsonDollarLt1(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 struct{}) (outBsonDollarLt bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_lt", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_lt FROM documentdb_api_catalog.bson_dollar_lt($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarLt); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_lt", l)
	}
	return
}

// BsonDollarLte is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_lte(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_lte boolean).
func BsonDollarLte(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarLte bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_lte", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_lte FROM documentdb_api_catalog.bson_dollar_lte($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarLte); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_lte", l)
	}
	return
}

// BsonDollarLte1 is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_lte(anonymous documentdb_core.bson, anonymous1 documentdb_core.bsonquery, OUT bson_dollar_lte boolean).
func BsonDollarLte1(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 struct{}) (outBsonDollarLte bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_lte", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_lte FROM documentdb_api_catalog.bson_dollar_lte($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarLte); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_lte", l)
	}
	return
}

// BsonDollarMod is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_mod(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_mod boolean).
func BsonDollarMod(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarMod bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_mod", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_mod FROM documentdb_api_catalog.bson_dollar_mod($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarMod); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_mod", l)
	}
	return
}

// BsonDollarNe is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_ne(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_ne boolean).
func BsonDollarNe(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarNe bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_ne", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_ne FROM documentdb_api_catalog.bson_dollar_ne($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarNe); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_ne", l)
	}
	return
}

// BsonDollarNin is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_nin(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_nin boolean).
func BsonDollarNin(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarNin bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_nin", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_nin FROM documentdb_api_catalog.bson_dollar_nin($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarNin); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_nin", l)
	}
	return
}

// BsonDollarProject is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_project(document documentdb_core.bson, pathspec documentdb_core.bson, OUT bson_dollar_project documentdb_core.bson).
func BsonDollarProject(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, pathSpec wirebson.RawDocument) (outBsonDollarProject wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_project", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_project::bytea FROM documentdb_api_catalog.bson_dollar_project($1::bytea, $2::bytea)", document, pathSpec)
	if err = row.Scan(&outBsonDollarProject); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_project", l)
	}
	return
}

// BsonDollarProjectFind is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_project_find(document documentdb_core.bson, pathspec documentdb_core.bson, queryspec documentdb_core.bson DEFAULT NULL, OUT bson_dollar_project_find documentdb_core.bson).
func BsonDollarProjectFind(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, pathSpec wirebson.RawDocument, querySpec wirebson.RawDocument) (outBsonDollarProjectFind wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_project_find", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_project_find::bytea FROM documentdb_api_catalog.bson_dollar_project_find($1::bytea, $2::bytea, $3::bytea)", document, pathSpec, querySpec)
	if err = row.Scan(&outBsonDollarProjectFind); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_project_find", l)
	}
	return
}

// BsonDollarProjectGeonear is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_project_geonear(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_project_geonear documentdb_core.bson).
func BsonDollarProjectGeonear(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarProjectGeonear wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_project_geonear", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_project_geonear::bytea FROM documentdb_api_catalog.bson_dollar_project_geonear($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarProjectGeonear); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_project_geonear", l)
	}
	return
}

// BsonDollarRegex is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_regex(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_regex boolean).
func BsonDollarRegex(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarRegex bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_regex", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_regex FROM documentdb_api_catalog.bson_dollar_regex($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarRegex); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_regex", l)
	}
	return
}

// BsonDollarReplaceRoot is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_replace_root(document documentdb_core.bson, pathspec documentdb_core.bson, OUT bson_dollar_replace_root documentdb_core.bson).
func BsonDollarReplaceRoot(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, pathSpec wirebson.RawDocument) (outBsonDollarReplaceRoot wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_replace_root", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_replace_root::bytea FROM documentdb_api_catalog.bson_dollar_replace_root($1::bytea, $2::bytea)", document, pathSpec)
	if err = row.Scan(&outBsonDollarReplaceRoot); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_replace_root", l)
	}
	return
}

// BsonDollarSet is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_set(document documentdb_core.bson, pathspec documentdb_core.bson, OUT bson_dollar_set documentdb_core.bson).
func BsonDollarSet(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, pathSpec wirebson.RawDocument) (outBsonDollarSet wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_set", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_set::bytea FROM documentdb_api_catalog.bson_dollar_set($1::bytea, $2::bytea)", document, pathSpec)
	if err = row.Scan(&outBsonDollarSet); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_set", l)
	}
	return
}

// BsonDollarSize is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_size(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_size boolean).
func BsonDollarSize(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarSize bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_size", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_size FROM documentdb_api_catalog.bson_dollar_size($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarSize); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_size", l)
	}
	return
}

// BsonDollarType is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_type(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_type boolean).
func BsonDollarType(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarType bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_type", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_type FROM documentdb_api_catalog.bson_dollar_type($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarType); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_type", l)
	}
	return
}

// BsonDollarUnset is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_unset(document documentdb_core.bson, pathspec documentdb_core.bson, OUT bson_dollar_unset documentdb_core.bson).
func BsonDollarUnset(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, pathSpec wirebson.RawDocument) (outBsonDollarUnset wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_unset", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_unset::bytea FROM documentdb_api_catalog.bson_dollar_unset($1::bytea, $2::bytea)", document, pathSpec)
	if err = row.Scan(&outBsonDollarUnset); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_unset", l)
	}
	return
}

// BsonDollarUnwind is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_unwind(anonymous documentdb_core.bson, anonymous1 text, OUT bson_dollar_unwind documentdb_core.bson).
func BsonDollarUnwind(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 string) (outBsonDollarUnwind wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_unwind", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_unwind::bytea FROM documentdb_api_catalog.bson_dollar_unwind($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarUnwind); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_unwind", l)
	}
	return
}

// BsonDollarUnwind1 is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_unwind(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_unwind documentdb_core.bson).
func BsonDollarUnwind1(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarUnwind wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_unwind", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_unwind::bytea FROM documentdb_api_catalog.bson_dollar_unwind($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarUnwind); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_unwind", l)
	}
	return
}

// BsonExpressionGet is a wrapper for
//
//	documentdb_api_catalog.bson_expression_get(document documentdb_core.bson, expressionspec documentdb_core.bson, isnullonempty boolean DEFAULT false, OUT bson_expression_get documentdb_core.bson).
func BsonExpressionGet(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, expressionSpec wirebson.RawDocument, isnullonempty bool) (outBsonExpressionGet wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_expression_get", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_expression_get::bytea FROM documentdb_api_catalog.bson_expression_get($1::bytea, $2::bytea, $3)", document, expressionSpec, isnullonempty)
	if err = row.Scan(&outBsonExpressionGet); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_expression_get", l)
	}
	return
}

// BsonExpressionMap is a wrapper for
//
//	documentdb_api_catalog.bson_expression_map(document documentdb_core.bson, sourcearrayname text, expressionspec documentdb_core.bson, isnullonempty boolean DEFAULT false, OUT bson_expression_map documentdb_core.bson).
func BsonExpressionMap(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, sourcearrayname string, expressionSpec wirebson.RawDocument, isnullonempty bool) (outBsonExpressionMap wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_expression_map", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_expression_map::bytea FROM documentdb_api_catalog.bson_expression_map($1::bytea, $2, $3::bytea, $4)", document, sourcearrayname, expressionSpec, isnullonempty)
	if err = row.Scan(&outBsonExpressionMap); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_expression_map", l)
	}
	return
}

// BsonFirstCombine is a wrapper for
//
//	documentdb_api_catalog.bson_first_combine(anonymous bytea, anonymous1 bytea, OUT bson_first_combine bytea).
func BsonFirstCombine(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}) (outBsonFirstCombine struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_first_combine", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_first_combine FROM documentdb_api_catalog.bson_first_combine($1, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonFirstCombine); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_first_combine", l)
	}
	return
}

// BsonFirstLastFinal is a wrapper for
//
//	documentdb_api_catalog.bson_first_last_final(anonymous bytea, OUT bson_first_last_final documentdb_core.bson).
func BsonFirstLastFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonFirstLastFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_first_last_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_first_last_final::bytea FROM documentdb_api_catalog.bson_first_last_final($1)", anonymous)
	if err = row.Scan(&outBsonFirstLastFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_first_last_final", l)
	}
	return
}

// BsonFirstLastFinalOnSorted is a wrapper for
//
//	documentdb_api_catalog.bson_first_last_final_on_sorted(anonymous bytea, OUT bson_first_last_final_on_sorted documentdb_core.bson).
func BsonFirstLastFinalOnSorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonFirstLastFinalOnSorted wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_first_last_final_on_sorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_first_last_final_on_sorted::bytea FROM documentdb_api_catalog.bson_first_last_final_on_sorted($1)", anonymous)
	if err = row.Scan(&outBsonFirstLastFinalOnSorted); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_first_last_final_on_sorted", l)
	}
	return
}

// BsonFirstTransition is a wrapper for
//
//	documentdb_api_catalog.bson_first_transition(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 ARRAY, OUT bson_first_transition bytea).
func BsonFirstTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 struct{}) (outBsonFirstTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_first_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_first_transition FROM documentdb_api_catalog.bson_first_transition($1, $2::bytea, $3)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(&outBsonFirstTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_first_transition", l)
	}
	return
}

// BsonFirstTransitionOnSorted is a wrapper for
//
//	documentdb_api_catalog.bson_first_transition_on_sorted(anonymous bytea, anonymous1 documentdb_core.bson, OUT bson_first_transition_on_sorted bytea).
func BsonFirstTransitionOnSorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonFirstTransitionOnSorted struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_first_transition_on_sorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_first_transition_on_sorted FROM documentdb_api_catalog.bson_first_transition_on_sorted($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonFirstTransitionOnSorted); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_first_transition_on_sorted", l)
	}
	return
}

// BsonFirstnCombine is a wrapper for
//
//	documentdb_api_catalog.bson_firstn_combine(anonymous bytea, anonymous1 bytea, OUT bson_firstn_combine bytea).
func BsonFirstnCombine(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}) (outBsonFirstnCombine struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_firstn_combine", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_firstn_combine FROM documentdb_api_catalog.bson_firstn_combine($1, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonFirstnCombine); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_firstn_combine", l)
	}
	return
}

// BsonFirstnLastnFinal is a wrapper for
//
//	documentdb_api_catalog.bson_firstn_lastn_final(anonymous bytea, OUT bson_firstn_lastn_final documentdb_core.bson).
func BsonFirstnLastnFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonFirstnLastnFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_firstn_lastn_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_firstn_lastn_final::bytea FROM documentdb_api_catalog.bson_firstn_lastn_final($1)", anonymous)
	if err = row.Scan(&outBsonFirstnLastnFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_firstn_lastn_final", l)
	}
	return
}

// BsonFirstnLastnFinalOnSorted is a wrapper for
//
//	documentdb_api_catalog.bson_firstn_lastn_final_on_sorted(anonymous bytea, OUT bson_firstn_lastn_final_on_sorted documentdb_core.bson).
func BsonFirstnLastnFinalOnSorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonFirstnLastnFinalOnSorted wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_firstn_lastn_final_on_sorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_firstn_lastn_final_on_sorted::bytea FROM documentdb_api_catalog.bson_firstn_lastn_final_on_sorted($1)", anonymous)
	if err = row.Scan(&outBsonFirstnLastnFinalOnSorted); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_firstn_lastn_final_on_sorted", l)
	}
	return
}

// BsonFirstnTransition is a wrapper for
//
//	documentdb_api_catalog.bson_firstn_transition(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 bigint, anonymous123 ARRAY, OUT bson_firstn_transition bytea).
func BsonFirstnTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 int64, anonymous123 struct{}) (outBsonFirstnTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_firstn_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_firstn_transition FROM documentdb_api_catalog.bson_firstn_transition($1, $2::bytea, $3, $4)", anonymous, anonymous1, anonymous12, anonymous123)
	if err = row.Scan(&outBsonFirstnTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_firstn_transition", l)
	}
	return
}

// BsonFirstnTransitionOnSorted is a wrapper for
//
//	documentdb_api_catalog.bson_firstn_transition_on_sorted(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 bigint, OUT bson_firstn_transition_on_sorted bytea).
func BsonFirstnTransitionOnSorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 int64) (outBsonFirstnTransitionOnSorted struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_firstn_transition_on_sorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_firstn_transition_on_sorted FROM documentdb_api_catalog.bson_firstn_transition_on_sorted($1, $2::bytea, $3)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(&outBsonFirstnTransitionOnSorted); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_firstn_transition_on_sorted", l)
	}
	return
}

// BsonGeonearDistance is a wrapper for
//
//	documentdb_api_catalog.bson_geonear_distance(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_geonear_distance double precision).
func BsonGeonearDistance(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonGeonearDistance float64, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_geonear_distance", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_geonear_distance FROM documentdb_api_catalog.bson_geonear_distance($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonGeonearDistance); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_geonear_distance", l)
	}
	return
}

// BsonGistGeographyCompress is a wrapper for
//
//	documentdb_api_catalog.bson_gist_geography_compress(anonymous internal, OUT bson_gist_geography_compress internal).
func BsonGistGeographyCompress(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonGistGeographyCompress struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_gist_geography_compress", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_gist_geography_compress FROM documentdb_api_catalog.bson_gist_geography_compress($1)", anonymous)
	if err = row.Scan(&outBsonGistGeographyCompress); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_gist_geography_compress", l)
	}
	return
}

// BsonGistGeographyConsistent is a wrapper for
//
//	documentdb_api_catalog.bson_gist_geography_consistent(anonymous internal, anonymous1 documentdb_core.bson, anonymous12 integer, OUT bson_gist_geography_consistent boolean).
func BsonGistGeographyConsistent(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 int32) (outBsonGistGeographyConsistent bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_gist_geography_consistent", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_gist_geography_consistent FROM documentdb_api_catalog.bson_gist_geography_consistent($1, $2::bytea, $3)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(&outBsonGistGeographyConsistent); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_gist_geography_consistent", l)
	}
	return
}

// BsonGistGeographyDistance is a wrapper for
//
//	documentdb_api_catalog.bson_gist_geography_distance(anonymous internal, anonymous1 documentdb_core.bson, anonymous12 integer, OUT bson_gist_geography_distance double precision).
func BsonGistGeographyDistance(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 int32) (outBsonGistGeographyDistance float64, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_gist_geography_distance", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_gist_geography_distance FROM documentdb_api_catalog.bson_gist_geography_distance($1, $2::bytea, $3)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(&outBsonGistGeographyDistance); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_gist_geography_distance", l)
	}
	return
}

// BsonGistGeographyOptions is a wrapper for
//
//	documentdb_api_catalog.bson_gist_geography_options(anonymous internal).
func BsonGistGeographyOptions(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_gist_geography_options", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.bson_gist_geography_options($1)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_gist_geography_options", l)
	}
	return
}

// BsonGistGeometry2dCompress is a wrapper for
//
//	documentdb_api_catalog.bson_gist_geometry_2d_compress(anonymous internal, OUT bson_gist_geometry_2d_compress internal).
func BsonGistGeometry2dCompress(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonGistGeometry2dCompress struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_gist_geometry_2d_compress", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_gist_geometry_2d_compress FROM documentdb_api_catalog.bson_gist_geometry_2d_compress($1)", anonymous)
	if err = row.Scan(&outBsonGistGeometry2dCompress); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_gist_geometry_2d_compress", l)
	}
	return
}

// BsonGistGeometry2dOptions is a wrapper for
//
//	documentdb_api_catalog.bson_gist_geometry_2d_options(anonymous internal).
func BsonGistGeometry2dOptions(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_gist_geometry_2d_options", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.bson_gist_geometry_2d_options($1)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_gist_geometry_2d_options", l)
	}
	return
}

// BsonGistGeometryConsistent2d is a wrapper for
//
//	documentdb_api_catalog.bson_gist_geometry_consistent_2d(anonymous internal, anonymous1 documentdb_core.bson, anonymous12 integer, OUT bson_gist_geometry_consistent_2d boolean).
func BsonGistGeometryConsistent2d(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 int32) (outBsonGistGeometryConsistent2d bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_gist_geometry_consistent_2d", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_gist_geometry_consistent_2d FROM documentdb_api_catalog.bson_gist_geometry_consistent_2d($1, $2::bytea, $3)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(&outBsonGistGeometryConsistent2d); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_gist_geometry_consistent_2d", l)
	}
	return
}

// BsonGistGeometryDistance2d is a wrapper for
//
//	documentdb_api_catalog.bson_gist_geometry_distance_2d(anonymous internal, anonymous1 documentdb_core.bson, anonymous12 integer, OUT bson_gist_geometry_distance_2d double precision).
func BsonGistGeometryDistance2d(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 int32) (outBsonGistGeometryDistance2d float64, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_gist_geometry_distance_2d", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_gist_geometry_distance_2d FROM documentdb_api_catalog.bson_gist_geometry_distance_2d($1, $2::bytea, $3)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(&outBsonGistGeometryDistance2d); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_gist_geometry_distance_2d", l)
	}
	return
}

// BsonLastCombine is a wrapper for
//
//	documentdb_api_catalog.bson_last_combine(anonymous bytea, anonymous1 bytea, OUT bson_last_combine bytea).
func BsonLastCombine(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}) (outBsonLastCombine struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_last_combine", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_last_combine FROM documentdb_api_catalog.bson_last_combine($1, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonLastCombine); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_last_combine", l)
	}
	return
}

// BsonLastTransition is a wrapper for
//
//	documentdb_api_catalog.bson_last_transition(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 ARRAY, OUT bson_last_transition bytea).
func BsonLastTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 struct{}) (outBsonLastTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_last_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_last_transition FROM documentdb_api_catalog.bson_last_transition($1, $2::bytea, $3)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(&outBsonLastTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_last_transition", l)
	}
	return
}

// BsonLastTransitionOnSorted is a wrapper for
//
//	documentdb_api_catalog.bson_last_transition_on_sorted(anonymous bytea, anonymous1 documentdb_core.bson, OUT bson_last_transition_on_sorted bytea).
func BsonLastTransitionOnSorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonLastTransitionOnSorted struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_last_transition_on_sorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_last_transition_on_sorted FROM documentdb_api_catalog.bson_last_transition_on_sorted($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonLastTransitionOnSorted); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_last_transition_on_sorted", l)
	}
	return
}

// BsonLastnCombine is a wrapper for
//
//	documentdb_api_catalog.bson_lastn_combine(anonymous bytea, anonymous1 bytea, OUT bson_lastn_combine bytea).
func BsonLastnCombine(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}) (outBsonLastnCombine struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_lastn_combine", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_lastn_combine FROM documentdb_api_catalog.bson_lastn_combine($1, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonLastnCombine); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_lastn_combine", l)
	}
	return
}

// BsonLastnTransition is a wrapper for
//
//	documentdb_api_catalog.bson_lastn_transition(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 bigint, anonymous123 ARRAY, OUT bson_lastn_transition bytea).
func BsonLastnTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 int64, anonymous123 struct{}) (outBsonLastnTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_lastn_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_lastn_transition FROM documentdb_api_catalog.bson_lastn_transition($1, $2::bytea, $3, $4)", anonymous, anonymous1, anonymous12, anonymous123)
	if err = row.Scan(&outBsonLastnTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_lastn_transition", l)
	}
	return
}

// BsonLastnTransitionOnSorted is a wrapper for
//
//	documentdb_api_catalog.bson_lastn_transition_on_sorted(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 bigint, OUT bson_lastn_transition_on_sorted bytea).
func BsonLastnTransitionOnSorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 int64) (outBsonLastnTransitionOnSorted struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_lastn_transition_on_sorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_lastn_transition_on_sorted FROM documentdb_api_catalog.bson_lastn_transition_on_sorted($1, $2::bytea, $3)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(&outBsonLastnTransitionOnSorted); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_lastn_transition_on_sorted", l)
	}
	return
}

// BsonLookupUnwind is a wrapper for
//
//	documentdb_api_catalog.bson_lookup_unwind(anonymous documentdb_core.bson, anonymous1 text, OUT bson_lookup_unwind documentdb_core.bson).
func BsonLookupUnwind(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 string) (outBsonLookupUnwind wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_lookup_unwind", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_lookup_unwind::bytea FROM documentdb_api_catalog.bson_lookup_unwind($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonLookupUnwind); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_lookup_unwind", l)
	}
	return
}

// BsonMaxCombine is a wrapper for
//
//	documentdb_api_catalog.bson_max_combine(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_max_combine documentdb_core.bson).
func BsonMaxCombine(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonMaxCombine wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_max_combine", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_max_combine::bytea FROM documentdb_api_catalog.bson_max_combine($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonMaxCombine); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_max_combine", l)
	}
	return
}

// BsonMaxTransition is a wrapper for
//
//	documentdb_api_catalog.bson_max_transition(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_max_transition documentdb_core.bson).
func BsonMaxTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonMaxTransition wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_max_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_max_transition::bytea FROM documentdb_api_catalog.bson_max_transition($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonMaxTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_max_transition", l)
	}
	return
}

// BsonMinCombine is a wrapper for
//
//	documentdb_api_catalog.bson_min_combine(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_min_combine documentdb_core.bson).
func BsonMinCombine(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonMinCombine wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_min_combine", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_min_combine::bytea FROM documentdb_api_catalog.bson_min_combine($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonMinCombine); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_min_combine", l)
	}
	return
}

// BsonMinMaxFinal is a wrapper for
//
//	documentdb_api_catalog.bson_min_max_final(anonymous documentdb_core.bson, OUT bson_min_max_final documentdb_core.bson).
func BsonMinMaxFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument) (outBsonMinMaxFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_min_max_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_min_max_final::bytea FROM documentdb_api_catalog.bson_min_max_final($1::bytea)", anonymous)
	if err = row.Scan(&outBsonMinMaxFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_min_max_final", l)
	}
	return
}

// BsonMinTransition is a wrapper for
//
//	documentdb_api_catalog.bson_min_transition(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_min_transition documentdb_core.bson).
func BsonMinTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonMinTransition wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_min_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_min_transition::bytea FROM documentdb_api_catalog.bson_min_transition($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonMinTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_min_transition", l)
	}
	return
}

// BsonObjectAgg is a wrapper for
//
//	documentdb_api_catalog.bson_object_agg(anonymous documentdb_core.bson).
func BsonObjectAgg(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_object_agg", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.bson_object_agg($1::bytea)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_object_agg", l)
	}
	return
}

// BsonObjectAggFinal is a wrapper for
//
//	documentdb_api_catalog.bson_object_agg_final(anonymous bytea, OUT bson_object_agg_final documentdb_core.bson).
func BsonObjectAggFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonObjectAggFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_object_agg_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_object_agg_final::bytea FROM documentdb_api_catalog.bson_object_agg_final($1)", anonymous)
	if err = row.Scan(&outBsonObjectAggFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_object_agg_final", l)
	}
	return
}

// BsonObjectAggTransition is a wrapper for
//
//	documentdb_api_catalog.bson_object_agg_transition(anonymous bytea, anonymous1 documentdb_core.bson, OUT bson_object_agg_transition bytea).
func BsonObjectAggTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonObjectAggTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_object_agg_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_object_agg_transition FROM documentdb_api_catalog.bson_object_agg_transition($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonObjectAggTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_object_agg_transition", l)
	}
	return
}

// BsonOrderby is a wrapper for
//
//	documentdb_api_catalog.bson_orderby(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_orderby documentdb_core.bson).
func BsonOrderby(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonOrderby wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_orderby", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_orderby::bytea FROM documentdb_api_catalog.bson_orderby($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonOrderby); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_orderby", l)
	}
	return
}

// BsonOut is a wrapper for
//
//	documentdb_api_catalog.bson_out(anonymous documentdb_core.bson, anonymous1 text, anonymous12 text, anonymous123 text, anonymous1234 text).
func BsonOut(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 string, anonymous12 string, anonymous123 string, anonymous1234 string) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_out", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.bson_out($1::bytea, $2, $3, $4, $5)", anonymous, anonymous1, anonymous12, anonymous123, anonymous1234)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_out", l)
	}
	return
}

// BsonOutFinal is a wrapper for
//
//	documentdb_api_catalog.bson_out_final(anonymous bytea, OUT bson_out_final documentdb_core.bson).
func BsonOutFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonOutFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_out_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_out_final::bytea FROM documentdb_api_catalog.bson_out_final($1)", anonymous)
	if err = row.Scan(&outBsonOutFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_out_final", l)
	}
	return
}

// BsonOutTransition is a wrapper for
//
//	documentdb_api_catalog.bson_out_transition(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 text, anonymous123 text, anonymous1234 text, anonymous12345 text, OUT bson_out_transition bytea).
func BsonOutTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 string, anonymous123 string, anonymous1234 string, anonymous12345 string) (outBsonOutTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_out_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_out_transition FROM documentdb_api_catalog.bson_out_transition($1, $2::bytea, $3, $4, $5, $6)", anonymous, anonymous1, anonymous12, anonymous123, anonymous1234, anonymous12345)
	if err = row.Scan(&outBsonOutTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_out_transition", l)
	}
	return
}

// BsonQueryMatch is a wrapper for
//
//	documentdb_api_catalog.bson_query_match(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_query_match boolean).
func BsonQueryMatch(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonQueryMatch bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_query_match", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_query_match FROM documentdb_api_catalog.bson_query_match($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonQueryMatch); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_query_match", l)
	}
	return
}

// BsonSumAvgCombine is a wrapper for
//
//	documentdb_api_catalog.bson_sum_avg_combine(anonymous bytea, anonymous1 bytea, OUT bson_sum_avg_combine bytea).
func BsonSumAvgCombine(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}) (outBsonSumAvgCombine struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_sum_avg_combine", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_sum_avg_combine FROM documentdb_api_catalog.bson_sum_avg_combine($1, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonSumAvgCombine); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_sum_avg_combine", l)
	}
	return
}

// BsonSumAvgTransition is a wrapper for
//
//	documentdb_api_catalog.bson_sum_avg_transition(anonymous bytea, anonymous1 documentdb_core.bson, OUT bson_sum_avg_transition bytea).
func BsonSumAvgTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonSumAvgTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_sum_avg_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_sum_avg_transition FROM documentdb_api_catalog.bson_sum_avg_transition($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonSumAvgTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_sum_avg_transition", l)
	}
	return
}

// BsonSumFinal is a wrapper for
//
//	documentdb_api_catalog.bson_sum_final(anonymous bytea, OUT bson_sum_final documentdb_core.bson).
func BsonSumFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonSumFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_sum_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_sum_final::bytea FROM documentdb_api_catalog.bson_sum_final($1)", anonymous)
	if err = row.Scan(&outBsonSumFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_sum_final", l)
	}
	return
}

// BsonTrueMatch is a wrapper for
//
//	documentdb_api_catalog.bson_true_match(anonymous documentdb_core.bson, OUT bson_true_match boolean).
func BsonTrueMatch(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument) (outBsonTrueMatch bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_true_match", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_true_match FROM documentdb_api_catalog.bson_true_match($1::bytea)", anonymous)
	if err = row.Scan(&outBsonTrueMatch); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_true_match", l)
	}
	return
}

// BsonValidateGeography is a wrapper for
//
//	documentdb_api_catalog.bson_validate_geography(p_document documentdb_core.bson, p_keypath text, OUT bson_validate_geography documentdb_core.bson).
func BsonValidateGeography(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, keypath string) (outBsonValidateGeography wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_validate_geography", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_validate_geography::bytea FROM documentdb_api_catalog.bson_validate_geography($1::bytea, $2)", document, keypath)
	if err = row.Scan(&outBsonValidateGeography); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_validate_geography", l)
	}
	return
}

// BsonValidateGeometry is a wrapper for
//
//	documentdb_api_catalog.bson_validate_geometry(p_document documentdb_core.bson, p_keypath text, OUT bson_validate_geometry documentdb_core.bson).
func BsonValidateGeometry(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, keypath string) (outBsonValidateGeometry wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_validate_geometry", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_validate_geometry::bytea FROM documentdb_api_catalog.bson_validate_geometry($1::bytea, $2)", document, keypath)
	if err = row.Scan(&outBsonValidateGeometry); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_validate_geometry", l)
	}
	return
}

// Bsonaverage is a wrapper for
//
//	documentdb_api_catalog.bsonaverage(anonymous documentdb_core.bson).
func Bsonaverage(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonaverage", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.bsonaverage($1::bytea)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonaverage", l)
	}
	return
}

// Bsonfirst is a wrapper for
//
//	documentdb_api_catalog.bsonfirst(anonymous documentdb_core.bson, anonymous1 ARRAY).
func Bsonfirst(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 struct{}) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonfirst", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.bsonfirst($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonfirst", l)
	}
	return
}

// Bsonfirstn is a wrapper for
//
//	documentdb_api_catalog.bsonfirstn(anonymous documentdb_core.bson, anonymous1 bigint, anonymous12 ARRAY).
func Bsonfirstn(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 int64, anonymous12 struct{}) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonfirstn", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.bsonfirstn($1::bytea, $2, $3)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonfirstn", l)
	}
	return
}

// Bsonfirstnonsorted is a wrapper for
//
//	documentdb_api_catalog.bsonfirstnonsorted(anonymous documentdb_core.bson, anonymous1 bigint).
func Bsonfirstnonsorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 int64) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonfirstnonsorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.bsonfirstnonsorted($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonfirstnonsorted", l)
	}
	return
}

// Bsonfirstonsorted is a wrapper for
//
//	documentdb_api_catalog.bsonfirstonsorted(anonymous documentdb_core.bson).
func Bsonfirstonsorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonfirstonsorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.bsonfirstonsorted($1::bytea)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonfirstonsorted", l)
	}
	return
}

// Bsonlast is a wrapper for
//
//	documentdb_api_catalog.bsonlast(anonymous documentdb_core.bson, anonymous1 ARRAY).
func Bsonlast(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 struct{}) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonlast", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.bsonlast($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonlast", l)
	}
	return
}

// Bsonlastn is a wrapper for
//
//	documentdb_api_catalog.bsonlastn(anonymous documentdb_core.bson, anonymous1 bigint, anonymous12 ARRAY).
func Bsonlastn(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 int64, anonymous12 struct{}) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonlastn", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.bsonlastn($1::bytea, $2, $3)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonlastn", l)
	}
	return
}

// Bsonlastnonsorted is a wrapper for
//
//	documentdb_api_catalog.bsonlastnonsorted(anonymous documentdb_core.bson, anonymous1 bigint).
func Bsonlastnonsorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 int64) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonlastnonsorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.bsonlastnonsorted($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonlastnonsorted", l)
	}
	return
}

// Bsonlastonsorted is a wrapper for
//
//	documentdb_api_catalog.bsonlastonsorted(anonymous documentdb_core.bson).
func Bsonlastonsorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonlastonsorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.bsonlastonsorted($1::bytea)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonlastonsorted", l)
	}
	return
}

// Bsonmax is a wrapper for
//
//	documentdb_api_catalog.bsonmax(anonymous documentdb_core.bson).
func Bsonmax(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonmax", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.bsonmax($1::bytea)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonmax", l)
	}
	return
}

// Bsonmin is a wrapper for
//
//	documentdb_api_catalog.bsonmin(anonymous documentdb_core.bson).
func Bsonmin(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonmin", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.bsonmin($1::bytea)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonmin", l)
	}
	return
}

// Bsonsum is a wrapper for
//
//	documentdb_api_catalog.bsonsum(anonymous documentdb_core.bson).
func Bsonsum(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonsum", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.bsonsum($1::bytea)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonsum", l)
	}
	return
}

// Documentdbrumhandler is a wrapper for
//
//	documentdb_api_catalog.documentdbrumhandler(anonymous internal, OUT documentdbrumhandler index_am_handler).
func Documentdbrumhandler(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outDocumentdbrumhandler struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.documentdbrumhandler", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT documentdbrumhandler FROM documentdb_api_catalog.documentdbrumhandler($1)", anonymous)
	if err = row.Scan(&outDocumentdbrumhandler); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.documentdbrumhandler", l)
	}
	return
}

// DollarSupport is a wrapper for
//
//	documentdb_api_catalog.dollar_support(anonymous internal, OUT dollar_support internal).
func DollarSupport(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outDollarSupport struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.dollar_support", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT dollar_support FROM documentdb_api_catalog.dollar_support($1)", anonymous)
	if err = row.Scan(&outDollarSupport); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.dollar_support", l)
	}
	return
}

// GinBsonCanPreConsistent is a wrapper for
//
//	documentdb_api_catalog.gin_bson_can_pre_consistent(anonymous smallint, anonymous1 documentdb_core.bson, anonymous12 integer, anonymous123 internal, anonymous1234 internal, anonymous12345 internal, OUT gin_bson_can_pre_consistent boolean).
func GinBsonCanPreConsistent(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 int32, anonymous123 struct{}, anonymous1234 struct{}, anonymous12345 struct{}) (outGinBsonCanPreConsistent bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_can_pre_consistent", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_can_pre_consistent FROM documentdb_api_catalog.gin_bson_can_pre_consistent($1, $2::bytea, $3, $4, $5, $6)", anonymous, anonymous1, anonymous12, anonymous123, anonymous1234, anonymous12345)
	if err = row.Scan(&outGinBsonCanPreConsistent); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_can_pre_consistent", l)
	}
	return
}

// GinBsonCompare is a wrapper for
//
//	documentdb_api_catalog.gin_bson_compare(anonymous bytea, anonymous1 bytea, OUT gin_bson_compare boolean).
func GinBsonCompare(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}) (outGinBsonCompare bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_compare", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_compare FROM documentdb_api_catalog.gin_bson_compare($1, $2)", anonymous, anonymous1)
	if err = row.Scan(&outGinBsonCompare); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_compare", l)
	}
	return
}

// GinBsonComparePartial is a wrapper for
//
//	documentdb_api_catalog.gin_bson_compare_partial(anonymous bytea, anonymous1 bytea, anonymous12 smallint, anonymous123 internal, OUT gin_bson_compare_partial integer).
func GinBsonComparePartial(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}, anonymous12 struct{}, anonymous123 struct{}) (outGinBsonComparePartial int32, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_compare_partial", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_compare_partial FROM documentdb_api_catalog.gin_bson_compare_partial($1, $2, $3, $4)", anonymous, anonymous1, anonymous12, anonymous123)
	if err = row.Scan(&outGinBsonComparePartial); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_compare_partial", l)
	}
	return
}

// GinBsonConsistent is a wrapper for
//
//	documentdb_api_catalog.gin_bson_consistent(anonymous internal, anonymous1 smallint, anonymous12 anyelement, anonymous123 integer, anonymous1234 internal, anonymous12345 internal, OUT gin_bson_consistent boolean).
func GinBsonConsistent(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}, anonymous12 struct{}, anonymous123 int32, anonymous1234 struct{}, anonymous12345 struct{}) (outGinBsonConsistent bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_consistent", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_consistent FROM documentdb_api_catalog.gin_bson_consistent($1, $2, $3, $4, $5, $6)", anonymous, anonymous1, anonymous12, anonymous123, anonymous1234, anonymous12345)
	if err = row.Scan(&outGinBsonConsistent); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_consistent", l)
	}
	return
}

// GinBsonExclusionPreConsistent is a wrapper for
//
//	documentdb_api_catalog.gin_bson_exclusion_pre_consistent(anonymous internal, anonymous1 smallint, anonymous12 documentdb_api_catalog.shard_key_and_document, anonymous123 integer, anonymous1234 internal, anonymous12345 internal, anonymous123456 internal, anonymous1234567 internal).
func GinBsonExclusionPreConsistent(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}, anonymous12 struct{}, anonymous123 int32, anonymous1234 struct{}, anonymous12345 struct{}, anonymous123456 struct{}, anonymous1234567 struct{}) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_exclusion_pre_consistent", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.gin_bson_exclusion_pre_consistent($1, $2, $3, $4, $5, $6, $7, $8)", anonymous, anonymous1, anonymous12, anonymous123, anonymous1234, anonymous12345, anonymous123456, anonymous1234567)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_exclusion_pre_consistent", l)
	}
	return
}

// GinBsonExtractQuery is a wrapper for
//
//	documentdb_api_catalog.gin_bson_extract_query(anonymous documentdb_core.bson, anonymous1 internal, anonymous12 smallint, anonymous123 internal, anonymous1234 internal, anonymous12345 internal, anonymous123456 internal, OUT gin_bson_extract_query internal).
func GinBsonExtractQuery(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 struct{}, anonymous12 struct{}, anonymous123 struct{}, anonymous1234 struct{}, anonymous12345 struct{}, anonymous123456 struct{}) (outGinBsonExtractQuery struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_extract_query", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_extract_query FROM documentdb_api_catalog.gin_bson_extract_query($1::bytea, $2, $3, $4, $5, $6, $7)", anonymous, anonymous1, anonymous12, anonymous123, anonymous1234, anonymous12345, anonymous123456)
	if err = row.Scan(&outGinBsonExtractQuery); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_extract_query", l)
	}
	return
}

// GinBsonPreConsistent is a wrapper for
//
//	documentdb_api_catalog.gin_bson_pre_consistent(anonymous internal, anonymous1 smallint, anonymous12 documentdb_core.bson, anonymous123 integer, anonymous1234 internal, anonymous12345 internal, anonymous123456 internal, anonymous1234567 internal).
func GinBsonPreConsistent(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}, anonymous12 wirebson.RawDocument, anonymous123 int32, anonymous1234 struct{}, anonymous12345 struct{}, anonymous123456 struct{}, anonymous1234567 struct{}) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_pre_consistent", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.gin_bson_pre_consistent($1, $2, $3::bytea, $4, $5, $6, $7, $8)", anonymous, anonymous1, anonymous12, anonymous123, anonymous1234, anonymous12345, anonymous123456, anonymous1234567)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_pre_consistent", l)
	}
	return
}

// GinBsonSinglePathExtractValue is a wrapper for
//
//	documentdb_api_catalog.gin_bson_single_path_extract_value(anonymous documentdb_core.bson, anonymous1 internal, OUT gin_bson_single_path_extract_value internal).
func GinBsonSinglePathExtractValue(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 struct{}) (outGinBsonSinglePathExtractValue struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_single_path_extract_value", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_single_path_extract_value FROM documentdb_api_catalog.gin_bson_single_path_extract_value($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(&outGinBsonSinglePathExtractValue); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_single_path_extract_value", l)
	}
	return
}

// GinBsonSinglePathOptions is a wrapper for
//
//	documentdb_api_catalog.gin_bson_single_path_options(anonymous internal).
func GinBsonSinglePathOptions(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_single_path_options", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.gin_bson_single_path_options($1)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_single_path_options", l)
	}
	return
}

// GinBsonWildcardProjectExtractValue is a wrapper for
//
//	documentdb_api_catalog.gin_bson_wildcard_project_extract_value(anonymous documentdb_core.bson, anonymous1 internal, OUT gin_bson_wildcard_project_extract_value internal).
func GinBsonWildcardProjectExtractValue(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 struct{}) (outGinBsonWildcardProjectExtractValue struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_wildcard_project_extract_value", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_wildcard_project_extract_value FROM documentdb_api_catalog.gin_bson_wildcard_project_extract_value($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(&outGinBsonWildcardProjectExtractValue); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_wildcard_project_extract_value", l)
	}
	return
}

// GinBsonWildcardProjectOptions is a wrapper for
//
//	documentdb_api_catalog.gin_bson_wildcard_project_options(anonymous internal).
func GinBsonWildcardProjectOptions(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_wildcard_project_options", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_catalog.gin_bson_wildcard_project_options($1)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_wildcard_project_options", l)
	}
	return
}

// QueryMatchSupport is a wrapper for
//
//	documentdb_api_catalog.query_match_support(anonymous internal, OUT query_match_support internal).
func QueryMatchSupport(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outQueryMatchSupport struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.query_match_support", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT query_match_support FROM documentdb_api_catalog.query_match_support($1)", anonymous)
	if err = row.Scan(&outQueryMatchSupport); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.query_match_support", l)
	}
	return
}
