---
title: "How MongoDB compares arrays"
slug: ferretdb-compare-arrays
authors: [chi]
description: In this article, we explore in detail how MongoDB BSON arrays are compared.
keywords:
  - MongoDB sorting
  - MongoDB array comparison
image: /img/blog/ferretdb-how-mongodb-compares-arrays.jpg
unlisted: true
---

In this article, we explore in detail how MongoDB BSON arrays are compared.

![How MongoDB compares arrays](/img/blog/ferretdb-how-mongodb-compares-arrays.jpg)

<!--truncate-->

## Comparison of BSON

The purpose of comparing BSON values is to determine which value is greater or less than the other.
This comparison is used in various operations, such as sorting, filtering using the
`$lt`, `$gt`, `$lte` and `$gte` operators, as well as updating using `$max` and `$min` operators.
When comparing BSON values of the same type, the process is straightforward.
Also, when comparing values of different types, the [BSON Comparison Order](#bson-comparison-order)
is used to determine the result.
However, in the case of array comparison against other BSON value,
the comparison may use the BSON comparison order or an element from the array.

In this blog post, we will discuss the comparison of BSON values, with a focus on arrays.
We will provide examples to help clarify the process.

### BSON Comparison Order

BSON values have a defined order of comparison, listed from lowest to highest as follows:

1. Null
2. Numbers (ints, longs, doubles, decimals)
3. Symbol, String
4. Object
5. Array
6. BinData
7. ObjectId
8. Boolean
9. Date
10. Timestamp
11. Regular Expression

When comparing BSON values of different types, the BSON comparison order is used,
with array being an exception.
When comparing values of the same type, the specific comparison for that type is used.

### Comparing Arrays

When comparing BSON arrays, each index is iterated in order.
At each index, BSON comparison order is used then the values are compared.
If the values at a particular index are not equal, that result is used as the final comparison result.

If there are no more element in the array during the iteration,
then that array is considered smaller.

#### Example of Comparing Arrays

To compare two arrays, we compare each element in the arrays until we discover a difference.
For instance, when comparing the arrays `[3, 1, 'b']` and `[3, 'b', 'a']`,
the following steps are taken:

1. Compare `[3, 1, 'b']` and `[3, 'b', 'a']` using comparison order.
   They have the same BSON type; both are arrays.
2. Compare first index `3` and `3` using comparison order, both are numbers, and they are the same.
3. Compare next index, `1` and `'b'` using comparison order,
`1` is a number and less than string `'b'`.

So `[3, 1, 'b']` is less than `[3, 'b', 'a']`.

If an array has no more element to compare, the one with no more element is less.
For the same reason empty array is less than arrays with elements.

### Comparing Array and Other BSON Type

When comparing an array with other BSON types, it doesn't *always* use BSON comparison order
of array BSON type.
It often uses the greatest or the smallest value
from the array to compare against other BSON type.

In some cases, such as with the [`$max` and `$min` update operator](#comparison-in-update-operator),
the comparison order is used.
In other situations, such as [sorting](#comparison-in-sorting),
the [`$gt` and `$lt` filter operators](#comparison-in-filter-operator),
an element within the array is used to compare against other BSON type.

[Sorting](#comparison-in-sorting), used in `.sort()`, uses the following rules
to compare array and other BSON types.

* Ascending sort uses the smallest element of any BSON type from the array.
* Descending sort uses the largest element of any BSON type from the array.
* Empty array is less than null.

[Filtering](#comparison-in-filter-operator), commonly used in `$lt` and `$gt` operators,
applies the following rules to compare array and other BSON types.

* `$lt` uses the smallest element of the same BSON type as non-array from the array.
* `$gt` uses the largest element of the same BSON type as non-array from the array.
* Empty array should not match other BSON type.

[Updating](#comparison-in-update-operator) with `$max` and `$min` operators applies the following rules
to compare array and other BSON types.

* For array and other BSON type comparison, BSON comparison order is used.
* Empty array is greater than null using BSON comparison order.

#### Example of Ascending and Descending Sort

How does array compare with other BSON type using one of the array element?
In this example, `2` and `[3, 1]` are compared using ascending and descending sort.

##### Array and Other BSON Type Ascending Sort

The following steps show the ascending sort comparison for `2` and `[3, 1]`:

1. It gets the smallest element of array `[3, 1]` which is `1`.
2. It compares `2` and `1`, `2` is greater than `1`.

Therefore, when using ascending sort, `2` is greater than `[3, 1]`.

##### Array and Other BSON Type Descending Sort

The following steps show the descending sort comparison for  `2` and `[3, 1]`.

1. It gets the largest element of array `[3, 1]` which is `3`.
2. It compares `2` and `3`, `2` is less than `3`.

Therefore, when using descending sort,  `2` is less than `[3, 1]`.

It might seem confusing at first, but note that ascending sort uses the smallest element
from the array, and descending sort uses the largest element from the array.

For an empty array, it's a special case; an empty array is less than any BSON type.
In that case, `[]` is less than even `null` for [sorting](#comparison-in-sorting).

## Comparison in Sorting

Sorting used in `.sort()` sorts records by ascending or descending order,
but array behaves specially.

The following rules are used to compare array and other BSON types.

* Ascending sort uses the smallest element of any BSON type from the array.
* Descending sort uses the largest element of any BSON type from the array.
* Empty array is less than null.

### Sorting Array

Let's insert following records to see how arrays are sorted.

```js
db.mixedsort.insertMany([
  { _id: 'array-empty', v: [] },
  { _id: 'null', v: null },
  { _id: 'array-mixed', v: [ 'a', 'z', 0 ] },
  { _id: 'array-numbers', v: [ 10, 5 ] },
  { _id: 'array-strings', v: [ 'a' ] },
  { _id: 'string', v: 'b' }
])
```

Let's use ascending sort on `v`.
Ascending sort is indicated by `1`.

```js
db.mixedsort.find().sort({v: 1})
[
  { _id: 'array-empty', v: [] },              // empty array is the smallest
  { _id: 'null', v: null },                   // null is used for comparison
  { _id: 'array-mixed', v: [ 'a', 'z', 0 ] }, // 0 the smallest value is used for comparison
  { _id: 'array-numbers', v: [ 10, 5 ] },     // 5 the smallest value is used for comparison
  { _id: 'array-strings', v: [ 'a' ] },       // 'a' the smallest value is used for comparison
  { _id: 'string', v: 'b' }                   // 'b' is used for comparison
]
```

Ascending sort uses the smallest element from array for comparison.
For example, `array-mixed` record gets its smallest element `0` and uses
that to compare against other records.
Even though an array is greater than string in [BSON comparison order](#bson-comparison-order),
`array-strings` record is smaller than
`string` record because the smallest element `'a'` from `array-strings` and `'b'` from `string`
are compared.

Let's use descending sort on `v`.
Descending sort is indicated by `-1`.

```js
db.mixedsort.find().sort({v: -1})
[
  { _id: 'array-mixed', v: [ 'a', 'z', 0 ] }, // 'z' the largest value is used for comparison
  { _id: 'string', v: 'b' },                  // 'b' is used for comparison
  { _id: 'array-strings', v: [ 'a' ] },       // 'a' the largest value is used for comparison
  { _id: 'array-numbers', v: [ 10, 5 ] },     // 10 the largest value is used for comparison
  { _id: 'null', v: null },                   // null is used for comparison
  { _id: 'array-empty', v: [] }               // empty array is the smallest
]
```

Descending sort uses the largest element of the array.
For example, `array-mixed` record gets its largest element `'z'` and uses
that to compare against other records.

Descending sort is not the opposite order of ascending sort,
because the comparison element used from the array is different.

### Sorting Nested Array

Let's use following example to sort nested arrays.

```js
 db.nestedsort.insertMany([
  { _id: 'nested-number', v: [ [ 6, 1 ] ] },
  { _id: 'nested-null', v: [ ['g'], [ null ] ] },
  { _id: 'nested-mixed', v: [ [ true, 0, 'g' ] ] },
  { _id: 'nested-empty', v: [ [ 6, 2 ], [ ] ] }, 
  { _id: 'array-mixed', v: [ true, 0, 'g' ] }
])
```

For the ascending sort, nested array gets the smallest array inner array
and use that array for the comparison.

```js
db.nestedsort.find().sort({v: 1})
[
  { _id: 'array-mixed', v: [ true, 0, 'g' ] },     // 0 the smallest element is used for comparison.
  { _id: 'nested-empty', v: [ [ 6, 2 ], [] ] },    // [] the smallest element is used for comparison.
  { _id: 'nested-null', v: [ ['g'], [ null ] ] },  // [ null ] the smallest is used for comparison.
  { _id: 'nested-number', v: [ [ 6, 1 ] ] },       // [ 6, 1 ] is used for comparison.
  { _id: 'nested-mixed', v: [ [ true, 0, 'g' ] ] } // [ true, 0, 'g' ] is used for comparison.
]
```

When comparing two nested arrays, they are not iterated index by index.
Instead, the smallest inner array is selected and used as a basis for comparison with the other array.

For example, if comparison iterated each index of `nested-null` and `nested-number`,
the first index of the nested array `'g'` of `nested-null`
would be greater than `6` of `nested-number` using BSON comparison order.
The fact `nested-null` is smaller than `nested-number`
indicates that, even nested array to nested array comparison uses the smallest element from an array
for comparison.

Let's look at how `nested-null` and `nested-number` are compared.

1. `nested-null` is an array, get the smallest element `[ null ]`.
2. `nested-number` is an array, get the smallest element `[ 6, 1 ]`.
3. Compare `[ null ]` and `[ 6, 1 ]` using BSON comparison order, both are arrays.
4. Compare the first indexes of the array using BSON comparison order,
`null` is null type and less than number type `6`.

So `nested-null` is less than `nested-number`.

For a nested array to array comparison, BSON comparison order is used.
Unlike the behaviour of empty array being smaller than other BSON types,
this does not apply to nested empty array.
Let's look at how `array-mixed` and `nested-empty` are compared.

1. `array-mixed` is an array, get the smallest element `0`.
2. `nested-empty` is an array, get the smallest element `[]`.
3. Compare `0` and `[]` using BSON comparison order, `0` is number and less than array `[]`.

So `array-mixed` is less than `nested-empty`.

## Comparison in Filter Operator

[$gt and $lt](https://docs.ferretdb.io/basic_operations/read/#retrieve-documents-using-operator-queries)
filter operators select records that are greater than or less than the query.

Filtering used in `$lt` and `$gt` operators use following rules
to compare array and other BSON types.

* `$lt` uses the smallest element of the same BSON type as non-array from the array.
* `$gt` uses the largest element of the same BSON type as non-array from the array.
* Empty array should not match other BSON type.

Let's insert array records to apply `$lt` and `$gt` filters.

```js
db.mixedfilter.insertMany([
  { _id: 'array-empty', v: [] },
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] },
  { _id: 'array-string', v: [ 'd' ] },
  { _id: 'array-number', v: [ 10, 5 ] },
  { _id: 'string', v: 'b' },
  { _id: 'null', v: null }
])
```

`$lt` selects records that are less than a specified value but this is only applied
to the same BSON type.
Let's look at filtering less than `'c'`.

```js
db.mixedfilter.find({v: {$lt: 'c'}})
[
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // 'a' the smallest string is used for comparison.
  { _id: 'string', v: 'b' }                   // 'b' is used for comparison.
]
```

The records selected are string BSON type `string` and array BSON type `array-mixed`.

* `string` was selected because `'b'` is less than `'c'`.
* `array-mixed` was selected because the smallest string of array `'a'` is less than `'c'`.
* `array-string` was not selected because the smallest element
of the array `'d'` is not less than `'c'`.
* `null` was not selected because is it not string BSON type.
* `array-empty` and `array-number` were not selected because they do not
  contain string BSON type.

Let's take a look at how `$gt` operator works with arrays.

`$gt` selects records that are greater than a specific value
and this is only applied to the same BSON type.
Let's look at filtering greater than `'c'`.

```js
db.mixedfilter.find({v: {$gt: 'c'}})
[
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // 'z' the largest string is used for comparison.
  { _id: 'array-string', v: [ 'd' ] }         // 'd' the largest string is used for comparison.
]
```

The records selected are `array-mixed` and `array-string`.

* `array-mixed` was selected because it contains `'z'` which is greater than `'c'`.
* `array-string` was selected  because it contains `'d'` which is greater than `'c'`.
* It does not select `string` because `'b'` is not greater than `'c'`.
* It also does not select `null` because is it not string BSON type.
* It does not select `array-empty` and `array-number` because the array does not contain string BSON type.

### Filtering Operator with Arrays

Let's use array filter to find records less than`['c']`.

```js
db.mixedfilter.find({v: {$lt: ['c']}})
[
  { _id: 'array-empty', v: [] },              // empty array is the smallest array
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // compares each element of [ 0, 'a', 'z' ]
  { _id: 'array-number', v: [ 10, 5 ] }       // compares each element of [ 10, 5 ]
]
```

When an array filter is applied, it only selects array BSON type.

The selected records are `array-empty`, `array-mixed` and `array-number`.

* `array-empty` is selected because empty array is the smallest array.
* `array-mixed` is selected by comparing each element iteratively and
the first element `0` is less than `'c'` in comparison order.
* `array-number` is selected by comparing each element iteratively and
first element `10` is less than `'c'` in comparison order.
* `array-string` is not selected because comparing the first element `'d'` is less not than `'c'`.
* `string` and `null` are not selected, they are not arrays.

Let's look at filtering greater than `['c']`.

```js
db.mixedfilter.find({v: {$gt: ['c']}})
[ { _id: 'array-string', v: [ 'd' ] } ] // compares each element of [ 'd' ]
```

The selected record is `array-string`.

* `array-string` is selected because comparing the first element `'d'` is greater than `'c'`.
* `array-empty` is not selected as empty array is the smallest array.
* `array-mixed` is not selected by comparing
each element and first element `0` is not greater than `'c'` in comparison order.
* `array-number` is not selected by comparing
each element and first element `10` is not greater than `'c'` in comparison order.
* `string` and `null` are not selected, they are not arrays.

### Filter Operator with Nested Array

Let's look at filtering nested array with an array.

```js
db.nestedfilter.insertMany([
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'a', 1 ] ] },
  { _id: 'nested-string', v: [ [ 'g', 'a' ] ] },
  { _id: 'nested-number', v: [ [ 10, 1 ] ] },
  { _id: 'array-bool', v: [ true ] },
  { _id: 'array-null', v: [ null ] }
])
```

First let's use non-array filter on them.

```js
db.nestedfilter.find({v: {$lt: 'c'}})

db.nestedfilter.find({v: {$gt: 'c'}})
```

Using non-array filter such as `'c'`, nothing was matched since `$gt` and `$lt`
does not find string BSON type within the array, they are all arrays.
For the case of `array-bool` and `array-null`, they are not string BSON type,
so neither of them were selected.

#### Filter Operator $lt with Nested Array

Let's use array filter `['c']` on `$lt` operator, we want to know how array compares to nested
array type.
As we've seen [Comparing Array and Other BSON Type](#comparing-array-and-other-bson-type),
comparing to array and other BSON type is where comparison behaves differently.
So comparing nested arrays using array filter would give us insights on
how nested array works with `$lt`.

```js
db.nestedfilter.find({v: {$lt: ['c']}})
[
  { _id: 'nested-empty', v: [ [] ] },         // [] the smallest array is used for comparison.
  { _id: 'nested-mixed', v: [ [ 'a', 1 ] ] }, // [ 'a', 1 ] the smallest array is used for comparison.
  { _id: 'nested-number', v: [ [ 10, 1 ] ] }, // [ 10, 1 ] the smallest array is used for comparison.
  { _id: 'array-null', v: [ null ] }          // null the smallest 
]
```

The selected records are `nested-empty`, `nested-mixed`, `nested-number` and `array-null`.

* `nested-empty` is selected because empty nested array is the smallest array.
* `nested-mixed` is selected because the first index of nested array `'a'` is less than `'c'`.
* `nested-number` is selected because the first index of nested array
  `10` is less than `'c'` in BSON comparison order.
* `array-null` is selected because `null` is less than string `'c'` in BSON comparison order.
* `nested-string` is not selected because `'g'` is not less than `'c'`.
* `array-bool` is not selected because boolean `true` is not less than
  string `'c'` in BSON comparison order.

Note that `nested-number` was selected even though the
first index of inner array does not contain string type.
It seems that `$lt` filter uses BSON comparison order for comparison type as long as
they are within an array, rather than filtering it out like other BSON types.
This also explains that `array-null` of `[ null ]` was selected, even though
the first element is null BSON type and different type from string BSON type`c`.
This shows that `$lt` comparison uses BSON comparison order for comparing elements of
two arrays.

#### Filter Operator $gt with Nested Array

:::note
This example shows an uncertain result of `$gt` operator
:::

Let's now use array filter `['c']` on `$gt` operator, we want to know how it works.

```js
db.nestedfilter.find({v: {$gt: ['c']}})
[
  { _id: 'nested-empty', v: [ [] ] },            // [] is array and greater in comparison order than string 'c'.
  { _id: 'nested-mixed', v: [ [ 'a', 1 ] ] },    // [ 'a', 1 ] is array and greater comparison order than string 'c'.
  { _id: 'nested-string', v: [ [ 'g', 'a' ] ] }, // [ 'g', 'a' ] is array and greater comparison order than string 'c'.
  { _id: 'nested-number', v: [ [ 10, 1 ] ] },    // [ 10, 1 ] is array and greater comparison order than string 'c'.
  { _id: 'array-bool', v: [ true ] }             // true is greater in comparison order than 'c'.
]
```

Using array filter `['c']` on `$gt` operator, it selected
`array-bool`, `nested-empty`, `nested-mixed`, `nested-string` and `nested-number` from the collection.
This shows that all nested arrays were selected.
It selected `array-bool` which has boolean BSON type `true`
that is greater than string `'c'` in BSON comparison order.

The selected nested arrays `nested-empty`, `nested-mixed`, `nested-string` and `nested-number` were
unexpected since the empty array particularly is not greater than other arrays
when we use the same logic as `$lt` operator on nested array.
The potential explanation is that `$gt` on nested array works on BSON comparison order
when filter is an array.
However, this is different behaviour from `$lt`, which seems to compare
the smallest element of an array instead of applying BSON comparison order.

We are yet to fully understand how nested array is expected to work with filter comparison operator.

## Comparison in Update Operator

Update operators `$max` and `$min` update the records that
satisfy the comparison condition.

The following rules apply for update operators when comparing array and other BSON types.

* For array and other BSON type comparison, BSON comparison order is used.
* Empty array is greater than null using BSON comparison order.

Let's use following example to update arrays using `$max` update operator.
The field `op` is used for the update operator to update multiple documents at once.

```js
db.updatemixed.insertMany([
  { _id: 'bool', v: true, op: true },
  { _id: 'array-string', v: [ 'b', 'h' ], op: true },
  { _id: 'array-mixed', v: [ 'g', 1 ], op: true },
  { _id: 'number', v: 4, op: true }
])
```

`$max` operator updates the document if the specified value is greater than
the value that exists in the document.
In this example `{$max: {v: 'c'}}` is used
and this updates document if specified value `'c'` is greater than the existing
value in the field `v` of documents.

```js
db.updatemixed.updateMany({op: true}, {$max: {v: 'c'}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 4,
  modifiedCount: 1,
  upsertedCount: 0
}
db.updatemixed.find()
[
  { _id: 'bool', v: true, op: true },
  { _id: 'array-string', v: [ 'b', 'h' ], op: true },
  { _id: 'array-mixed', v: [ 'g', 1 ], op: true },
  { _id: 'number', v: 'c', op: true }
]
```

The updated record is only `number`.

* `number` was updated, because BSON comparison order of string `'c'` is greater than number `4`.
* `array-string` and `array-mixed` were not updated because `'c'` is not greater than array
in BSON comparison order.
* `bool` was not updated because `'c'` is not greater than boolean in BSON comparison order.

For `$max` operator, it does not use element of an array for comparison unlike sorting
and comparison filter operator.

### Update Operator `$max` with Array

Let's use another collection to see how update operator works using array filter.

```js
db.updatearray.insertMany([
  { _id: 'bool', v: true, op: true },
  { _id: 'array-string', v: [ 'b', 'h' ], op: true },
  { _id: 'array-mixed', v: [ 'g', 1 ], op: true },
  { _id: 'number', v: 4, op: true }
])
```

In this example `{$max: {v: ['c']}}` is used
and this updates document if specified value `['c']` is greater than the existing
value in the field `v` of documents.

```js
db.updatearray.updateMany({op: true}, {$max: {v: ['c']}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 4,
  modifiedCount: 2,
  upsertedCount: 0
}
db.updatearray.find()
[
  { _id: 'bool', v: true, op: true },
  { _id: 'array-string', v: [ 'c' ], op: true },
  { _id: 'array-mixed', v: [ 'g', 1 ], op: true },
  { _id: 'number', v: [ 'c' ], op: true }
]
```

The records updated were `array-string` and `number`.
was used to compare array type of the update `number` was updated because array `['c']` is greater
in BSON comparison order than `number`.

* `bool` was not updated because array `['c']` is not greater than boolean
`true` in BSON comparison order.
* `array-string` was updated because the first index `'c'` is greater than
the first index of array `'b'`.
* `array-mixed` was not updated because `'c'` is not greater than `'g'`.
* `number` was updated because array `['c']` is greater than number in BSON comparison order.

### Update Operator with Nested Array

Let's add nested array to use `$max` operator to update the collection.

```js
db.updatenested.insertMany([
  { _id: 'bool', v: [ [ true ] ], op: true },
  { _id: 'array-string', v: [ [ 'b', 'g' ] ], op: true },
  { _id: 'array', v: [ [ 'g', 1 ] ], op: true },
  { _id: 'number', v: [ 4 ], op: true }
])
```

Here we use array update operator `{$max: {v: ['c']}}`, because comparison of array and
other type is where comparison behaves differently.

```js
db.updatenested.updateMany({op: true}, {$max: {v: ['c']}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 4,
  modifiedCount: 1,
  upsertedCount: 0
}
db.updatenested.find()
[
  { _id: 'bool', v: [ [ true ] ], op: true },
  { _id: 'array-string', v: [ [ 'b', 'g' ] ], op: true },
  { _id: 'array', v: [ [ 'g', 1 ] ], op: true },
  { _id: 'number', v: [ 'c' ], op: true }
]
```

The updated record is `number` only

* `number` was updated because the first index of `['c']`, string `'c'` has
greater BSON comparison order than number `4`.
* `bool`, `array-string` and `array` were not updated since the first index of `['c']`
string does not have greater BSON comparison order than array.

From this example, we understand that `$max` purely uses BSON comparison order for
comparing other BSON types and array does not take special role.

## Why Nested Array is not Supported at FerretDB

At FerretDB, we do not support nested array at the moment.
We did not initially support nested array due to complexities raised by
differences in the comparison of
[array and other BSON type](#comparing-array-and-other-bson-type).
In particular, differentiating cases where BSON comparison order of the array is used
verses an element from an array is used for comparison was not trivial at first.
Since then, we took time to understand under the hood of comparison for different operations.

Finally, we found out that nested array has not trivial behaviour on
[`$gt` operator](#filter-operator-gt-with-nested-array).
A typical assumption
on how `$gt` may work with nested array would be similar to how `$lt` works
with nested array, but using the largest element.
This was not the case, and
we are yet to find out how it should function.
Perhaps using `$gt` in nested array is not a common usage and the result
we found was a corner case.

If you have any questions or feedback, please [let us know](https://docs.ferretdb.io/#community)!
We're always here to help you get the most out of FerretDB.
