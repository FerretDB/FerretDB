---
title: "How MongoDB compares arrays in filtering"
slug: ferretdb-compare-arrays
authors: [chi]
description: "In this article, we explore in detail how MongoDB BSON arrays are compared
in filter operators."
keywords:
  - MongoDB $eq operator
  - MongoDB implicit match
  - MongoDB $lt operator
  - MongoDB $gt operator
  - MongoDB array element match
  - MongoDB array value match
image: /img/blog/ferretdb-how-mongodb-compares-arrays.jpg
unlisted: true
---

In this article, we explore in detail how MongoDB BSON arrays are compared in filter operators.

![How MongoDB compares arrays](/img/blog/ferretdb-how-mongodb-compares-arrays.jpg)

<!--truncate-->

## Understanding BSON Comparison for Filtering

The purpose of comparing BSON values is to determine which value is
equal, greater or less than the other.
The comparison is used in various operations, such as sorting, filter operators,
as well as update operators.

In this blog post, we will discuss the comparison of BSON values used in filter operators,
with a focus on arrays.
We will provide examples to help clarify the process.

### Terminology

**Smallest element** - The smallest element of an array that has the same BSON type
as the filter argument.

**Largest element** - The largest element of an array that has the same BSON type
as the filter argument.

**Array values** - A field of a document that holds an array.

### BSON Comparison Order

BSON values have a defined order of comparison, listed from lowest to highest as follows:

1. Null
2. Numbers
3. String
4. Object
5. Array
6. BinData
7. ObjectId
8. Boolean
9. Date
10. Timestamp
11. Regular Expression

All number types go through conversion, so they have the same BSON comparison order, regardless of
`double`, `int32`, `int64` or `decimal`.

The BSON comparison order is used for comparing different BSON types.
If BSON comparison order are equal, we compare their values, if not the operator has
logic to handle how to deal with it.
A BSON array may use an element from an array to compare with other BSON type.

### Comparison Rules of Filter

When the filter argument and the value in the document are not the same BSON type,
`$eq` operator does not match them. After all, the value is not the same as the filter argument.

In fact, both `$lt` and `$gt` operator also do not select BSON value that are not the same BSON type.

#### Example of Different BSON Type Comparison in `$lt`

For example if the filter argument is string, only strings are selected.

To compare different BSON type, we use `string` filter argument and
`number` in the document in the collection.
The following steps show `$lt` filter for comparing the filter argument `'a'` with `1`.

1. Compare `1` and `'a'` using BSON comparison order.
   They have different BSON type.
2. They cannot be compared using `$lt` because they are not the same BSON type.

So `1` is *not* less than `'a'`.

This shows that `$lt` filter does not match if the BSON type is different.
This is important because BSON comparison order is used to filter out different
BSON type, but it does not use the BSON comparison order for `$lt` filter result.

#### Example of Array Value Comparison

When comparing an array filter argument with array values,
elements of array are iterated.
At each index, BSON comparison order is used then values are compared.
If the values at a particular index are not equal, that result is used as the final comparison result.
If there are no more elements in the array during the iteration,
then that array is considered smaller.

To compare array filter argument and array in the collection arrays,
we compare each element in the arrays until we discover a difference.
For instance the following steps show `$lt` filter for comparing
the filter argument `[3, 1, 'b']` with `[3, 'b', 'a']`.

1. Compare `[3, 1, 'b']` and `[3, 'b', 'a']` using comparison order.
   They have the same BSON type; both are arrays.
2. Compare first index `3` and `3` using comparison order, both are numbers, and they are the same.
3. Compare next index, `1` and `'b'` using comparison order,
   `1` is a number and less than string `'b'`.

So `[3, 1, 'b']` is less than `[3, 'b', 'a']`.

If an array has no more element to compare, the one with no more element is less.
For the same reason empty array is less than arrays with elements.

#### Example of Array Element Comparison

When using a filter argument comparing to an array,
an element from that array would be selected.
This is the case for both implicit operator and `$eq` operator.

For operators `$lt` and `$lte` the smallest element from the array in the collection
is used to compare against the filter argument.

For comparing a filter argument with array in the collection, `$lt` filter uses
the smallest element from the array.
The following steps show `$lt` filter for comparing filter argument `2`
and `[3, 1]` in the collection:

1. It gets the smallest element of array collection `[3, 1]` which is `1`.
2. It compares `1` with filter argument `2` and `1`, `1` is less than `2`.

Therefore, when using `$lt` filter, `[3, 1]` is less than `2`.

For operators `$gt` and `$gte` the largest element is used for comparison instead.

The following steps show `$gt` filter for comparing filter argument `2`
and `[3, 1]` in the collection:

1. It gets the largest element of array collection `[3, 1]` which is `3`.
2. It compares `3` with filter argument `2`, `3` is greater than `2`.

Therefore, when using `$gt` filter, `[3, 1]` is greater than `2`.

It might seem confusing at first, but note that `$lt` uses the smallest element
from the array, and `$gt` uses the largest element from the array.

Additionally, `$lt`, `$gt`, `$lte` and `$gte` uses BSON comparison order
to only select elements of the same BSON comparison order as the filter argument.

## Filter Operator Comparison

In this section, we use `mongosh` to show example of the comparison in filtering.

### Number Comparison

For the filter comparison, numbers `double`, `int32`, `int64` and `decimal` with
the same value are considered equal.

We use simple examples to demonstrate `int32` and `double` are selected by `$eq` operator and
implicit filter even though the type is different.

```js
db.numberexample.insertMany([
  { _id: 'scalar-int', v: Int32(1) },
  { _id: 'scalar-double', v: Double(1.0) },
])
```

We use implicit operator to select equal value from the collection.

```js
db.numberexample.find({ v: 1 })
[
  { _id: 'scalar-int', v: 1 },
  { _id: 'scalar-double', v: 1 }
]
```

It shows that `scalar-int` and `scalar-double` were selected, indicating different number types
in the collection do not matter as long as the value is the same.

In the following, we use filter argument of the Int32 type.

```js
db.numberexample.find({ v: Int32(1) })
[
  { _id: 'scalar-int', v: 1 },
  { _id: 'scalar-double', v: 1 }
]
```

It also selected both number types, the filter argument type does not matter as long as the
value is the same.

The `$eq` operator is equivalent of implicit operator for the number comparison.
The below shows usage on the same collection.

```js
db.numberexample.find({ v: {$eq: 1} })
[
  { _id: 'scalar-int', v: 1 },
  { _id: 'scalar-double', v: 1 }
]
```

For filter comparison, `double`, `int`, `long` and `decimal` are matched for the same value
regardless of the number type.

### `$eq` Operator Comparison

The operator `$eq` is equivalent of implicit operator except for the usage on regular expression.

We use following collection to demonstrate selected collection based on the filter argument.

```js
db.eqxample.insertMany([
  { _id: 'scalar-int', v: 1 },
  { _id: 'array-number', v: [ 0.1, 1 ] },
  { _id: 'array-int', v: [ 1 ] },
  { _id: 'nested-int', v: [ [ 1, 2 ] ] },
  { _id: 'nested-arrays', v: [ [ 0.1 ], [ 1 ] ] },
  { _id: 'nested-double', v: [ [ Double(1.0) ] ] },
  { _id: 'nested-number', v: [ [ 1.0, 1 ] ] }
])
```

#### `$eq` Operator with Scalar Argument

The operator `$eq` selects documents from the collection which has an equal value
or an array which contains the equal value.

```js
db.eqxample.find({v: {$eq: 1}})
[
  { _id: 'scalar-int', v: 1 },
  { _id: 'array-number', v: [ 0.1, 1 ] },
  { _id: 'array-int', v: [ 1 ] }
]
```

The selected `array-number` and `array-int` contains the filter argument `1` in the array.
The location of the value in the array does not matter.
For instance, `array-number` contains the equal value in the second index.

#### `$eq` Operator with Array Argument

Using array filter argument `[1]`, it selects an array which has the same value as the filter argument.

```js
db.eqxample.find({v: [1]})
[
  { _id: 'array-int', v: [ 1 ] },
  { _id: 'nested-arrays', v: [ [ 0.1 ], [ 1 ] ] },
  { _id: 'nested-double', v: [ [ 1 ] ] }
]
```

The selected `array-int` is the same as the filter argument.
The selected `nested-arrays` and `nested-double` contains an array that is the same as
the filter argument.

It did not select `scalar-int`, it's because `$eq` operator selects array collections which contain
the filter argument, but not the other way.

#### `eq` Operator with Nested Array Argument

We demonstrate using nested array filter to select from the collection.

```js
db.eqxample.find({v: [[1]]})
[
  { _id: 'nested-double', v: [ [ 1 ] ] }
]
```

The selected `nested-double` is the same as the filter.
It did not select `nested-number`
nor `nested-arrays` because the index to index comparison does not match exactly.
For the nested array filter, the collection has to match exactly to the filter.

### `$lt` Operator Comparison

[$lt](https://docs.ferretdb.io/basic_operations/read/#retrieve-documents-using-operator-queries)
filter operators select records that are less than the query.
We use following collection to demonstrate `$lt` filter argument.

```js
db.ltexample.insertMany([
  { _id: 'scalar-null', v: null },
  { _id: 'scalar-number', v: 1 },
  { _id: 'scalar-string', v: 'a' },
  { _id: 'array-empty', v: [] },
  { _id: 'array-null', v: [ null ] },
  { _id: 'array-mixed', v: [ 1, 'z', 'b' ] },
  { _id: 'array-string', v: [ 'd' ] },
  { _id: 'array-bool', v: [ false ] },
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'c' ], [ 1, 'z', 'b' ] ] },
  { _id: 'nested-string', v: [ [ 'g' ] ] },
  { _id: 'nested-bool', v: [ [ true ] ] }
])
```

#### `$lt` Operator with Scalar Argument

The operator `$lt` selects records that are less than a specified value of the same BSON type
as the filter argument.
When the filter argument is string, collections with string records
that has less value would be selected.

```js
db.ltexample.find({v: {$lt: 'c'}})
[
  { _id: 'scalar-string', v: 'a' },
  { _id: 'array-mixed', v: [ 1, 'z', 'b' ] }
]
```

The records selected are `scalar-string` and an array `array-mixed`.
The record `scalar-string` has smaller value than the filter argument.

An array record `array-mixed` was selected because the smallest element `b` is
less than the filter argument `c`.
The operator `$lt` on array collection uses the smallest element for the comparison.

When the collection array does not contain
the same BSON type as the filter argument such as `array-null`, no selection is made.

#### `$lt` Operator with Array Argument

When the filter argument is an array, collections with array records
that has less is selected.
It also selects nested arrays if the inner array is less than the filter argument.

The following example shows applying `$lt` operator with an array argument `['c']`.

```js
db.ltexample.find({v: {$lt: ['c']}})
[
  { _id: 'array-empty', v: [] },
  { _id: 'array-null', v: [ null ] },
  { _id: 'array-mixed', v: [ 1, 'z', 'b' ] },
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'c' ], [ 1, 'z', 'b' ] ] }
]
```

The filter argument selected arrays that are less
and nested arrays which contains an array that is less.

No scalar values were selected, because array argument only selects arrays.
So _contains_ condition
is applied on collection containing less than the filter argument, but not the other way around.

For selected `array-null` and `array-mixed` each indexes was compared against filter and both of them
has first index element that is less than filter argument using BSON comparison order.

An empty array is smaller than an array with items, so `array-empty` was selected.
The nested array `nested-empty` was also selected, this shows that `$lt` fetches the smallest
element from nested array and compares to its array filter.

For the selected `nested-mixed`, the smallest inner array `[ 1, 'z', 'b' ]` is used
to compare with the argument.
Using the same logic `nested-string` was not selected because
it does not contain an inner array smaller than the argument filter.

#### `$lt` Operator with Nested Array Argument

The following example shows applying `$lt` operator with a nested array argument `[['c']]`.

```js
db.ltexample.find({v: {$lt: [['c']]}})
[
  { _id: 'array-empty', v: [] },
  { _id: 'array-null', v: [ null ] },
  { _id: 'array-mixed', v: [ 1, 'z', 'b' ] },
  { _id: 'array-string', v: [ 'd' ] },
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'c' ], [ 1, 'z', 'b' ] ] },
  { _id: 'nested-string', v: [ [ 'g' ] ] }
]
```

No scalar values from the collection was selected as scalar values are not
array type.

For arrays that were selected, they are less than filter argument, upon comparing
each index.

For nested arrays, `nested-string` was selected even though the first element
of the inner array is not less than the argument filter.
This show that nested array argument and nested array in collections are not compared index to index.
Instead, it takes the smallest array from the nested array and that is used
to compare against the filter argument.
In the case of `nested-string`, the smallest inner array `['g']`
is used to compare with the filter argument `[['c']]`.
Using BSON comparison order to compare the first element `g` of string BSON type
which is smaller than array BSON type `['c']` of the filter argument.

An array that was not selected was `nested-bool` due to boolean BSON type being not less than
array BSON type in BSON comparison order.
For this, argument `[['c']]` was compared with the smallest
element of the nested array of `nested-bool` which is `[true]`.

### `$gt` Operator Comparison

[$gt](https://docs.ferretdb.io/basic_operations/read/#retrieve-documents-using-operator-queries)
filter operators select records that are greater than the query.

We use `gtexample` collection.

```js
db.gtexample.insertMany([
  { _id: 'scalar-null', v: null },
  { _id: 'scalar-number', v: 1 },
  { _id: 'scalar-string', v: 'a' },
  { _id: 'array-empty', v: [] },
  { _id: 'array-null', v: [ null ] },
  { _id: 'array-mixed', v: [ 1, 'z', 'b' ] },
  { _id: 'array-string', v: [ 'd' ] },
  { _id: 'array-bool', v: [ false ] },
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'c' ], [ 1, 'z', 'b' ] ] },
  { _id: 'nested-string', v: [ [ 'a' ] ] },
  { _id: 'nested-bool', v: [ [ true ] ] }
])
```

#### `$gt` Operator with Scalar Argument

The following uses `$gt` to select records that are greater than `'c'`.

```js
db.gtexample.find({v: {$gt: 'c'}})
[
  { _id: 'array-mixed', v: [ 1, 'z', 'b' ] },
  { _id: 'array-string', v: [ 'd' ] }
]
```

The records selected are `array-mixed` and `array-string`.
They are both arrays contain string BSON value that is greater than the filter argument of `c`.

It did not select arrays that does not contain string BSON type such as `array-null`.

No nested arrays were selected because array is not the same BSON type as string.

#### `$gt` Operator with Array Argument

The following demonstrates array filter argument `['c']` using `$gt`.

In the previous section, `$lt` array argument operator selected arrays that are less
and nested arrays that contains less.

:::note
This example shows an uncertain result of `$gt` operator
:::

```js
db.gtexample.find({v: {$gt: ['c']}})
[
  { _id: 'array-string', v: [ 'd' ] },
  { _id: 'array-bool', v: [ false ] },
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'c' ], [ 1, 'z', 'b' ] ] },
  { _id: 'nested-string', v: [ [ 'g', 'z' ] ] },
  { _id: 'nested-bool', v: [ [ true ] ] }
]
```

No scalar documents were selected.
This is the same as `$lt` behaviour on array argument
because array argument filter only selects array BSON type.

The selected arrays `array-bool` and `array-string` contain values that is
greater than the filter argument of `c` at its first index.
The arrays are compared
index to index using BSON comparison order then by value comparison.

For nested arrays, all nested array even an empty nested array `nested-empty` were selected.
This indicates that `$gt` on array argument filter does not select the largest
element from the nested array like `$lt` did.
It compares array filter argument and nested array in collection index to index
using BSON comparison order.
When this happens an array BSON type in the collection is
greater than string BSON type of the filter argument, so it selects all nested arrays.

This is significantly different behaviour from `$lt` filter with array argument,
recapping`$lt` used the smallest element from the nested array,
while `$gt` compares index to index.

We are yet to fully understand how nested array is expected to work with filter comparison operator.

#### `$gt` Operator with Nested Array Argument

:::note
This example also shows an uncertain result of `$gt` operator.
:::

The following example shows applying `$gt` operator with a nested array argument `[['c']]`.

```js
db.gtexample.find({v: {$gt: [['c']]}})
[
  { _id: 'array-bool', v: [ false ] },
  { _id: 'nested-mixed', v: [ [ 'c' ], [ 1, 'z', 'b' ] ] },
  { _id: 'nested-bool', v: [ [ true ] ] }
]
```

No scalar values from the collection was selected since the scalar values are not array type.

The selected array `array-bool` has boolean which greater BSON comparison order
than of array type, so comparison between `['c']` and the largest item from the array `false`
was used compare.
Using the BSON comparison order, boolean is greater than an array hence it was
selected.

For nested arrays in the collection, `nested-mixed` and `nested-bool`
were selected.
Recapping `$gt` on array filter argument, the index to index comparison is done.
For `nested-mixed`, it has the same element `['c']` at its first index, and
it also has item on the second index while argument filter does not, which makes it greater.
For `nested-bool`, it has boolean which is greater BSON comparison order than string of the
filter argument at its first index of the inner array, which makes it greater.

The nested array is compare index to index
unlike `$lt` which takes the smallest element from the array.

## Nested Array at FerretDB

At FerretDB, we do not support nested array at the moment.
We did not initially support nested array due to complexities raised by
differences in the comparison of
[array and other BSON type](#understanding-bson-comparison-for-filtering).
In particular, differentiating cases where BSON comparison order of the array is used
verses an element from an array is used for comparison was not trivial at first.
Since then, we took time to understand under the hood of comparison for different operations.

Finally, we found out that using array and nested array filter argument,
the difference on how comparison is done on [`$lt` operator](#lt-operator-with-array-argument)
and [`$gt` operator](#gt-operator-with-array-argument) on nested array collections are not trivial.
A typical assumption on how `$gt` and `$lt` would be they behave similarly.
However, given an array argument filer and nested array collection,
`$lt` uses the smallest element from nested array
and `$gt` on the other hand compares index to index of nested array collection.
Perhaps using comparison operators like `$lt` and `$gt` for nested array is
not a common usage and the result we found was a corner case.

If you have any questions or feedback, please [let us know](https://docs.ferretdb.io/#community)!
We're always here to help you get the most out of FerretDB.
