---
title: "How MongoDB compares arrays"
slug: ferretdb-compare-arrays
authors: [chi]
description: In this article, we explore in detail how MongoDB BSON arrays are compared in filter operators.
keywords:
  - MongoDB sorting
  - MongoDB array comparison
image: /img/blog/ferretdb-how-mongodb-compares-arrays.jpg
unlisted: true
---

In this article, we explore in detail how MongoDB BSON arrays are compared in filter operators.

![How MongoDB compares arrays](/img/blog/ferretdb-how-mongodb-compares-arrays.jpg)

<!--truncate-->

## Understanding BSON Comparison for Filtering

The purpose of comparing BSON values is to determine which value is
equal, greater or less than the other.
The comparison is used in various operations, such as sorting, filter operators,
as well as update operators.
When comparing BSON values of the same type, the process is straightforward.
Also, when comparing values of different types, the [BSON Comparison Order](#bson-comparison-order)
is used to determine the result.
However, in the case of array comparison against other BSON value,
the comparison may use the BSON comparison order or an element from the array.

In this blog post, we will discuss the comparison of BSON values used in filter operators,
with a focus on arrays.
We will provide examples to help clarify the process.

### BSON Comparison Order

BSON values have a defined order of comparison, listed from lowest to highest as follows:

1. Null
2. Numbers
3. String
4. Object
5. Array
6. BinData
7. ObjectId
8. Boolean
9. Date
10. Timestamp
11. Regular Expression

When comparing BSON values of different types, the BSON comparison order is used,
with array being an exception. We will discuss in detail in the following section.
When comparing values of the same type, the specific comparison for that type is used.

### Examples of Comparison Rules

When comparing BSON arrays, each index is iterated in order.
At each index, BSON comparison order is used when the values are compared.
If the values at a particular index are not equal, that result is used as the final comparison result.

If there are no more elements in the array during the iteration,
then that array is considered smaller.

When comparing an array with other BSON types, it doesn't *always* use BSON comparison order
of array BSON type.
It often uses the greatest or the smallest value
from the array to compare against other BSON type.

In case of filter operators an element within the array is used to compare against other BSON type.

Filtering used in [`$lt`](#lt-operator-comparison) and [`$gt`](#gt-operator-comparison) operators,
applies the following rules to compare array and other BSON types.

* `$lt` uses the smallest element of the same BSON type as non-array from the array.
* `$gt` uses the largest element of the same BSON type as non-array from the array.
* Empty array should not match other BSON type.

#### Example of Comparing Arrays

To compare two arrays, we compare each element in the arrays until we discover a difference.
For instance, when comparing the arrays `[3, 1, 'b']` and `[3, 'b', 'a']`,
the following steps are taken:

1. Compare `[3, 1, 'b']` and `[3, 'b', 'a']` using comparison order.
   They have the same BSON type; both are arrays.
2. Compare first index `3` and `3` using comparison order, both are numbers, and they are the same.
3. Compare next index, `1` and `'b'` using comparison order,
`1` is a number and less than string `'b'`.

So `[3, 1, 'b']` is less than `[3, 'b', 'a']`.

If an array has no more element to compare, the one with no more element is less.
For the same reason empty array is less than arrays with elements.

#### Example of Comparing Array and Other BSON Type

## Filter Operator Comparison

### `$eq` Operator Comparison

#### `$eq` Operator with Argument

#### `$eq` Operator with Array Argument

#### `$eq` Operator with Nested Array Argument

### `$lt` Operator Comparison

[$lt](https://docs.ferretdb.io/basic_operations/read/#retrieve-documents-using-operator-queries)
filter operators select records that are less than the query.

#### `$lt` Operator with Argument

Let's insert array records to apply `$lt` filter.

```js
db.mixedfilter.insertMany([
  { _id: 'array-empty', v: [] },
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] },
  { _id: 'array-string', v: [ 'd' ] },
  { _id: 'array-number', v: [ 10, 5 ] },
  { _id: 'string', v: 'b' },
  { _id: 'array-null', v: [null] },
  { _id: 'null', v: null }
])
```

`$lt` selects records that are less than a specified value but this is only applied
to the same BSON type.
Let's look at filtering less than `'c'`.

```js
db.mixedfilter.find({v: {$lt: 'c'}})
[
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // 'a' the smallest string is used for comparison.
  { _id: 'string', v: 'b' }                   // 'b' is used for comparison.
]
```

The records selected are string BSON type `string` and array BSON type `array-mixed`.

* `string` was selected because `'b'` is less than `'c'`.
* `array-mixed` was selected because the smallest string of array `'a'` is less than `'c'`.
* `array-string` was not selected because the smallest element
  of the array `'d'` is not less than `'c'`.
* `null` was not selected because is it not string BSON type.
* `array-empty` and `array-number` were not selected because they do not
  contain string BSON type.

Let's look at filtering nested array with an array.

```js
db.nestedfilter.insertMany([
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'a', 1 ] ] },
  { _id: 'nested-string', v: [ [ 'g', 'a' ] ] },
  { _id: 'nested-number', v: [ [ 10, 1 ] ] },
  { _id: 'array-bool', v: [ true ] },
  { _id: 'array-null', v: [ null ] }
])
```

First let's use non-array filter on them.

```js
db.nestedfilter.find({v: {$lt: 'c'}})

db.nestedfilter.find({v: {$gt: 'c'}})
```

Using non-array filter such as `'c'`, nothing was matched since `$gt` and `$lt`
does not find string BSON type within the array, they are all arrays.
For the case of `array-bool` and `array-null`, they are not string BSON type,
so neither of them were selected.

#### `$lt` Operator with Array Argument

Let's use array filter to find records less than`['c']`.

```js
db.mixedfilter.find({v: {$lt: ['c']}})
[
  { _id: 'array-empty', v: [] },              // empty array is the smallest array
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // compares each element of [ 0, 'a', 'z' ]
  { _id: 'array-number', v: [ 10, 5 ] }       // compares each element of [ 10, 5 ]
]
```

When an array filter is applied, it only selects array BSON type.

The selected records are `array-empty`, `array-mixed` and `array-number`.

* `array-empty` is selected because empty array is the smallest array.
* `array-mixed` is selected by comparing each element iteratively and
  the first element `0` is less than `'c'` in comparison order.
* `array-number` is selected by comparing each element iteratively and
  first element `10` is less than `'c'` in comparison order.
* `array-string` is not selected because comparing the first element `'d'` is less not than `'c'`.
* `string` and `null` are not selected, they are not arrays.

Let's use array filter `['c']` on `$lt` operator, we want to know how array compares to nested
array type.
As we've seen in
[comparison of array and other BSON type](#example-of-comparing-array-and-other-bson-type),
comparing to array and other BSON type is where comparison behaves differently.
So comparing nested arrays using array filter would give us insights on
how nested array works with `$lt`.

```js
db.nestedfilter.find({v: {$lt: ['c']}})
[
  { _id: 'nested-empty', v: [ [] ] },         // [] the smallest array is used for comparison.
  { _id: 'nested-mixed', v: [ [ 'a', 1 ] ] }, // [ 'a', 1 ] the smallest array is used for comparison.
  { _id: 'nested-number', v: [ [ 10, 1 ] ] }, // [ 10, 1 ] the smallest array is used for comparison.
  { _id: 'array-null', v: [ null ] }          // null the smallest 
]
```

The selected records are `nested-empty`, `nested-mixed`, `nested-number` and `array-null`.

* `nested-empty` is selected because empty nested array is the smallest array.
* `nested-mixed` is selected because the first index of nested array `'a'` is less than `'c'`.
* `nested-number` is selected because the first index of nested array
  `10` is less than `'c'` in BSON comparison order.
* `array-null` is selected because `null` is less than string `'c'` in BSON comparison order.
* `nested-string` is not selected because `'g'` is not less than `'c'`.
* `array-bool` is not selected because boolean `true` is not less than
  string `'c'` in BSON comparison order.

Note that `nested-number` was selected even though the
first index of inner array does not contain string type.
It seems that `$lt` filter uses BSON comparison order for comparison type as long as
they are within an array, rather than filtering it out like other BSON types.
This also explains that `array-null` of `[ null ]` was selected, even though
the first element is null BSON type and different type from string BSON type`c`.
This shows that `$lt` comparison uses BSON comparison order for comparing elements of
two arrays.

#### `$lt` Operator with Nested Array Argument

### `$gt` Operator Comparison

[$gt](https://docs.ferretdb.io/basic_operations/read/#retrieve-documents-using-operator-queries)
filter operators select records that are greater than the query.

#### `$gt` Operator with Argument

Let's insert array records to apply `$lt` filter.

```js
db.mixedfilter.insertMany([
  { _id: 'array-empty', v: [] },
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] },
  { _id: 'array-string', v: [ 'd' ] },
  { _id: 'array-number', v: [ 10, 5 ] },
  { _id: 'string', v: 'b' },
  { _id: 'null', v: null }
])
```

Let's take a look at how `$gt` operator works with arrays.

`$gt` selects records that are greater than a specific value
and this is only applied to the same BSON type.
Let's look at filtering greater than `'c'`.

```js
db.mixedfilter.find({v: {$gt: 'c'}})
[
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // 'z' the largest string is used for comparison.
  { _id: 'array-string', v: [ 'd' ] }         // 'd' the largest string is used for comparison.
]
```

The records selected are `array-mixed` and `array-string`.

* `array-mixed` was selected because it contains `'z'` which is greater than `'c'`.
* `array-string` was selected  because it contains `'d'` which is greater than `'c'`.
* It does not select `string` because `'b'` is not greater than `'c'`.
* It also does not select `null` because is it not string BSON type.
* It does not select `array-empty` and `array-number` because the array does not contain string BSON type.

#### `$gt` Operator with Array Argument

Let's look at filtering greater than `['c']`.

```js
db.mixedfilter.find({v: {$gt: ['c']}})
[ { _id: 'array-string', v: [ 'd' ] } ] // compares each element of [ 'd' ]
```

The selected record is `array-string`.

* `array-string` is selected because comparing the first element `'d'` is greater than `'c'`.
* `array-empty` is not selected as empty array is the smallest array.
* `array-mixed` is not selected by comparing
  each element and first element `0` is not greater than `'c'` in comparison order.
* `array-number` is not selected by comparing
  each element and first element `10` is not greater than `'c'` in comparison order.
* `string` and `null` are not selected, they are not arrays.

:::note
This example shows an uncertain result of `$gt` operator
:::

Let's now use array filter `['c']` on `$gt` operator, we want to know how it works.

```js
db.nestedfilter.find({v: {$gt: ['c']}})
[
  { _id: 'nested-empty', v: [ [] ] },            // [] is array and greater in comparison order than string 'c'.
  { _id: 'nested-mixed', v: [ [ 'a', 1 ] ] },    // [ 'a', 1 ] is array and greater comparison order than string 'c'.
  { _id: 'nested-string', v: [ [ 'g', 'a' ] ] }, // [ 'g', 'a' ] is array and greater comparison order than string 'c'.
  { _id: 'nested-number', v: [ [ 10, 1 ] ] },    // [ 10, 1 ] is array and greater comparison order than string 'c'.
  { _id: 'array-bool', v: [ true ] }             // true is greater in comparison order than 'c'.
]
```

Using array filter `['c']` on `$gt` operator, it selected
`array-bool`, `nested-empty`, `nested-mixed`, `nested-string` and `nested-number` from the collection.
This shows that all nested arrays were selected.
It selected `array-bool` which has boolean BSON type `true`
that is greater than string `'c'` in BSON comparison order.

The selected nested arrays `nested-empty`, `nested-mixed`, `nested-string` and `nested-number` were
unexpected since the empty array particularly is not greater than other arrays
when we use the same logic as `$lt` operator on nested array.
The potential explanation is that `$gt` on nested array works on BSON comparison order
when filter is an array.
However, this is different behaviour from `$lt`, which seems to compare
the smallest element of an array instead of applying BSON comparison order.

We are yet to fully understand how nested array is expected to work with filter comparison operator.

#### `$gt` Operator with Nested Array Argument

## Nested Array at FerretDB

At FerretDB, we do not support nested array at the moment.
We did not initially support nested array due to complexities raised by
differences in the comparison of
[array and other BSON type](#understanding-bson-comparison-for-filtering).
In particular, differentiating cases where BSON comparison order of the array is used
verses an element from an array is used for comparison was not trivial at first.
Since then, we took time to understand under the hood of comparison for different operations.

Finally, we found out that nested array has not trivial behaviour on
[`$gt` operator](#gt-operator-with-array-argument).
A typical assumption
on how `$gt` may work with nested array would be similar to how `$lt` works
with nested array, but using the largest element.
This was not the case, and
we are yet to find out how it should function.
Perhaps using `$gt` in nested array is not a common usage and the result
we found was a corner case.

If you have any questions or feedback, please [let us know](https://docs.ferretdb.io/#community)!
We're always here to help you get the most out of FerretDB.
