---
title: "How MongoDB compares arrays"
slug: ferretdb-compare-arrays
authors: [chi tag]
description: Find out how arrays are compared at FerretDB.
keywords:
  - MongoDB sorting
  - MongoDB comparison
  - MongoDB array comparison
image: /img/blog/ferretdb-how-mongodb-compares-arrays.jpg
tags: [tag1, tag2]
unlisted: true
---

Find out how BSON arrays are compared at FerretDB.

![Image alt description](/img/blog/ferretdb-how-mongodb-compares-arrays.jpg)

<!--truncate-->

## Comparison of BSON
The comparison of BSON is about finding which BSON value is greater or
less than the other BSON value.
Comparison is used in sorting, filtering using `$lt`, `$gt`, `lte` and `$gte` operators,
and updating using `$max` and `$min` operators.
Comparing the same BSON type is straight forward, comparing different BSON type
is also defined in [BSON Comparison Order](#BSON Comparison Order).
However, array comparison against non-array BSON type may use BSON comparison order,
or an element from the array to compare against non-array BSON value.

In this blog post, comparison of BSON values with special attention 
to array is shown with examples.

### BSON Comparison Order

BSON values are have comparison order from the lowest to the highest as it's listed in following.

1. Null
2. Numbers (ints, longs, doubles, decimals)
3. Symbol, String
4. Object
5. Array
6. BinData
7. ObjectId
8. Boolean
9. Date
10. Timestamp
11. Regular Expression

When the BSON types are different BSON comparison order is used,
when they are the same, the comparison specific to that type is used.

### Comparing arrays

When two BSON arrays are compared, each index is iterated in order to compare
BSON comparison order, when they are the say value of the type is compared.
As soon as they are different, that is used for the result of the comparison.

At any point during iterating arrays, if no more element exists in next index,
then that array is smaller.

#### Example 1
Two arrays compare each element of the array, until they are not the same.
For example comparing `[3, 1, 'b']` and `[3, 'b', 'a']` takes following steps.
1. Compare `[3, 1, 'b']` and `[3, 2, 'a']` using comparison order. They are the same, both are arrays.
2. Compare first index `3` and `3` using comparison order, they are the same, both are numbers.
3. Compare first index `3` and `3` using number comparison, they are the same.
4. Compare next index, `1` and `b` using comparison order, `1` is number and less than string `b`.
So `[3, 1, 'b']` is less than `[3, 'b', 'a']`.

If an array has no more element to compare, the one with more element is greater.
#### Example 2
For example comparing `[3, 1]` and `[3]` takes following steps.
1. Compare `[3, 1]` and `[3]` using comparison order, they are both arrays.
2. Compare first index `3` and `3` using comparison order, they are the same, both are numbers.
3. Compare first index `3` and `3` using number comparison, they are the same.
4. Compare next index, first array has `1` but second array does not have any element.
If one array no longer has index to compare, that array is less.
So `[3, 1]` is greater than `[3]`.

For the same reason empty array is less than arrays with elements.

### Compare array and other BSON type
Comparing array with other BSON types, it doesn't _always_ use
comparison order of array BSON type. It often uses the largest or the greatest value
from the array to compare against non-array type.

#### How array and other BSON type are compared
There is a case where comparison order is used such as
[$max and $min update operator](#max-min-update-operator).
For other cases [sorting](#sorting), [#gt and #lt filter operators](#gt-lt-filter-operator),
array uses an element inside an array to compare with other BSON type.

Sorting used in `.sort({<<field>>: <<order>>})` uses following rules
to compare array and other BSON types.
* for array and non-array comparison, ascending sort uses the smallest element of any type from the array.
* for array and non-array comparison, descending sort uses the largest element of any type from the array.
* empty array is less than null.

Filtering used in `$lt` and `$gt` operators use following rules
to compare array and other BSON types.
* for array and non-array comparison, `$lt` uses the smallest element of the same type as non-array BSON type from the array.
* for array and non-array comparison, `$gt` uses the largest element of the same type as non-array BSON type from the array.
* empty array should not match non-array BSON type.

Updating with `$max` and `$min` operators use following rules
to compare array and other BSON types.
* for array and non-array comparison, BSON comparison order is used.
* empty array is greater than null using BSON comparison order.

#### Example 1
For example, comparing `2` and `[3, 1]` the result is different based on ascending sort or descending sort.

Let's use ascending sort to compare `2` and `[3, 1]`.
1. It gets the smallest element of array `[3, 1]` which is `1`
2. It compares `2` and `1` and `1` is less.
So `[3, 1]` is less than `2`.

#### Example 2
Let's use descending sort to compare `2` and `[3, 1]`.
1. It gets the largest element of array `[3, 1]` which is `3`
2. It compares `2` and `3`, `3` is greater.
So `[3, 1]` is greater than `2`.

It might seem confusing at first, but ascending sort uses the smallest element
from the array and descending sort uses the largest element from the array.

For an empty array, it's a special case where empty array less than any BSON type.
So `[]` is less than even `null` for [sorting](#sorting),
[#gt and #lt filter operators](#gt-lt-filter-operator).

### Array within array comparison - nested array
Nested array is similar to an array for comparison.

For example, comparing empty nested array `[[1 'b']]` and `[['a' 2] ['c']]`.
1. Check comparison order of `[[1 'b']]` and `[['a' 2] ['c']]`, they are both array.
2. Check comparison order of the first index `[1 'b']` and `['a' 2]`, they are both array.
3. Check comparison order of the first index within the nested array `1` and `a`, `1` is number and `a` is string. The number is smaller in comparison order.
   So `[[1 'b']]` is less than `[['a' 2] ['c']]`.

## Examples

### Comparison in sorting
Sorting records by ascending or descending order uses comparison order,
but array behaves specially.
Ascending sort is indicated by `1`, and the smallest element from the array
is used for comparison.
`db.<<ollections>>.find({}).sort({<<field>>: 1})`

Sorting used in `.sort({<<field>>: <<order>>})` uses following rules
to compare array and other BSON types.
* for array and non-array comparison, ascending sort uses the smallest element of any type from the array.
* for array and non-array comparison, descending sort uses the largest element of any type from the array.
* empty array is less than null.

#### sorting array
Let's look at how ascending sort orders records using following example.
```js
test> db.mixedsort.insertMany([
{ _id: 'array-empty', v: [] },
{ _id: 'null', v: null },
{ _id: 'array-mixed', v: [ 0, 'a', 'z' ] },
{ _id: 'array-numbers', v: [ 10, 5 ] },
{ _id: 'array-strings', v: [ 'a' ] },
{ _id: 'string', v: 'b' }
])
```

The ascending sort uses the smallest element from array BSON type.
For example, `array-mixed` record gets its smallest element `0` and uses
that to compare against other records.
Even though array is greater than string in [BSON comparison order](#bson-comparison-order),
`{ _id: 'array-mixed', v: [ 0, 'a', 'z' ] }` record is smaller than
`{ _id: 'string', v: 'b' }` record using the smallest element from the array.


```js
db.mixedsort.find({}).sort({v: 1})
[
  { _id: 'array-empty', v: [] },              // empty array is the smallest
  { _id: 'null', v: null },                   // null is used for comparison
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // 0 the smallest value is used for comparison
  { _id: 'array-numbers', v: [ 10, 5 ] },     // 5 the smallest value is used for comparison
  { _id: 'array-strings', v: [ 'a' ] },       // `a` the greatest value is used for comparison
  { _id: 'string', v: 'b' }                   // `b` is used for comparison
]
```

For descending sort, the largest element of the array is used for comparison.
`db.collections.find({}).sort({<<field>>: -1})`

Let's look at how descending sort orders elements.
The ascending sort uses the largest element of an array BSON type.
For example, `array-mixed` record gets its largest element `z` and uses
that to compare against other records.
So descending sort is not the opposite order of ascending sort,
because the comparison element used from the array is different.
```js
db.mixedsort.find({}).sort({v: -1})
[
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // `z` the greatest value is used for comparison
  { _id: 'string', v: 'b' },                  // `b` is used for comparison
  { _id: 'array-strings', v: [ 'a' ] },       // `a` the greatest value is used for comparison
  { _id: 'array-numbers', v: [ 10, 5 ] },     // 10 the greatest value is used for comparison
  { _id: 'null', v: null },                   // null is used for comparison
  { _id: 'array-empty', v: [] }               // empty array is the smallest
]
```
#### sorting nested array

```js
 db.nestedsort.insertMany([
  { _id: 'nested-number', v: [ [ 6, 1 ] ] },
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ true, 0, 'g' ] ] },
  { _id: 'nested-null', v: [ [ 6, 2, null ] ] }
])
```

Unlike array comparison {### sorting array} which uses the largest or smallest element
from an array, nested array compares each index using comparison order
then compares the value.

For example, comparing `nested-number` and `nested-null`,
although `nested-null` has the smallest BSON type `null` in the nested array,
it is greater than `nested-number`.
Let's compare `nested-number` and `nested-null` step by step using ascending sort.
1. Compare the smallest element of nested array, they are `[ 6, 1 ]` and `[ 6, 2, null ]` and both are arrays.
2. Compare the first index of the array, they are `6` and `6` and the same.
3. Compare the second index of the array, first nested array has `1` and second has `2`
So `nested-number` is less than `nested-null`.

```js
db.nestedsort.find({}).sort({v: 1})
[
  { _id: 'nested-empty', v: [ [] ] },              // empty nested array is smaller
  { _id: 'nested-number', v: [ [ 6, 1 ] ] },       // compares each element of [ 6, 1 ]
  { _id: 'nested-null', v: [ [ 6, 2, null ] ] },   // compares each element of [ 6, 2, null ]
  { _id: 'nested-mixed', v: [ [ true, 0, 'g' ] ] } // compares each element of [ true, 0, 'g' ]
]
```

### Comparison in filter operator
[$gt, $lt, $gte and $lte](https://docs.ferretdb.io/basic_operations/read/#retrieve-documents-using-operator-queries) operators
select records that satisfy comparison condition.

Filtering used in `$lt` and `$gt` operators use following rules
to compare array and other BSON types.
* for array and non-array comparison, `$lt` uses the smallest element of the same type as non-array BSON type from the array.
* for array and non-array comparison, `$gt` uses the largest element of the same type as non-array BSON type from the array.
* empty array should not match non-array BSON type.

`$lt` selects records that are less than a specific value.
```js
db.mixedfilter.insertMany([
  { _id: 'array-empty', v: [] },
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] },
  { _id: 'array-strings', v: [ 'd' ] },
  { _id: 'array-numbers', v: [ 10, 5 ] },
  { _id: 'string', v: 'b' },
  { _id: 'null', v: null }
])
```

Let's look at filtering less than `c`.
The records selected are string BSON type `{ _id: 'string', v: 'b' }`
where `b` is less than `c`,
and also array BSON type `{ _id: 'array-mixed', v: [ 0, 'a', 'z' ] }` which
containing string BSON type `a` and `z` in its array.
`$lt` uses the smallest value `a` where `a` is less than `b`.
It does not match `{ _id: 'array-strings', v: [ 'd' ] }` because the smallest
element of the array `d` is not less than `c`.
It also does not select `[]`, `null` and `[10 5]` because
they are not string BSON type or the array does not
contain string BSON type, so `$lt` does not match the filter.
```js
db.mixedfilter.find({v: {$lt: 'c'}})
[
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // `a` the smallest string is compared to `c`
  { _id: 'string', v: 'b' }                   // `b` is compated to `c`
]
```

Let's look at filtering greater than `'c'`.
`$gt` uses the largest value of the same BSON type.
```js
test> db.mixedfilter.find({v: {$gt: 'c'}})
[
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // `z` the largest string is compared to `c`
  { _id: 'array-strings', v: [ 'd' ] }        // `d` the largest string is compared to `c`
]
```
#### Filtering array

Let's look at filtering less than `['c']`.
When an array filter is applied, it only selects array BSON type.
* `{ _id: 'array-empty', v: [] }` is selected as empty array is the smallest.
* `{ _id: 'array-mixed', v: [ 0, 'a', 'z' ] }` is selected by comparing 
  each element and first element `0` is less than `c` in comparison order.
* `{ _id: 'array-numbers', v: [ 10, 5 ] }` is selected by comparing
  each element and first element `0` is less than `c` in comparison order.
* `{ _id: 'array-strings', v: [ 'd' ] }` is not selected because comparing 
  the first element `d` is less not than `c`.
* `{ _id: 'string', v: 'b' }` and `{ _id: 'null', v: null }` are not selected,
  they are not arrays.

```js
db.mixedfilter.find({v:{$lt:['c']}})
[
  { _id: 'array-empty', v: [] },              // empty array is the smallest array
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // compares each element of [ 0, 'a', 'z' ]
  { _id: 'array-numbers', v: [ 10, 5 ] }      // compares each element of [ 10, 5 ]
]
```

Let's look at filtering greater than `['c']`.
It selects array BSON type and compares the array against `['c']`.
```js
db.mixedfilter.find({v: {$gt: ['c']}})
[ { _id: 'array-strings', v: [ 'd' ] } ] // compares each element of [ 'd' ]
```
#### Filtering nested array 
Let's look at filtering nested array with an array.
```js
db.nestedfilter.insertMany([
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'a', 1 ] ] },
  { _id: 'nested-string', v: [ [ 'g', 'a' ] ] },
  { _id: 'nested-number', v: [ [ 10, 1 ] ] },
  { _id: 'array-bool', v: [ true ] },
  { _id: 'array-null', v: [ null ] }
])
```
Using non-array filter such as `'c'`, nothing was matched since `$gt` and `$lt`
does not find string BSON type within the array, they are in the nested array.
```js
db.nestedfilter.find({v:{$lt: 'c'}})

db.nestedfilter.find({v:{$gt: 'c'}})
```

##### $lt
Using array filter `['c']` on `$lt` operator, it selected 
empty nested array `{ _id: 'nested-empty', v: [ [] ] }`
and `{ _id: 'nested-mixed', v: [ [ 'a', 1 ] ] }` which the nested array contains
smaller element `a` than filter `c` on its first index.
* selected `{ _id: 'nested-empty', v: [ [] ] }` because empty nested array is less.
* selected `{ _id: 'nested-mixed', v: [ [ 'a', 1 ] ] }` because first index of 
  nested array `a` is less than `c`.
* selected ` { _id: 'nested-number', v: [ [ 10, 1 ] ] }` because first index of nested array
 `10` is less than `c` in BSON comparison order.
* selected `{ _id: 'array-null', v: [ null ] }` because `null` less than string `c`
  in BSON comparison order.
* not selecting `{ _id: 'nested-string', v: [ [ 'g', 'a' ] ] }` because `g` is not
  less than `c`.
* not selecting `{ _id: 'array-bool', v: [ true ] }` because boolean is not less than
  string in BSON comparison order.
```js
db.nestedfilter.find({v:{$lt: ['c']}})
[
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'a', 1 ] ] },
  { _id: 'nested-number', v: [ [ 10, 1 ] ] },
  { _id: 'array-null', v: [ null ] }
]
```

##### $gt
Using array filter `['c']` on `$gt` operator, it selected all nested arrays
from the collection. This is unexpected since empty array
`{ _id: 'nested-empty', v: [ [] ] }` is expected to be smaller.
:::this example shows uncertain result of $gt operator:::
```js
db.nestedfilter.find({v:{$gt: ['c']}})
[
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'a', 1 ] ] },
  { _id: 'nested-string', v: [ [ 'g', 'a' ] ] },
  { _id: 'nested-number', v: [ [ 10, 1 ] ] },
  { _id: 'array-bool', v: [ true ] }
]
```

### Comparison in update operator
$max update operator update the record that satisfy the comparison condition.

Updating with `$max` and `$min` operators use following rules
to compare array and other BSON types.
* for array and non-array comparison, BSON comparison order is used.
* empty array is greater than null using BSON comparison order.

Let's use following example, field `op` is used for the 
update operator to update the collection at once.
```js
db.updatemixed.insertMany([
  { _id: 'bool', v: true, op: true },
  { _id: 'array-string', v: [ 'b', 'h' ], op: true },
  { _id: 'array-mixed', v: [ 'g', 1 ], op: true },
  { _id: 'number', v: 4, op: true }
])
```
The `$max` operator is applied to update where field `v` to `c` if `c` is greater
than the existing field value.
```js
db.updatemixed.updateMany({op:true},{$max: {v: 'c'}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 4,
  modifiedCount: 1,
  upsertedCount: 0
}
```

Only `{ _id: 'number', v: 'c', op: true }` was updated, because string BSON comparison
order of `c` is greater than number `4`.

No array was updated because array has greater BSON comparison order than string.
For `$max` operator, it does not use element of an array for comparison unlike sorting
and comparison filter operator.
```js
db.updatemixed.find({})
[
  { _id: 'bool', v: true, op: true },
  { _id: 'array-string', v: [ 'b', 'h' ], op: true },
  { _id: 'array-mixed', v: [ 'g', 1 ], op: true },
  { _id: 'number', v: 'c', op: true }
]
```

The `$max` operator is applied to update where field `v` to `['c']` if `['c']` is greater
than the existing field value.
```js
db.updatearray.insertMany([
  { _id: 'bool', v: true, op: true },
  { _id: 'array-string', v: [ 'b', 'h' ], op: true },
  { _id: 'array-mixed', v: [ 'g', 1 ], op: true },
  { _id: 'number', v: 4, op: true }
])
db.updatearray.updateMany({op:true},{$max: {v: ['c']}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 4,
  modifiedCount: 2,
  upsertedCount: 0
}
```

```js
db.updatearray.find()
[
  { _id: 'bool', v: true, op: true },
  { _id: 'array-string', v: [ 'c' ], op: true },
  { _id: 'array-mixed', v: [ 'g', 1 ], op: true },
  { _id: 'number', v: [ 'c' ], op: true }
]
```
`array-string` and `number` were updated by `$max`.
* `bool` was not updated because array `['c]` is not greater than boolean `true `in BSON comparison order.
* `array-string` was updated because `c` was greater than the first index of array `b`.
* `array-mixed` was not updated because `c` was not greater than `g`.
* `number` was updated because array is greater than number in BSON comparison order.

### Updating nested array
For nexted array `$max` works just like normal cases. 

```js
db.updatenested.insertMany([
  { _id: 'bool', v: [ [ true ] ], op: true },
  { _id: 'array-string', v: [ [ 'b', 'g' ] ], op: true },
  { _id: 'array', v: [ [ 'g', 1 ] ], op: true },
  { _id: 'number', v: [ 4 ], op: true }
])
db.updatenested.updateMany({op:true},{$max: {v: ['c']}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 4,
  modifiedCount: 1,
  upsertedCount: 0
}
```

Since array is greater in BSON comparison order than string,
no nested array were updated.
```js
db.updatenested.find()
[
  { _id: 'bool', v: [ [ true ] ], op: true },
  { _id: 'array-string', v: [ [ 'b', 'g' ] ], op: true },
  { _id: 'array', v: [ [ 'g', 1 ] ], op: true },
  { _id: 'number', v: [ 'c' ], op: true }
]
```

## Why nested array is not supported at FerretDB

At FerretDB, we do not support nested array at the moment.
We did not initially support nested array due to complexities and
difference in comparison of
[array with non-array BSON type](#compare-array-and-other-bson-type).
There is uncertainty on how filter such as `$gt` works on [nested BSON array](#$gt)
comparison.
