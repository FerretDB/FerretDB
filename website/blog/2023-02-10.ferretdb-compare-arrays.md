---
title: "How MongoDB compares arrays"
slug: ferretdb-compare-arrays
authors: [chi tag]
description: Find out how arrays are compared at FerretDB.
keywords:
  - MongoDB sorting
  - MongoDB comparison
  - MongoDB array comparison
image: /img/blog/ferretdb-how-mongodb-compares-arrays.jpg
tags: [tag1, tag2]
unlisted: true
---

Find out how BSON arrays are compared at FerretDB.

![Image alt description](/img/blog/ferretdb-how-mongodb-compares-arrays.jpg)

<!--truncate-->

## BSON Comparison Order {#bson-comparison-order}

Different BSON values are have comparison order from the lowest to the highest as it's listed in following.
It's documented in [MongoDB Comparison/Sort Order](https://www.mongodb.com/docs/manual/reference/bson-type-comparison-order/).

1. Null
2. Numbers (ints, longs, doubles, decimals)
3. Symbol, String
4. Object
5. Array
6. BinData
7. ObjectId
8. Boolean
9. Date
10. Timestamp
11. Regular Expression

The comparison of BSON uses BSON comparison order,
when the BSON type is the same, then the comparison specific to that type is used.

## Compare arrays

Array is no exception when comparing two arrays. It iterates each index to compare
BSON comparison order, when they are the say value of the type is compared.
As soon as they are different, that is used for the result of the comparison.

At any point during iterating arrays, if no more element exists in next index,
then that array is smaller.

Two arrays compare each element of the array, until they are not the same.
For example comparing `[3, 1, 'b']` and `[3, 'b', 'a']` takes following steps.
1. Compare `[3, 1, 'b']` and `[3, 2, 'a']` using comparison order. They are the same, both are arrays.
2. Compare first index `3` and `3` using comparison order, they are the same, both are numbers.
3. Compare first index `3` and `3` using number comparison, they are the same.
4. Compare next index, `1` and `b` using comparison order, `1` is number and less than string `b`.
So `[3, 1, 'b']` is less than `[3, 'b', 'a']`.

If an array has no more element to compare, the one with more element is greater.
For example comparing `[3, 1]` and `[3]` takes following steps.
1. Compare `[3, 1]` and `[3]` using comparison order, they are both arrays.
2. Compare first index `3` and `3` using comparison order, they are the same, both are numbers.
3. Compare first index `3` and `3` using number comparison, they are the same.
4. Compare next index, first array has `1` but second array does not have any element.
If one array no longer has index to compare, that array is less.
So `[3, 1]` is greater than `[3]`.

For the same reason empty array is less than arrays with elements.

## Compare array and other BSON type
Comparing array with other BSON types, it doesn't _always_ use comparison order of array BSON type.
There is a case where comparison order is used in
[$max and $min update operator](#max-min-update-operator).
For other cases [sorting](#sorting), [#gt and #lt filter operators](#gt-lt-filter-operator),
array uses an element inside an array to compare with other BSON type.
For example, comparing `2` and `[3, 1]` the result is different based on ascending sort or descending sort.

Let's use ascending sort to compare `2` and `[3, 1]`.
1. It gets the smallest element of array `[3, 1]` which is `1`
2. It compares `2` and `1` and `1` is less.
So `[3, 1]` is less than `2`.

Let's use descending sort to compare `2` and `[3, 1]`.
1. It gets the largest element of array `[3, 1]` which is `3`
2. It compares `2` and `3`, `3` is greater.
So `[3, 1]` is greater than `2`.

It might seem confusing at first, but ascending sort uses the smallest element
from the array and descending sort uses the largest element from the array.

For an empty array, it's a special case where empty array less than any BSON type.
So `[]` is less than even `null` for [sorting](#sorting),
[#gt and #lt filter operators](#gt-lt-filter-operator).

## Array within array comparison - nested array
Nested array is similar to an array for comparison.

For example, comparing empty nested array `[[1 'b']]` and `[['a' 2] ['c']]`.
1. Check comparison order of `[[1 'b']]` and `[['a' 2] ['c']]`, they are both array.
2. Check comparison order of the first index `[1 'b']` and `['a' 2]`, they are both array.
3. Check comparison order of the first index within the nested array `1` and `a`, `1` is number and `a` is string. The number is smaller in comparison order.
   So `[[1 'b']]` is less than `[['a' 2] ['c']]`.

## sorting
Sorting records by ascending or descending order uses comparison order,
but array behaves specially.
Ascending sort is indicated by `1`, and the smallest element from the array
is used for comparison.
`db.<<ollections>>.find({}).sort({<<field>>: 1})`

### sorting array
Let's look at how ascending sort orders records using following example.
```js
test> db.mixedsort.insertMany([
{ _id: 'array-empty', v: [] },
{ _id: 'null', v: null },
{ _id: 'array-mixed', v: [ 0, 'a', 'z' ] },
{ _id: 'array-numbers', v: [ 10, 5 ] },
{ _id: 'array-strings', v: [ 'a' ] },
{ _id: 'string', v: 'b' }
])
```

The ascending sort uses the smallest element from array BSON type.
For example, `array-mixed` record gets its smallest element `0` and uses
that to compare against other records.
Even though array is greater than string in [BSON comparison order](#bson-comparison-order),
`{ _id: 'array-mixed', v: [ 0, 'a', 'z' ] }` record is smaller than
`{ _id: 'string', v: 'b' }` record using the smallest element from the array.


```js
db.mixedsort.find({}).sort({v: 1})
[
  { _id: 'array-empty', v: [] },              // empty array is the smallest
  { _id: 'null', v: null },                   // null is used for comparison
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // 0 the smallest value is used for comparison
  { _id: 'array-numbers', v: [ 10, 5 ] },     // 5 the smallest value is used for comparison
  { _id: 'array-strings', v: [ 'a' ] },       // `a` the greatest value is used for comparison
  { _id: 'string', v: 'b' }                   // `b` is used for comparison
]
```

For descending sort, the largest element of the array is used for comparison.
`db.collections.find({}).sort({<<field>>: -1})`

Let's look at how descending sort orders elements.
The ascending sort uses the largest element of an array BSON type.
For example, `array-mixed` record gets its largest element `z` and uses
that to compare against other records.
So descending sort is not the opposite order of ascending sort,
because the comparison element used from the array is different.
```js
db.mixedsort.find({}).sort({v: -1})
[
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // `z` the greatest value is used for comparison
  { _id: 'string', v: 'b' },                  // `b` is used for comparison
  { _id: 'array-strings', v: [ 'a' ] },       // `a` the greatest value is used for comparison
  { _id: 'array-numbers', v: [ 10, 5 ] },     // 10 the greatest value is used for comparison
  { _id: 'null', v: null },                   // null is used for comparison
  { _id: 'array-empty', v: [] }               // empty array is the smallest
]
```
### sorting nested array

```js
 db.nestedsort.insertMany([
  { _id: 'nested-number', v: [ [ 6, 1 ] ] },
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ true, 0, 'g' ] ] },
  { _id: 'nested-null', v: [ [ 6, 2, null ] ] }
])
```

Unlike array comparison {### sorting array} which uses the largest or smallest element
from an array, nested array compares each index using comparison order
then compares the value.

For example, comparing `nested-number` and `nested-null`,
although `nested-null` has the smallest BSON type `null` in the nested array,
it is greater than `nested-number`.
Let's compare `nested-number` and `nested-null` step by step using ascending sort.
1. Compare the smallest element of nested array, they are `[ 6, 1 ]` and `[ 6, 2, null ]` and both are arrays.
2. Compare the first index of the array, they are `6` and `6` and the same.
3. Compare the second index of the array, first nested array has `1` and second has `2`
So `nested-number` is less than `nested-null`.

```js
db.nestedsort.find({}).sort({v: 1})
[
  { _id: 'nested-empty', v: [ [] ] },              // empty nested array is smaller
  { _id: 'nested-number', v: [ [ 6, 1 ] ] },       // compares each element of [ 6, 1 ]
  { _id: 'nested-null', v: [ [ 6, 2, null ] ] },   // compares each element of [ 6, 2, null ]
  { _id: 'nested-mixed', v: [ [ true, 0, 'g' ] ] } // compares each element of [ true, 0, 'g' ]
]
```

## $gt and $lt filter operators {#gt-lt-filter-operator}
[$gt, $lt, $gte and $lte](https://docs.ferretdb.io/basic_operations/read/#retrieve-documents-using-operator-queries) operators
select records that satisfy comparison condition.

`$lt` selects records that are less than a specific value.
```js
db.mixedfilter.insertMany([
  { _id: 'array-empty', v: [] },
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] },
  { _id: 'array-strings', v: [ 'd' ] },
  { _id: 'array-numbers', v: [ 10, 5 ] },
  { _id: 'string', v: 'b' },
  { _id: 'null', v: null }
])
```

Let's look at filtering less than `c`.
The records selected are string BSON type `{ _id: 'string', v: 'b' }`
where `b` is less than `c`,
and also array BSON type `{ _id: 'array-mixed', v: [ 0, 'a', 'z' ] }` which
containing string BSON type `a` and `z` in its array.
`$lt` uses the smallest value `a` where `a` is less than `b`.
It does not match `{ _id: 'array-strings', v: [ 'd' ] }` because the smallest
element of the array `d` is not less than `c`.
It also does not select `[]`, `null` and `[10 5]` because
they are not string BSON type or the array does not
contain string BSON type, so `$lt` does not match the filter.
```js
db.mixedfilter.find({v: {$lt: 'c'}})
[
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // `a` the smallest string is compared to `c`
  { _id: 'string', v: 'b' }                   // `b` is compated to `c`
]
```

Let's look at filtering greater than `'c'`.
`$gt` uses the largest value of the same BSON type.
```js
test> db.mixedfilter.find({v: {$gt: 'c'}})
[
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // `z` the largest string is compared to `c`
  { _id: 'array-strings', v: [ 'd' ] }        // `d` the largest string is compared to `c`
]
```
### Filtering array

Let's look at filtering less than `['c']`.
When an array filter is applied, it only selects array BSON type.
* `{ _id: 'array-empty', v: [] }` is selected as empty array is the smallest.
* `{ _id: 'array-mixed', v: [ 0, 'a', 'z' ] }` is selected by comparing 
  each element and first element `0` is less than `c` in comparison order.
* `{ _id: 'array-numbers', v: [ 10, 5 ] }` is selected by comparing
  each element and first element `0` is less than `c` in comparison order.
* `{ _id: 'array-strings', v: [ 'd' ] }` is not selected because comparing 
  the first element `d` is less not than `c`.
* `{ _id: 'string', v: 'b' }` and `{ _id: 'null', v: null }` are not selected,
  they are not arrays.

```js
db.mixedfilter.find({v:{$lt:['c']}})
[
  { _id: 'array-empty', v: [] },              // empty array is the smallest array
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // compares each element of [ 0, 'a', 'z' ]
  { _id: 'array-numbers', v: [ 10, 5 ] }      // compares each element of [ 10, 5 ]
]
```

Let's look at filtering greater than `['c']`.
It selects array BSON type and compares the array against `['c']`.
```js
db.mixedfilter.find({v: {$gt: ['c']}})
[ { _id: 'array-strings', v: [ 'd' ] } ] // compares each element of [ 'd' ]
```
### Filtering nested array 
Let's look at filtering nested array with an array.
```js
db.nestedfilter.insertMany([
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'a', 1 ] ] },
  { _id: 'nested-string', v: [ [ 'g', 'a' ] ] },
  { _id: 'nested-number', v: [ [ 10, 1 ] ] },
  { _id: 'array-bool', v: [ true ] },
  { _id: 'array-null', v: [ null ] }
])
```

Using array filter `['c']` on `$lt` operator, it selected 
empty nested array `{ _id: 'nested-empty', v: [ [] ] }`
and `{ _id: 'nested-mixed', v: [ [ 'a', 1 ] ] }` which the nested array contains
smaller element `a` than filter `c` on its first index.
* selected `{ _id: 'nested-empty', v: [ [] ] }` because empty nested array is less.
* selected `{ _id: 'nested-mixed', v: [ [ 'a', 1 ] ] }` because first index of 
  nested array `a` is less than `c`.
* selected ` { _id: 'nested-number', v: [ [ 10, 1 ] ] }` because first index of nested array
 `10` is less than `c` in BSON comparison order.
* selected `{ _id: 'array-null', v: [ null ] }` because `null` less than string `c`
  in BSON comparison order.
* not selecting `{ _id: 'nested-string', v: [ [ 'g', 'a' ] ] }` because `g` is not
  less than `c`.
* not selecting `{ _id: 'array-bool', v: [ true ] }` because boolean is not less than
  string in BSON comparison order.
```js
db.nestedfilter.find({v:{$lt: ['c']}})
[
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'a', 1 ] ] },
  { _id: 'nested-number', v: [ [ 10, 1 ] ] },
  { _id: 'array-null', v: [ null ] }
]
```

Using array filter `['c']` on `$gt` operator, it selected all nested arrays
from the collection. This is unexpected since empty array
`{ _id: 'nested-empty', v: [ [] ] }` is expected to be smaller. 

```js
db.nestedfilter.find({v:{$gt: ['c']}})
[
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'a', 1 ] ] },
  { _id: 'nested-string', v: [ [ 'g', 'a' ] ] },
  { _id: 'nested-number', v: [ [ 10, 1 ] ] },
  { _id: 'array-bool', v: [ true ] }
]
```

// TODO
```js
db.nestedfilter.find({v:{$lt: [['c']]}})
[
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'a', 1 ] ] },
  { _id: 'nested-string', v: [ [ 'g', 'a' ] ] },
  { _id: 'nested-number', v: [ [ 10, 1 ] ] }
]
```

```js
db.nestedfilter.find({v:{$gt: [['c']]}})
[
  { _id: 'nested-string', v: [ [ 'g', 'a' ] ] },
  { _id: 'array-bool', v: [ true ] }
]
```

## Update operator
$max update operator update the record that satisfy the comparison condition.

For example, using update operator 
`db.<<ollections>>.update({},{v: {$lt: 'c'}})`

Let's use following example, field `op` is used for the 
update operator to update the collection at once.
```js
db.updatemixed.insertMany([
  { _id: 'bool', v: true, op: true },
  { _id: 'array-string', v: [ 'b', 'h' ], op: true },
  { _id: 'array-mixed', v: [ 'g', 1 ], op: true },
  { _id: 'number', v: 4, op: true }
])
```
The `$max` operator is applied to update where field `v` to `c` if `c` is greater
than the existing field value.
```js
db.updatemixed.updateMany({op:true},{$max: {v: 'c'}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 4,
  modifiedCount: 1,
  upsertedCount: 0
}
```

Only `{ _id: 'number', v: 'c', op: true }` was updated, because string BSON comparison
order of `c` is greater than number `4`.

No array was updated because array has greater BSON comparison order than string.
For `$max` operator, it does not use element of an array for comparison unlike sorting
and comparison filter operator.
```js
db.updatemixed.find({})
[
  { _id: 'bool', v: true, op: true },
  { _id: 'array-string', v: [ 'b', 'h' ], op: true },
  { _id: 'array-mixed', v: [ 'g', 1 ], op: true },
  { _id: 'number', v: 'c', op: true }
]
```

Let's use array filter.
```js
db.updatearray.insertMany([
  { _id: 'bool', v: true, op: true },
  { _id: 'array-string', v: [ 'b', 'h' ], op: true },
  { _id: 'array-mixed', v: [ 'g', 1 ], op: true },
  { _id: 'number', v: 4, op: true }
])
```

The `$max` operator is applied to update where field `v` to `['c']` if `['c']` is greater
than the existing field value.
```js
db.updatearray.updateMany({op:true},{$max: {v: ['c']}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 4,
  modifiedCount: 2,
  upsertedCount: 0
}
```
* `bool` was not updated because array `['c]` is not greater than boolean `true `in BSON comparison order.
* `array-string` was updated because `c` was greater than the first index of array `b`.
* `array-mixed` was not updated because `c` was not greater than `g`.
* `number` was updated because array is greater than number in BSON comparison order.

```js
db.updatearray.find()
[
  { _id: 'bool', v: true, op: true },
  { _id: 'array-string', v: [ 'c' ], op: true },
  { _id: 'array-mixed', v: [ 'g', 1 ], op: true },
  { _id: 'number', v: [ 'c' ], op: true }
]
```
### Nested array


```js
db.updatenested.insertMany([
  { _id: 'bool', v: [ [ true ] ], op: true },
  { _id: 'array-string', v: [ [ 'b', 'g' ] ], op: true },
  { _id: 'array', v: [ [ 'g', 1 ] ], op: true },
  { _id: 'number', v: [ 4 ], op: true }
])
```
```js
db.updatenested.updateMany({op:true},{$max: {v: ['c']}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 4,
  modifiedCount: 1,
  upsertedCount: 0
}
```

```js
db.updatenested.find()
[
  { _id: 'bool', v: [ [ true ] ], op: true },
  { _id: 'array-string', v: [ [ 'b', 'g' ] ], op: true },
  { _id: 'array', v: [ [ 'g', 1 ] ], op: true },
  { _id: 'number', v: [ 'c' ], op: true }
]
```

#### Using nested array filter

```js
db.updatenested.insertMany([
  { _id: 'bool', v: [ [ true ] ], op: true },
  { _id: 'array-string', v: [ [ 'b', 'g' ] ], op: true },
  { _id: 'array', v: [ [ 'g', 1 ] ], op: true },
  { _id: 'number', v: [ 4 ], op: true }
])
```

```js
db.updatenested.updateMany({op:true},{$max: {v: [['c']]}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 4,
  modifiedCount: 2,
  upsertedCount: 0
}
```

```js
db.updatenested.find()
[
  { _id: 'bool', v: [ [ true ] ], op: true },
  { _id: 'array-string', v: [ [ 'c' ] ], op: true },
  { _id: 'array', v: [ [ 'g', 1 ] ], op: true },
  { _id: 'number', v: [ [ 'c' ] ], op: true }
]
```



   