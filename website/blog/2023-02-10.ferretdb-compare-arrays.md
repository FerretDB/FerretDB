---
title: "How MongoDB compares arrays"
slug: ferretdb-compare-arrays
authors: [chi]
description: Find out how MongoDB BSON arrays are compared.
keywords:
  - MongoDB sorting
  - MongoDB array comparison
image: /img/blog/ferretdb-how-mongodb-compares-arrays.jpg
unlisted: true
---

Find out how MongoDB BSON arrays are compared.

![How MongoDB compares arrays](/img/blog/ferretdb-how-mongodb-compares-arrays.jpg)

<!--truncate-->

## Comparison of BSON

The purpose of comparing BSON values is to determine which value is greater or less than the other.
This comparison is used in various operations, such as sorting and filtering using the
 `$lt`, `$gt`, `lte` and `$gte` operators, as well as updating using `$max` and `$min` operators.
When comparing BSON values of the same type, the process is straightforward.
Also, when comparing values of different types, the [BSON Comparison Order](#bson-comparison-order) 
is used to determine the result.
However, in the case of array comparison against other BSON value, 
the comparison may use the BSON comparison order or an element from the array.

In this blog post, we will discuss the comparison of BSON values, with a focus on arrays.
We will provide examples to help clarify the process.

### BSON Comparison Order

BSON values have a defined order of comparison, listed from lowest to highest as follows:

1. Null
2. Numbers (ints, longs, doubles, decimals)
3. Symbol, String
4. Object
5. Array
6. BinData
7. ObjectId
8. Boolean
9. Date
10. Timestamp
11. Regular Expression

When comparing BSON values of different types, the BSON comparison order is used,
with array being an exception.
When comparing values of the same type, the specific comparison for that type is used.

### Comparing Arrays

When comparing BSON arrays, each index is iterated in order.
At each index BSON comparison order is used then the values are compared.
If the values at a particular index are not equal, that result is used as the final comparison result.

If there are no more elements in the array during the iteration,
then that array is considered smaller.

#### Example of Comparing Arrays

To compare two arrays, we evaluate each element in the arrays until we discover a difference.
For instance, when comparing the arrays `[3, 1, 'b']` and `[3, 'b', 'a']`,
the following steps are taken:

1. Compare `[3, 1, 'b']` and `[3, 'b', 'a']` using comparison order.
   They have the same BSON type; both are arrays.

2. Compare first index `3` and `3` using comparison order, both are numbers.
3. Compare values of the first index `3` and `3`, they are the same.
4. Compare next index, `1` and `'b'` using comparison order,
   `1` is a number and less than string `'b'`.

So `[3, 1, 'b']` is less than `[3, 'b', 'a']`.

If an array has no more element to compare, the one with no more element is less.
For the same reason empty array is less than arrays with elements.

### Comparing Array and Other BSON Type
When comparing an array with other BSON types, it doesn't *always* use comparison order of array BSON type.
It often uses the greatest or the smallest value
from the array to compare against other BSON type.

In some cases, such as with the [`$max` and `$min` update operator](#max-min-update-operator), 
the comparison order is used.
In other situations, such as [sorting](#sorting), 
the [`$gt` and `$lt` filter operators](#gt-lt-filter-operator),
an element within the array is used to compare against other BSON type.

[Sorting](#sorting)  used in `.sort({<<field>>: <<order>>})` uses following rules
to compare array and other BSON types.

* Ascending sort uses the smallest element of any BSON type from the array.
* Descending sort uses the largest element of any BSON type from the array.
* Empty array is less than null.

[Filtering](#gt-lt-filter-operator) used in `$lt` and `$gt` operators use following rules
to compare array and other BSON types.
* `$lt` uses the smallest element of the same BSON type as non-array from the array.
* `$gt` uses the largest element of the same BSON type as non-array from the array.
* Empty array should not match other BSON type.

[Updating](#max-min-update-operator) with `$max` and `$min` operators use following rules
to compare array and other BSON types.
* For array and other BSON type comparison, BSON comparison order is used.
* Empty array is greater than null using BSON comparison order.

#### Example of Using Ascending and Descending Sort
How does array compare with other BSON type using one of the array element?
In this example, `2` and `[3, 1]` are compared using ascending and descending sort.

##### Array and Other BSON Type Ascending Sort
Following steps use ascending sort to compare `2` and `[3, 1]`.

1. It gets the smallest element of array `[3, 1]` which is `1`
2. It compares `2` and `1`, `2` is greater than `1`.

So `2` is greater than `[3, 1]` using ascending sort.

##### Array and Other BSON Type Descending Sort
Following steps use descending sort to compare `2` and `[3, 1]`.

1. It gets the largest element of array `[3, 1]` which is `3`
2. It compares `2` and `3`, `2` is less than `3`.

So `2` is less than `[3, 1]` using descending sort.

It might seem confusing at first, but ascending sort uses the smallest element
from the array and descending sort uses the largest element from the array.

For an empty array, it's a special case where empty array less than any BSON type.
So `[]` is less than even `null` for [sorting](#comparison-in-sorting).

## Comparison in Sorting

Sorting used in `.sort({<<field>>: <<order>>})` sorts records by ascending or descending order,
but array behaves specially.

Following rules are used to compare array and other BSON types.

* Ascending sort uses the smallest element of any BSON type from the array.
* Descending sort uses the largest element of any BSON type from the array.
* Empty array is less than null.

### Sorting Array
Let's insert following records to see how arrays are sorted.

```js
db.mixedsort.insertMany([
{ _id: 'array-empty', v: [] },
{ _id: 'null', v: null },
{ _id: 'array-mixed', v: [ 'a', 'z', 0 ] },
{ _id: 'array-numbers', v: [ 10, 5 ] },
{ _id: 'array-strings', v: [ 'a' ] },
{ _id: 'string', v: 'b' }
])
```

Let's use ascending sort on `v`, ascending sort is indicated by `1`.

```js
db.mixedsort.find().sort({v: 1})
[
  { _id: 'array-empty', v: [] },              // empty array is the smallest
  { _id: 'null', v: null },                   // null is used for comparison
  { _id: 'array-mixed', v: [ 'a', 'z', 0 ] }, // 0 the smallest value is used for comparison
  { _id: 'array-numbers', v: [ 10, 5 ] },     // 5 the smallest value is used for comparison
  { _id: 'array-strings', v: [ 'a' ] },       // 'a' the smallest value is used for comparison
  { _id: 'string', v: 'b' }                   // 'b' is used for comparison
]
```
Ascending sort uses the smallest element from array for comparison.
For example, `array-mixed` record gets its smallest element `0` and uses
that to compare against other records.
Even though an array is greater than string in [BSON comparison order](#bson-comparison-order),
`array-strings` record is smaller than
`string` record because the smallest element `'a'` from `array-mixed` and `'b'` from `string`
are compared.


Let's use descending sort on `v`, descending sort is indicated by `-1`.

```js
db.mixedsort.find().sort({v: -1})
[
  { _id: 'array-mixed', v: [ 'a', 'z', 0 ] }, // 'z' the greatest value is used for comparison
  { _id: 'string', v: 'b' },                  // 'b' is used for comparison
  { _id: 'array-strings', v: [ 'a' ] },       // 'a' the greatest value is used for comparison
  { _id: 'array-numbers', v: [ 10, 5 ] },     // 10 the greatest value is used for comparison
  { _id: 'null', v: null },                   // null is used for comparison
  { _id: 'array-empty', v: [] }               // empty array is the smallest
]
```

Descending sort uses the largest element of the array.
For example, `array-mixed` record gets its largest element `'z'` and uses
that to compare against other records.

Descending sort is not the opposite order of ascending sort,
because the comparison element used from the array is different.

### Sorting Nested Array

Let's use following example to sort nested arrays.
```js
 db.nestedsort.insertMany([
  { _id: 'nested-number', v: [ [ 6, 1 ] ] },
  { _id: 'nested-null', v: [ ['g'], [ null ] ] },
  { _id: 'nested-mixed', v: [ [ true, 0, 'g' ] ] },
  { _id: 'nested-empty', v: [ [ 6, 2 ], [ ] ] }, 
  { _id: 'array-mixed', v: [ true, 0, 'g' ] }
])
```

Like [array](#sorting-array) nested array gets the largest or smallest element
from the array, but for the case of nested array it's the smallest inner array.

```js
db.nestedsort.find().sort({v: 1})
[
  { _id: 'array-mixed', v: [ true, 0, 'g' ] },     // 0 the smallest element is used for comparison.
  { _id: 'nested-empty', v: [ [ 6, 2 ], [] ] },    // [] the smallest element is used for comparison.
  { _id: 'nested-null', v: [ ['g'], [ null ] ] },  // [ null ] the smallest is used for comparison.
  { _id: 'nested-number', v: [ [ 6, 1 ] ] },       // [ 6, 1 ] is used for comparison.
  { _id: 'nested-mixed', v: [ [ true, 0, 'g' ] ] } // [ true, 0, 'g' ] is used for comparison.
]
```

When comparing two nested arrays, they do not iterate each index.
Instead, it gets the smallest inner array and uses that to compare with other array.

For example, if comparison iterated each index of `nested-null` and `nested-number`,
the first index of the nested array `'g'` of `nested-null` 
would be greater than `6` of `nested-number`. The fact `nested-null` is smaller than `nested-number`
indicates that, even nested array to nested array comparison uses the smallest element from an array
for comparison.

Let's look at how `nested-null` and `nested-number` are compared.

1. `nested-null` is an array, get the smallest element `[ null ]`.
2. `nested-number` is an array, get the smallest element `[ 6, 1 ]`.
3. Compare `[ null ]` and `[ 6, 1 ]` using BSON comparison order, both are arrays.
4. Compare the first indexes of the array using BSON comparison order,
   `null` is null type and less than number type `6`. 

So `nested-null` is less than `nested-number`.

For a nested array to array comparison, BSON comparison order is used.
Let's look at how `array-mixed` and `nested-empty` are compared.
1. `array-mixed` is an array, get the smallest element `0`.
2. `nested-empty` is an array, get the smallest element `[]`.
3. Compare `0` and `[]` using BSON comparison order, `0` is number and less than array `[]`.

So `array-mixed` is less than `nested-empty`.

## Comparison in Filter Operator

[$gt and $lt](https://docs.ferretdb.io/basic_operations/read/#retrieve-documents-using-operator-queries)
filter operators select records that are greater than or less than the query.

Filtering used in `$lt` and `$gt` operators use following rules
to compare array and other BSON types.

* `$lt` uses the smallest element of the same BSON type as non-array from the array.
* `$gt` uses the largest element of the same BSON type as non-array from the array.
* Empty array should not match other BSON type.

Let's insert array records to apply `$gt` and `$lt` filters.

```js
db.mixedfilter.insertMany([
  { _id: 'array-empty', v: [] },
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] },
  { _id: 'array-string', v: [ 'd' ] },
  { _id: 'array-number', v: [ 10, 5 ] },
  { _id: 'string', v: 'b' },
  { _id: 'null', v: null }
])
```

`$lt` selects records that are less than a specified value but this is only applied to the same BSON type. 
Let's look at filtering less than `'c'`.

```js
db.mixedfilter.find({v: {$lt: 'c'}})
[
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // 'a' the smallest string is used for comparison.
  { _id: 'string', v: 'b' }                   // 'b' is used for comparison.
]
```
The records selected are string BSON type `string` and array BSON type `array-mixed`.
`string` was selected because `'b'` is less than `'c'`.
`array-mixed` was selected because the smallest string of array `'a'` is less than `'c'`.

It does not select `array-string` because the smallest element of the array `'d'` is not less than `'c'`.
It also does not select `null` because is it not string BSON type.
It does not select `array-empty` and `array-number` because the array does not contain string BSON type.

Let's take a look at how `$gt` operator works with arrays.

`$gt` selects records that are greater than a specific value
and this is only applied to the same BSON type.
Let's look at filtering greater than `'c'`.

```js
db.mixedfilter.find({v: {$gt: 'c'}})
[
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // 'z' the largest string is used for comparison.
  { _id: 'array-string', v: [ 'd' ] }         // 'd' the largest string is used for comparison.
]
```

The records selected are `array-mixed` and `array-string`.

* `array-mixed` was selected because it contains `'z'` which is greater than `'c'`.
* `array-string` was selected  because it contains `'d'` which is greater than `'c'`.
* It does not select `string` because `'b'` is not greater than `'c'`.
* It also does not select `null` because is it not string BSON type.
* It does not select `array-empty` and `array-number` because the array does not contain string BSON type.

### Filtering Operator with Arrays

Let's use array filter to find records less than`['c']`.
When an array filter is applied, it only selects array BSON type.

```js
db.mixedfilter.find({v: {$lt: ['c']}})
[
  { _id: 'array-empty', v: [] },              // empty array is the smallest array
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // compares each element of [ 0, 'a', 'z' ]
  { _id: 'array-number', v: [ 10, 5 ] }       // compares each element of [ 10, 5 ]
]
```

The selected records are `array-empty`, `array-mixed` and `array-number`.
* `array-empty` is selected as empty array is the smallest.
* `array-mixed` is selected by comparing each element and 
first element `0` is less than `'c'` in comparison order.
* `array-number` is selected by comparing each element and 
first element `10` is less than `'c'` in comparison order.
* `array-string` is not selected because comparing  the first element `'d'` is less not than `'c'`.
* `string` and `null` are not selected, they are not arrays.


Let's look at filtering greater than `['c']`.

```js
db.mixedfilter.find({v: {$gt: ['c']}})
[ { _id: 'array-string', v: [ 'd' ] } ] // compares each element of [ 'd' ]
```

The selected record is `array-string`.

* `array-string` is selected because comparing
  the first element `'d'` is greater than `'c'`.
* `array-empty` is not selected as empty array is the smallest.
* `array-mixed` is not selected by comparing
  each element and first element `0` is not greater than `'c'` in comparison order.
* `array-number` is not selected by comparing
  each element and first element `10` is not greater than `'c'` in comparison order.
* `string` and `null` are not selected, they are not arrays.

### Filter Operator with Nested Array

Let's look at filtering nested array with an array.

```js
db.nestedfilter.insertMany([
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'a', 1 ] ] },
  { _id: 'nested-string', v: [ [ 'g', 'a' ] ] },
  { _id: 'nested-number', v: [ [ 10, 1 ] ] },
  { _id: 'array-bool', v: [ true ] },
  { _id: 'array-null', v: [ null ] }
])
```

First let's use non-array filter on them. 

```js
db.nestedfilter.find({v:{$lt: 'c'}})

db.nestedfilter.find({v:{$gt: 'c'}})
```
Using non-array filter such as `'c'`, nothing was matched since `$gt` and `$lt`
does not find string BSON type within the array, they are all arrays.
For the case of `array-bool` and `array-null`, they are not string BSON type so they
were not selected.

#### Filter Operator $lt with Nested Array

Let's use array filter `['c']` on `$lt` operator, we want to know how array compares to nested
array type.
As we've seen [Comparing Array and Other BSON Type](#comparing-array-and-other-bson-type),
comparing to array and other BSON type is where comparison behaves differently.
So comparing nested arrays using array filter would give us insights on
how nested array works with `$lt`.

```js
db.nestedfilter.find({v:{$lt: ['c']}})
[
  { _id: 'nested-empty', v: [ [] ] },         // [] the smallest array is used for comparison.
  { _id: 'nested-mixed', v: [ [ 'a', 1 ] ] }, // [ 'a', 1 ] the smallest array is used for comparison.
  { _id: 'nested-number', v: [ [ 10, 1 ] ] }, // [ 10, 1 ] the smallest array is used for comparison.
  { _id: 'array-null', v: [ null ] }          // null the smallest 
]
```

The selected records are `nested-empty`, `nested-mixed`, `nested-number` and `array-null`.

* `nested-empty` is selected because empty nested array is less.
* `nested-mixed` is selected because first index of nested array `'a'` is less than `'c'`.
* `nested-number` is selected because first index of nested array
  `10` is less than `'c'` in BSON comparison order.
* `array-null` is selected because `null` is less than array in BSON comparison order.
* `nested-string` is not selected because `'g'` is not less than `'c'`.
* `array-bool` is not selected because boolean is not less than
  string in BSON comparison order.

Let's highlight `nested-number` was selected even though the
first index of inner array does not contain string type.
It seems that `$lt` filter uses BSON comparison order for comparison type as long as
they are within an array, rather than filtering it out other BSON types.

#### Filter Operator $gt with Nested Array

:::note
This example shows an uncertain result of `$gt` operator
:::

Let's now use array filter `['c']` on `$gt` operator, we want to know how it works.

```js
db.nestedfilter.find({v:{$gt: ['c']}})
[
  { _id: 'nested-empty', v: [ [] ] },            // [] is array and greater in comparison order than 'c'.
  { _id: 'nested-mixed', v: [ [ 'a', 1 ] ] },    // [ 'a', 1 ] is array and greater comparison order than 'c'.
  { _id: 'nested-string', v: [ [ 'g', 'a' ] ] }, // [ 'g', 'a' ] is array and greater comparison order than 'c'.
  { _id: 'nested-number', v: [ [ 10, 1 ] ] },    // [ 10, 1 ] is array and greater comparison order than 'c'.
  { _id: 'array-bool', v: [ true ] }             // true is greater in comparison order than 'c'.
]
```

Using array filter `['c']` on `$gt` operator,
it selected `array-bool` which has boolean BSON type `true`
that is greater than string `'c'`. it selected.
It also selected all nested arrays 
`nested-empty`, `nested-mixed`, `nested-string` and `nested-number` from the collection.
The results `nested-empty`, `nested-mixed` and `nested-number` were 
unexpected since the empty array particularly are not greater than other arrays.
The potential explanation is that `$gt` on nested array works on BSON comparison order
when filter is an array. However, this is different behaviour from `$lt`, which seems to compare
the smallest element of an array.

## Comparison in Update Operator

Update operators `$max` and `$min` update the records that
satisfy the comparison condition.

Updating with `$max` and `$min` operators use following rules
to compare array and other BSON types.

* For array and other BSON type comparison, BSON comparison order is used.
* Empty array is greater than null using BSON comparison order.

Let's use following example to update arrays using `$max` update operator.
The field `op` is used for the update operator to update multiple documents at once.

```js
db.updatemixed.insertMany([
  { _id: 'bool', v: true, op: true },
  { _id: 'array-string', v: [ 'b', 'h' ], op: true },
  { _id: 'array-mixed', v: [ 'g', 1 ], op: true },
  { _id: 'number', v: 4, op: true }
])
```

`$max` operator updates the document if the specified value is greater than
the value exists in the document. In this example `{$max: {v: 'c'}}` is used
and this updates document if specified value `'c'` is greater than the existing
value in the field `v` of documents.

```js
db.updatemixed.updateMany({op:true}, {$max: {v: 'c'}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 4,
  modifiedCount: 1,
  upsertedCount: 0
}
db.updatemixed.find()
[
  { _id: 'bool', v: true, op: true },
  { _id: 'array-string', v: [ 'b', 'h' ], op: true },
  { _id: 'array-mixed', v: [ 'g', 1 ], op: true },
  { _id: 'number', v: 'c', op: true }
]
```

Only `number` was updated, because BSON comparison
order of string `'c'` is greater than number `4`.

No array was updated because array has greater BSON comparison order than string.
For `$max` operator, it does not use element of an array for comparison unlike sorting
and comparison filter operator.

### Update Operator `$max` with Array

Let's use another collection to see how update operator works using array filter.

```js
db.updatearray.insertMany([
  { _id: 'bool', v: true, op: true },
  { _id: 'array-string', v: [ 'b', 'h' ], op: true },
  { _id: 'array-mixed', v: [ 'g', 1 ], op: true },
  { _id: 'number', v: 4, op: true }
])
```

In this example `{$max: {v: ['c']}}` is used
and this updates document if specified value `['c']` is greater than the existing
value in the field `v` of documents.


The records updated were `array-string` and `number`. `array-string` was updated by
iterating the first index of the array, and `'c'` was greater than existing value of `'b'`.
was used to compare array type of the update `number` was updated because array `['c']` is greater
in BSON comparison order than `number`.

```js
db.updatearray.updateMany({op:true},{$max: {v: ['c']}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 4,
  modifiedCount: 2,
  upsertedCount: 0
}
db.updatearray.find()
[
  { _id: 'bool', v: true, op: true },
  { _id: 'array-string', v: [ 'c' ], op: true },
  { _id: 'array-mixed', v: [ 'g', 1 ], op: true },
  { _id: 'number', v: [ 'c' ], op: true }
]
```

* `bool` was not updated because array `['c']` is not greater than boolean 
  `true` in BSON comparison order.
* `array-string` was updated because `'c'` was greater than the first index of array `'b'`.
* `array-mixed` was not updated because `'c'` was not greater than `'g'`.
* `number` was updated because number is not greater than array in BSON comparison order.

### Update Operator with Nested Array

Let's add nested array to use `$max` operator to update the collection.
```js
db.updatenested.insertMany([
  { _id: 'bool', v: [ [ true ] ], op: true },
  { _id: 'array-string', v: [ [ 'b', 'g' ] ], op: true },
  { _id: 'array', v: [ [ 'g', 1 ] ], op: true },
  { _id: 'number', v: [ 4 ], op: true }
])
```

Here we use array update operator `{$max: {v: ['c']}}`, because comparison of array and
other type is where comparison behaves differently.

```js
db.updatenested.updateMany({op:true},{$max: {v: ['c']}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 4,
  modifiedCount: 1,
  upsertedCount: 0
}
db.updatenested.find()
[
  { _id: 'bool', v: [ [ true ] ], op: true },
  { _id: 'array-string', v: [ [ 'b', 'g' ] ], op: true },
  { _id: 'array', v: [ [ 'g', 1 ] ], op: true },
  { _id: 'number', v: [ 'c' ], op: true }
]
```

`number` was updated because first index of `['c']`, string `'c'` has greater comparison order 
than number `4`.

No nested array were updated since array has greater BSON comparison order than string.

From this example, we understand that `$max` purely uses BSON comparison order for
comparing other BSON types and array does not take special role.

## Why Nested Array is not Supported at FerretDB

At FerretDB, we do not support nested array at the moment.
We did not initially support nested array due to complexities and
difference in comparison of
[array with non-array BSON type](#compare-array-and-other-bson-type).
There is uncertainty on how filter such as `$gt` works on [nested array](#nested-array-with-gt)
comparison.
