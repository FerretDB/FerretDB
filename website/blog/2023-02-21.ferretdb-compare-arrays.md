---
title: "How MongoDB compares arrays"
slug: ferretdb-compare-arrays
authors: [chi]
description: In this article, we explore in detail how MongoDB BSON arrays are compared in filter operators.
keywords:
  - MongoDB sorting
  - MongoDB array comparison
image: /img/blog/ferretdb-how-mongodb-compares-arrays.jpg
unlisted: true
---

In this article, we explore in detail how MongoDB BSON arrays are compared in filter operators.

![How MongoDB compares arrays](/img/blog/ferretdb-how-mongodb-compares-arrays.jpg)

<!--truncate-->

## Understanding BSON Comparison for Filtering

The purpose of comparing BSON values is to determine which value is
equal, greater or less than the other.
The comparison is used in various operations, such as sorting, filter operators,
as well as update operators.
When comparing BSON values of the same type, the process is straightforward.
Also, when comparing values of different types, the [BSON Comparison Order](#bson-comparison-order)
is used to determine the result.
However, in the case of array comparison against other BSON value,
the comparison may use the BSON comparison order or an element from the array.

In this blog post, we will discuss the comparison of BSON values used in filter operators,
with a focus on arrays.
We will provide examples to help clarify the process.

### BSON Comparison Order

BSON values have a defined order of comparison, listed from lowest to highest as follows:

1. Null
2. Numbers
3. String
4. Object
5. Array
6. BinData
7. ObjectId
8. Boolean
9. Date
10. Timestamp
11. Regular Expression

When comparing BSON values of different types, the BSON comparison order is used,
with array being an exception. We will discuss in detail in the following section.
When comparing values of the same type, the specific comparison for that type is used.

### Comparison Rules of Filter

When comparing BSON arrays, each index is iterated in order.
At each index, BSON comparison order is used when the values are compared.
If the values at a particular index are not equal, that result is used as the final comparison result.

If there are no more elements in the array during the iteration,
then that array is considered smaller.

When comparing an array with other BSON types, it doesn't *always* use BSON comparison order
of array BSON type.
It often uses the greatest or the smallest value from the array to compare against other BSON type.
Inequality between different BSON types could be explained, for example a number is not
equal to a string. In BSON comparison order, there is an order from the lowest to the highest
guiding us to which BSON type is less than or greater than the other.
However, this BSON comparison order is used for comparison filter using
`$lt`, `$gt`, `$lte` and `$gte` on different BSON types.
For example comparing a string and a number, a string would be greater than a number
if we use BSON comparison order. But `$gt` operator on a string and a number would not
result in a match. In this case, BSON comparison order is used to check that
values being compared are the same BSON type. If they are not the same,
`$lt`, `$gt`, `$lte` and `$gte` operators do not match. An array is an exception on this.

In case of filter operators an element within the array is used to compare against other BSON type.

Filtering used in [`$lt`](#lt-operator-comparison) and [`$gt`](#gt-operator-comparison) operators,
applies the following rules to compare array and other BSON types.

* `$lt` uses the smallest element of the same BSON type as non-array from the array.
* `$gt` uses the largest element of the same BSON type as non-array from the array.
* Empty array should not match other BSON type.

### Example of Comparison Rules of Filter

#### Example of Comparing Arrays

To compare two arrays, we compare each element in the arrays until we discover a difference.
For instance, when comparing the arrays `[3, 1, 'b']` and `[3, 'b', 'a']`,
the following steps are taken:

1. Compare `[3, 1, 'b']` and `[3, 'b', 'a']` using comparison order.
   They have the same BSON type; both are arrays.
2. Compare first index `3` and `3` using comparison order, both are numbers, and they are the same.
3. Compare next index, `1` and `'b'` using comparison order,
`1` is a number and less than string `'b'`.

So `[3, 1, 'b']` is less than `[3, 'b', 'a']`.

If an array has no more element to compare, the one with no more element is less.
For the same reason empty array is less than arrays with elements.

#### Example of Comparing Array and Other BSON Type

The following steps show `$lt` filter for comparing `2` and `[3, 1]`:

1. It gets the smallest element of array `[3, 1]` which is `1`.
2. It compares `2` and `1`, `2` is greater than `1`.

Therefore, when using ascending sort, `2` is greater than `[3, 1]`.

The following steps show `$gt` filter for comparing  `2` and `[3, 1]`.

1. It gets the largest element of array `[3, 1]` which is `3`.
2. It compares `2` and `3`, `2` is less than `3`.

Therefore, when using descending sort,  `2` is less than `[3, 1]`.

It might seem confusing at first, but note that `$lt` uses the smallest element
from the array, and `$gt` uses the largest element from the array.

## Filter Operator Comparison

In this section, we use `mongosh` to show example of the comparison in filtering.

### `$eq` Operator Comparison

#### `$eq` Operator with Scalar Argument

#### `$eq` Operator with Array Argument

#### `$eq` Operator with Nested Array Argument

### `$lt` Operator Comparison

[$lt](https://docs.ferretdb.io/basic_operations/read/#retrieve-documents-using-operator-queries)
filter operators select records that are less than the query.
Let's insert records to apply `$lt` filter.

```js
db.filterexample.insertMany([
  { _id: 'scalar-null', v: null },
  { _id: 'scalar-number', v: 1 },
  { _id: 'scalar-string', v: 'a' },
  { _id: 'array-empty', v: [] },
  { _id: 'array-null', v: [ null ] },
  { _id: 'array-mixed', v: [ 1, 'z', 'b' ] },
  { _id: 'array-string', v: [ 'd' ] },
  { _id: 'array-bool', v: [ false ] },
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'c' ], [ 1, 'z', 'b' ] ] },
  { _id: 'nested-string', v: [ [ 'g', 'z' ] ] },
  { _id: 'nested-bool', v: [ [ true ] ] }
])
```

#### `$lt` Operator with Scalar Argument

`$lt` selects records that are less than a specified value but this is only applied
to the same BSON type.
Let's look at filtering less than `'c'`.

```js
db.filterexample.find({v: {$lt: 'c'}})
[
  { _id: 'scalar-string', v: 'b' },          // 'b' is used for comparison.
  { _id: 'array-mixed', v: [ 1, 'z', 'b' ] } // 'b' the smallest string is used for comparison.
]
```

The records selected are string BSON type `string` and array BSON type `array-mixed`.

* `string` was selected because `'b'` is less than `'c'`.
* `array-mixed` was selected because the smallest string of array `'a'` is less than `'c'`.
* `array-string` was not selected because the smallest element
  of the array `'d'` is not less than `'c'`.
* `null` was not selected because is it not string BSON type.
* `array-empty` and `array-number` were not selected because they do not
  contain string BSON type.

An array `array-mixed` was selected, because it contains a string element which can be compared
with the filter argument.
It uses the smallest string BSON type element to compare with the argument.

Using non-array filter such as `'c'`, no nested array was matched since `$lt`
does not find string BSON type within the array, they are all arrays.
For the case of `array-bool` and `array-null`, they are not string BSON type,
so neither of them were selected.

#### `$lt` Operator with Array Argument

Let's use array filter to find records less than`['c']`.

```js
db.filterexample.find({v: {$lt: ['c']}})
[
  { _id: 'array-empty', v: [] },
  { _id: 'array-null', v: [ null ] },
  { _id: 'array-mixed', v: [ 1, 'z', 'b' ] },
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 'c' ], [ 1, 'z', 'b' ] ] }
]
```

No scalar values were selected, because array `[c]` is greater in the BSON comparison order
than null, number and string types.
The fact that `scalar-string` was not selected shows that when the filter argument 
is array, it does not use its element to compare with scalar value.
This is indicates that only array collection element is used for
comparison and not array argument element.

For comparison with array collections, each index of arrays were compared with
BSON comparison order and value comparison.

For comparison with nested array, the smallest inner array is used for comparison.
Looking at `nested-mixed` being selected, despite first inner array is the same as the
filter argument, it shows that it used smaller of the inner array which is the
second inner array.
Comparing array argument filter with nested array collection uses the smallest
inner array for the comparison.

When an array filter is applied, it only selects array BSON type.

The selected records are `array-empty`, `array-mixed` and `array-number`.

As we've seen in
[comparison of array and other BSON type](#example-of-comparing-array-and-other-bson-type),
comparing to array and other BSON type is where comparison behaves differently.
So comparing nested arrays using array filter would give us insights on
how nested array works with `$lt`.

The selected records are `nested-empty`, `nested-mixed`, `nested-number` and `array-null`.

* `array-empty` is selected because empty array is the smallest array.
* `array-mixed` is selected by comparing each element iteratively and
  the first element `0` is less than `'c'` in comparison order.
* `array-number` is selected by comparing each element iteratively and
  first element `10` is less than `'c'` in comparison order.
* `array-string` is not selected because comparing the first element `'d'` is less not than `'c'`.
* `string` and `null` are not selected, they are not arrays.
* `nested-empty` is selected because empty nested array is the smallest array.
* `nested-mixed` is selected because the first index of nested array `'a'` is less than `'c'`.
* `nested-number` is selected because the first index of nested array
  `10` is less than `'c'` in BSON comparison order.
* `array-null` is selected because `null` is less than string `'c'` in BSON comparison order.
* `nested-string` is not selected because `'g'` is not less than `'c'`.

Note that `nested-number` was selected even though the
first index of inner array does not contain string type.
It seems that `$lt` filter uses BSON comparison order for comparison type as long as
they are within an array, rather than filtering it out like other BSON types.
This also explains that `array-null` of `[ null ]` was selected, even though
the first element is null BSON type and different type from string BSON type`c`.
This shows that `$lt` comparison uses BSON comparison order for comparing elements of
two arrays.

#### `$lt` Operator with Nested Array Argument

```js
db.filterexample.find({v: {$lt: [['c']]}})
[
  { _id: 'array-empty', v: [] },
  { _id: 'array-null', v: [ null ] },
  { _id: 'array-mixed', v: [ 1, 'z', 'b' ] },
  { _id: 'array-string', v: [ 'd' ] },
  { _id: 'nested-empty', v: [ [] ] },
  { _id: 'nested-mixed', v: [ [ 1, 'z', 'b' ], [ 'c' ] ] },
  { _id: 'nested-string', v: [ [ 'g', 'z' ] ] }
]
```

No scalar values from the collection was selected. This show that scalar values of the collection
are not the same type as an array type and were not selected.

An array that was not selected was `array-bool`. It has boolean which greater BSON comparison order
than of array type, so comparison between `[['c']]` and the smallest item `true`
was used compare.

For nested arrays, `nested-string` was selected even though the first element
within inner array is not less than the argument filter. This show that
nested array argument and nested array in collections are not compared index to index.
Instead, it takes the smallest array of from the nested array is used
to compare against the filter argument. In the case of `nested-string`, it is
the first inner array. So the comparison is between the filter argument `[['c']]` and 
smallest from the array `[ 1, 'z', 'b' ]`. Then it uses BSON comparison order to compare
the first element the number type of collection which is smaller than array type
of the filter argument.

An array that was not selected was `nested-bool` due to boolean type being not smaller than
array type in BSON comparison order. The argument `[['c']]` was compared with the smallest
element of the nested array of `nested-bool` which is `[true]`. 

### `$gt` Operator Comparison

[$gt](https://docs.ferretdb.io/basic_operations/read/#retrieve-documents-using-operator-queries)
filter operators select records that are greater than the query.

We use the same `filterexample` collection.

#### `$gt` Operator with Scalar Argument

Let's take a look at how `$gt` operator works with arrays.

`$gt` selects records that are greater than a specific value
and this is only applied to the same BSON type.
Let's look at filtering greater than `'c'`.

```js
db.filterexample.find({v: {$gt: 'c'}})
[
  { _id: 'array-mixed', v: [ 1, 'z', 'b' ] }, // 'z' the largest string is used for comparison.
  { _id: 'array-string', v: [ 'd' ] }         // 'd' the largest string is used for comparison.
]
```

The records selected are `array-mixed` and `array-string`.

* `array-mixed` was selected because it contains `'z'` which is greater than `'c'`.
* `array-string` was selected  because it contains `'d'` which is greater than `'c'`.
* It does not select `string` because `'b'` is not greater than `'c'`.
* It also does not select `null` because is it not string BSON type.
* It does not select `array-empty` and `array-number` because the array does not contain string BSON type.

#### `$gt` Operator with Array Argument

Let's look at filtering greater than `['c']`.

:::note
This example shows an uncertain result of `$gt` operator
:::

```js
db.filterexample.find({v: {$gt: ['c']}})
[
  { _id: 'array-string', v: [ 'd' ] },
  { _id: 'nested-empty', v: [ [] ] }, 
  { _id: 'nested-mixed', v: [ [ 1, 'z', 'b' ], [ 'c' ], [ 'a' ] ] },
  { _id: 'nested-string', v: [ [ 'g', 'z' ] ] }
]
```

```js
db.nestedfilter.find({v: {$gt: ['c']}})
[
  { _id: 'nested-empty', v: [ [] ] },            // [] is array and greater in comparison order than string 'c'.
  { _id: 'nested-mixed', v: [ [ 'a', 1 ] ] },    // [ 'a', 1 ] is array and greater comparison order than string 'c'.
  { _id: 'nested-string', v: [ [ 'g', 'a' ] ] }, // [ 'g', 'a' ] is array and greater comparison order than string 'c'.
  { _id: 'nested-number', v: [ [ 10, 1 ] ] },    // [ 10, 1 ] is array and greater comparison order than string 'c'.
  { _id: 'array-bool', v: [ true ] }             // true is greater in comparison order than 'c'.
]
```

The selected record is `array-string`.

* `array-string` is selected because comparing the first element `'d'` is greater than `'c'`.
* `array-empty` is not selected as empty array is the smallest array.
* `array-mixed` is not selected by comparing
  each element and first element `0` is not greater than `'c'` in comparison order.
* `array-number` is not selected by comparing
  each element and first element `10` is not greater than `'c'` in comparison order.
* `string` and `null` are not selected, they are not arrays.


Using array filter `['c']` on `$gt` operator, it selected
`array-bool`, `nested-empty`, `nested-mixed`, `nested-string` and `nested-number` from the collection.
This shows that all nested arrays were selected.
It selected `array-bool` which has boolean BSON type `true`
that is greater than string `'c'` in BSON comparison order.

The selected nested arrays `nested-empty`, `nested-mixed`, `nested-string` and `nested-number` were
unexpected since the empty array particularly is not greater than other arrays
when we use the same logic as `$lt` operator on nested array.
The potential explanation is that `$gt` on nested array works on BSON comparison order
when filter is an array.
However, this is different behaviour from `$lt`, which seems to compare
the smallest element of an array instead of applying BSON comparison order.

We are yet to fully understand how nested array is expected to work with filter comparison operator.

#### `$gt` Operator with Nested Array Argument

```js
db.filterexample.find({v: {$gt: [['c']]}})
[
  { _id: 'nested-string', v: [ [ 'g', 'z' ] ] }
]
```

## Nested Array at FerretDB

At FerretDB, we do not support nested array at the moment.
We did not initially support nested array due to complexities raised by
differences in the comparison of
[array and other BSON type](#understanding-bson-comparison-for-filtering).
In particular, differentiating cases where BSON comparison order of the array is used
verses an element from an array is used for comparison was not trivial at first.
Since then, we took time to understand under the hood of comparison for different operations.

Finally, we found out that nested array has not trivial behaviour on
[`$gt` operator](#gt-operator-with-array-argument).
A typical assumption
on how `$gt` may work with nested array would be similar to how `$lt` works
with nested array, but using the largest element.
This was not the case, and
we are yet to find out how it should function.
Perhaps using `$gt` in nested array is not a common usage and the result
we found was a corner case.

If you have any questions or feedback, please [let us know](https://docs.ferretdb.io/#community)!
We're always here to help you get the most out of FerretDB.
