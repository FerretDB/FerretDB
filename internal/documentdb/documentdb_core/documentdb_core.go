// Code generated by "genwrap -debug -schemas=documentdb_api,documentdb_api_catalog,documentdb_api_internal,documentdb_core"; DO NOT EDIT.

package documentdb_core

import (
	"context"
	"log/slog"
	"time"

	"github.com/FerretDB/wire/wirebson"
	"github.com/jackc/pgx/v5"
	"go.opentelemetry.io/otel"
	oteltrace "go.opentelemetry.io/otel/trace"

	"github.com/FerretDB/FerretDB/v2/internal/mongoerrors"
)

// BsonCompare is a wrapper for
//
//	[Comment] documentdb_core.bson_compare_16428.
func BsonCompare(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument, _ wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_compare", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_compare([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_compare", l)
	}
	return
}

// BsonEqual is a wrapper for
//
//	[Comment] documentdb_core.bson_equal_16429.
func BsonEqual(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument, _ wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_equal", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_equal([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_equal", l)
	}
	return
}

// BsonFromBytea is a wrapper for
//
//	[Comment] documentdb_core.bson_from_bytea_16401.
func BsonFromBytea(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_from_bytea", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_from_bytea([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_from_bytea", l)
	}
	return
}

// BsonGetValue is a wrapper for
//
//	[Comment] documentdb_core.bson_get_value_16399.
func BsonGetValue(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument, _ string) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_get_value", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_get_value([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_get_value", l)
	}
	return
}

// BsonGetValueText is a wrapper for
//
//	[Comment] documentdb_core.bson_get_value_text_16400.
func BsonGetValueText(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument, _ string) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_get_value_text", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_get_value_text([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_get_value_text", l)
	}
	return
}

// BsonGt is a wrapper for
//
//	[Comment] documentdb_core.bson_gt_16433.
func BsonGt(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument, _ wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_gt", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_gt([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_gt", l)
	}
	return
}

// BsonGte is a wrapper for
//
//	[Comment] documentdb_core.bson_gte_16434.
func BsonGte(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument, _ wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_gte", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_gte([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_gte", l)
	}
	return
}

// BsonHashInt4 is a wrapper for
//
//	[Comment] documentdb_core.bson_hash_int4_16468.
func BsonHashInt4(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_hash_int4", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_hash_int4([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_hash_int4", l)
	}
	return
}

// BsonHashInt8 is a wrapper for
//
//	[Comment] documentdb_core.bson_hash_int8_16469.
func BsonHashInt8(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument, _ int64) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_hash_int8", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_hash_int8([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_hash_int8", l)
	}
	return
}

// BsonHexToBson is a wrapper for
//
//	[Comment] documentdb_core.bson_hex_to_bson_16404.
func BsonHexToBson(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_hex_to_bson", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_hex_to_bson([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_hex_to_bson", l)
	}
	return
}

// BsonIn is a wrapper for
//
//	[Comment] documentdb_core.bson_in_16387.
func BsonIn(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_in", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_in([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_in", l)
	}
	return
}

// BsonInRangeInterval is a wrapper for
//
//	[Comment] documentdb_core.bson_in_range_interval_16437.
func BsonInRangeInterval(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument, _ wirebson.RawDocument, _ struct{}, _ bool, _ bool) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_in_range_interval", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_in_range_interval([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_in_range_interval", l)
	}
	return
}

// BsonInRangeNumeric is a wrapper for
//
//	[Comment] documentdb_core.bson_in_range_numeric_16436.
func BsonInRangeNumeric(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument, _ wirebson.RawDocument, _ wirebson.RawDocument, _ bool, _ bool) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_in_range_numeric", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_in_range_numeric([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_in_range_numeric", l)
	}
	return
}

// BsonJsonToBson is a wrapper for
//
//	[Comment] documentdb_core.bson_json_to_bson_16405.
func BsonJsonToBson(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ string) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_json_to_bson", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_json_to_bson([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_json_to_bson", l)
	}
	return
}

// BsonLt is a wrapper for
//
//	[Comment] documentdb_core.bson_lt_16431.
func BsonLt(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument, _ wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_lt", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_lt([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_lt", l)
	}
	return
}

// BsonLte is a wrapper for
//
//	[Comment] documentdb_core.bson_lte_16432.
func BsonLte(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument, _ wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_lte", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_lte([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_lte", l)
	}
	return
}

// BsonNotEqual is a wrapper for
//
//	[Comment] documentdb_core.bson_not_equal_16430.
func BsonNotEqual(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument, _ wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_not_equal", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_not_equal([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_not_equal", l)
	}
	return
}

// BsonObjectKeys is a wrapper for
//
//	[Comment] documentdb_core.bson_object_keys_16408.
func BsonObjectKeys(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_object_keys", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_object_keys([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_object_keys", l)
	}
	return
}

// BsonOperatorSelectivity is a wrapper for
//
//	[Comment] documentdb_core.bson_operator_selectivity_16425.
func BsonOperatorSelectivity(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}, _ struct{}, _ struct{}, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_operator_selectivity", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_operator_selectivity([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_operator_selectivity", l)
	}
	return
}

// BsonOut is a wrapper for
//
//	[Comment] documentdb_core.bson_out_16388.
func BsonOut(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_out", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_out([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_out", l)
	}
	return
}

// BsonRecv is a wrapper for
//
//	[Comment] documentdb_core.bson_recv_16390.
func BsonRecv(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_recv", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_recv([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_recv", l)
	}
	return
}

// BsonRepathAndBuild is a wrapper for
//
//	[Comment] documentdb_core.bson_repath_and_build_16409.
func BsonRepathAndBuild(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_repath_and_build", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_repath_and_build([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_repath_and_build", l)
	}
	return
}

// BsonSend is a wrapper for
//
//	[Comment] documentdb_core.bson_send_16389.
func BsonSend(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_send", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_send([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_send", l)
	}
	return
}

// BsonToBsonHex is a wrapper for
//
//	[Comment] documentdb_core.bson_to_bson_hex_16403.
func BsonToBsonHex(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_to_bson_hex", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_to_bson_hex([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_to_bson_hex", l)
	}
	return
}

// BsonToBsonsequence is a wrapper for
//
//	[Comment] documentdb_core.bson_to_bsonsequence_16414.
func BsonToBsonsequence(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_to_bsonsequence", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_to_bsonsequence([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_to_bsonsequence", l)
	}
	return
}

// BsonToBytea is a wrapper for
//
//	[Comment] documentdb_core.bson_to_bytea_16402.
func BsonToBytea(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_to_bytea", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_to_bytea([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_to_bytea", l)
	}
	return
}

// BsonToJsonString is a wrapper for
//
//	[Comment] documentdb_core.bson_to_json_string_16406.
func BsonToJsonString(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_to_json_string", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_to_json_string([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_to_json_string", l)
	}
	return
}

// BsonTypanalyze is a wrapper for
//
//	[Comment] documentdb_core.bson_typanalyze_16392.
func BsonTypanalyze(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_typanalyze", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_typanalyze([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_typanalyze", l)
	}
	return
}

// BsonUniqueIndexEqual is a wrapper for
//
//	[Comment] documentdb_core.bson_unique_index_equal_16435.
func BsonUniqueIndexEqual(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument, _ wirebson.RawDocument) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bson_unique_index_equal", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bson_unique_index_equal([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bson_unique_index_equal", l)
	}
	return
}

// BsonqueryCompare is a wrapper for
//
//	[Comment] documentdb_core.bsonquery_compare_16444.
func BsonqueryCompare(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bsonquery_compare", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bsonquery_compare([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bsonquery_compare", l)
	}
	return
}

// BsonqueryCompare16445 is a wrapper for
//
//	[Comment] documentdb_core.bsonquery_compare_16445.
func BsonqueryCompare16445(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ wirebson.RawDocument, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bsonquery_compare", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bsonquery_compare([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bsonquery_compare", l)
	}
	return
}

// BsonqueryEqual is a wrapper for
//
//	[Comment] documentdb_core.bsonquery_equal_16446.
func BsonqueryEqual(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bsonquery_equal", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bsonquery_equal([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bsonquery_equal", l)
	}
	return
}

// BsonqueryGt is a wrapper for
//
//	[Comment] documentdb_core.bsonquery_gt_16450.
func BsonqueryGt(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bsonquery_gt", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bsonquery_gt([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bsonquery_gt", l)
	}
	return
}

// BsonqueryGte is a wrapper for
//
//	[Comment] documentdb_core.bsonquery_gte_16451.
func BsonqueryGte(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bsonquery_gte", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bsonquery_gte([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bsonquery_gte", l)
	}
	return
}

// BsonqueryIn is a wrapper for
//
//	[Comment] documentdb_core.bsonquery_in_16420.
func BsonqueryIn(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bsonquery_in", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bsonquery_in([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bsonquery_in", l)
	}
	return
}

// BsonqueryLt is a wrapper for
//
//	[Comment] documentdb_core.bsonquery_lt_16448.
func BsonqueryLt(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bsonquery_lt", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bsonquery_lt([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bsonquery_lt", l)
	}
	return
}

// BsonqueryLte is a wrapper for
//
//	[Comment] documentdb_core.bsonquery_lte_16449.
func BsonqueryLte(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bsonquery_lte", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bsonquery_lte([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bsonquery_lte", l)
	}
	return
}

// BsonqueryNotEqual is a wrapper for
//
//	[Comment] documentdb_core.bsonquery_not_equal_16447.
func BsonqueryNotEqual(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bsonquery_not_equal", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bsonquery_not_equal([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bsonquery_not_equal", l)
	}
	return
}

// BsonqueryOut is a wrapper for
//
//	[Comment] documentdb_core.bsonquery_out_16421.
func BsonqueryOut(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bsonquery_out", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bsonquery_out([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bsonquery_out", l)
	}
	return
}

// BsonqueryRecv is a wrapper for
//
//	[Comment] documentdb_core.bsonquery_recv_16423.
func BsonqueryRecv(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bsonquery_recv", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bsonquery_recv([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bsonquery_recv", l)
	}
	return
}

// BsonquerySend is a wrapper for
//
//	[Comment] documentdb_core.bsonquery_send_16422.
func BsonquerySend(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bsonquery_send", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bsonquery_send([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bsonquery_send", l)
	}
	return
}

// BsonsequenceFromBytea is a wrapper for
//
//	[Comment] documentdb_core.bsonsequence_from_bytea_16412.
func BsonsequenceFromBytea(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bsonsequence_from_bytea", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bsonsequence_from_bytea([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bsonsequence_from_bytea", l)
	}
	return
}

// BsonsequenceGetBson is a wrapper for
//
//	[Comment] documentdb_core.bsonsequence_get_bson_16415.
func BsonsequenceGetBson(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ []byte) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bsonsequence_get_bson", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bsonsequence_get_bson([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bsonsequence_get_bson", l)
	}
	return
}

// BsonsequenceIn is a wrapper for
//
//	[Comment] documentdb_core.bsonsequence_in_16394.
func BsonsequenceIn(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bsonsequence_in", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bsonsequence_in([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bsonsequence_in", l)
	}
	return
}

// BsonsequenceOut is a wrapper for
//
//	[Comment] documentdb_core.bsonsequence_out_16395.
func BsonsequenceOut(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ []byte) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bsonsequence_out", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bsonsequence_out([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bsonsequence_out", l)
	}
	return
}

// BsonsequenceRecv is a wrapper for
//
//	[Comment] documentdb_core.bsonsequence_recv_16397.
func BsonsequenceRecv(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bsonsequence_recv", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bsonsequence_recv([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bsonsequence_recv", l)
	}
	return
}

// BsonsequenceSend is a wrapper for
//
//	[Comment] documentdb_core.bsonsequence_send_16396.
func BsonsequenceSend(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ []byte) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bsonsequence_send", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bsonsequence_send([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bsonsequence_send", l)
	}
	return
}

// BsonsequenceToBytea is a wrapper for
//
//	[Comment] documentdb_core.bsonsequence_to_bytea_16413.
func BsonsequenceToBytea(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ []byte) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.bsonsequence_to_bytea", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.bsonsequence_to_bytea([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.bsonsequence_to_bytea", l)
	}
	return
}

// RowGetBson is a wrapper for
//
//	[Comment] documentdb_core.row_get_bson_16407.
func RowGetBson(ctx context.Context, conn *pgx.Conn, l *slog.Logger, _ struct{}) ([Returns], err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_core.row_get_bson", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT [SQLReturns] FROM documentdb_core.row_get_bson([SQLArgs])", [QueryRowArgs])
	if err = row.Scan([ScanArgs]); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_core.row_get_bson", l)
	}
	return
}
