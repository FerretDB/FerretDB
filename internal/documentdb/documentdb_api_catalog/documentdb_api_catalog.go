// Code generated by "genwrap -debug -schemas=documentdb_api,documentdb_api_catalog,documentdb_api_internal,documentdb_core"; DO NOT EDIT.

package documentdb_api_catalog

import (
	"context"
	"log/slog"

	"github.com/FerretDB/wire/wirebson"
	"github.com/jackc/pgx/v5"
	"go.opentelemetry.io/otel"
	oteltrace "go.opentelemetry.io/otel/trace"

	"github.com/FerretDB/FerretDB/v2/internal/mongoerrors"
)

// BsonAggregationCount is a wrapper for
//
//	documentdb_api_catalog.bson_aggregation_count(databasename text, countspec documentdb_core.bson, OUT document documentdb_core.bson).
func BsonAggregationCount(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databasename string, countSpec wirebson.RawDocument) (outDocument wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_aggregation_count", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT document::bytea FROM documentdb_api_catalog.bson_aggregation_count($1, $2::bytea)", databasename, countSpec)
	if err = row.Scan(&outDocument); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_aggregation_count", l)
	}
	return
}

// BsonAggregationDistinct is a wrapper for
//
//	documentdb_api_catalog.bson_aggregation_distinct(databasename text, distinctspec documentdb_core.bson, OUT document documentdb_core.bson).
func BsonAggregationDistinct(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databasename string, distinctSpec wirebson.RawDocument) (outDocument wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_aggregation_distinct", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT document::bytea FROM documentdb_api_catalog.bson_aggregation_distinct($1, $2::bytea)", databasename, distinctSpec)
	if err = row.Scan(&outDocument); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_aggregation_distinct", l)
	}
	return
}

// BsonAggregationFind is a wrapper for
//
//	documentdb_api_catalog.bson_aggregation_find(databasename text, findspec documentdb_core.bson, OUT document documentdb_core.bson).
func BsonAggregationFind(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databasename string, findSpec wirebson.RawDocument) (outDocument wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_aggregation_find", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT document::bytea FROM documentdb_api_catalog.bson_aggregation_find($1, $2::bytea)", databasename, findSpec)
	if err = row.Scan(&outDocument); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_aggregation_find", l)
	}
	return
}

// BsonAggregationPipeline is a wrapper for
//
//	documentdb_api_catalog.bson_aggregation_pipeline(databasename text, aggregationpipeline documentdb_core.bson, OUT document documentdb_core.bson).
func BsonAggregationPipeline(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databasename string, aggregationpipeline wirebson.RawDocument) (outDocument wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_aggregation_pipeline", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT document::bytea FROM documentdb_api_catalog.bson_aggregation_pipeline($1, $2::bytea)", databasename, aggregationpipeline)
	if err = row.Scan(&outDocument); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_aggregation_pipeline", l)
	}
	return
}

// BsonArrayAgg is a wrapper for
//
//	documentdb_api_catalog.bson_array_agg().
func BsonArrayAgg(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_array_agg", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT  FROM documentdb_api_catalog.bson_array_agg()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_array_agg", l)
	}
	return
}

// BsonArrayAgg1 is a wrapper for
//
//	documentdb_api_catalog.bson_array_agg().
func BsonArrayAgg1(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_array_agg", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT  FROM documentdb_api_catalog.bson_array_agg()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_array_agg", l)
	}
	return
}

// BsonArrayAggFinal is a wrapper for
//
//	documentdb_api_catalog.bson_array_agg_final(OUT bson_array_agg_final documentdb_core.bson).
func BsonArrayAggFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonArrayAggFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_array_agg_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_array_agg_final::bytea FROM documentdb_api_catalog.bson_array_agg_final()")
	if err = row.Scan(&outBsonArrayAggFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_array_agg_final", l)
	}
	return
}

// BsonArrayAggTransition is a wrapper for
//
//	documentdb_api_catalog.bson_array_agg_transition(OUT bson_array_agg_transition bytea).
func BsonArrayAggTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonArrayAggTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_array_agg_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_array_agg_transition FROM documentdb_api_catalog.bson_array_agg_transition()")
	if err = row.Scan(&outBsonArrayAggTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_array_agg_transition", l)
	}
	return
}

// BsonArrayAggTransition1 is a wrapper for
//
//	documentdb_api_catalog.bson_array_agg_transition(OUT bson_array_agg_transition bytea).
func BsonArrayAggTransition1(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonArrayAggTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_array_agg_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_array_agg_transition FROM documentdb_api_catalog.bson_array_agg_transition()")
	if err = row.Scan(&outBsonArrayAggTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_array_agg_transition", l)
	}
	return
}

// BsonAvgFinal is a wrapper for
//
//	documentdb_api_catalog.bson_avg_final(OUT bson_avg_final documentdb_core.bson).
func BsonAvgFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonAvgFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_avg_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_avg_final::bytea FROM documentdb_api_catalog.bson_avg_final()")
	if err = row.Scan(&outBsonAvgFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_avg_final", l)
	}
	return
}

// BsonBuildDistinctResponse is a wrapper for
//
//	documentdb_api_catalog.bson_build_distinct_response(OUT bson_build_distinct_response documentdb_core.bson).
func BsonBuildDistinctResponse(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonBuildDistinctResponse wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_build_distinct_response", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_build_distinct_response::bytea FROM documentdb_api_catalog.bson_build_distinct_response()")
	if err = row.Scan(&outBsonBuildDistinctResponse); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_build_distinct_response", l)
	}
	return
}

// BsonDistinctAgg is a wrapper for
//
//	documentdb_api_catalog.bson_distinct_agg().
func BsonDistinctAgg(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_distinct_agg", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT  FROM documentdb_api_catalog.bson_distinct_agg()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_distinct_agg", l)
	}
	return
}

// BsonDistinctUnwind is a wrapper for
//
//	documentdb_api_catalog.bson_distinct_unwind(OUT bson_distinct_unwind documentdb_core.bson).
func BsonDistinctUnwind(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDistinctUnwind wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_distinct_unwind", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_distinct_unwind::bytea FROM documentdb_api_catalog.bson_distinct_unwind()")
	if err = row.Scan(&outBsonDistinctUnwind); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_distinct_unwind", l)
	}
	return
}

// BsonDollarAddFields is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_add_fields(document documentdb_core.bson, pathspec documentdb_core.bson, OUT bson_dollar_add_fields documentdb_core.bson).
func BsonDollarAddFields(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, pathSpec wirebson.RawDocument) (outBsonDollarAddFields wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_add_fields", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_add_fields::bytea FROM documentdb_api_catalog.bson_dollar_add_fields($1::bytea, $2::bytea)", document, pathSpec)
	if err = row.Scan(&outBsonDollarAddFields); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_add_fields", l)
	}
	return
}

// BsonDollarAll is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_all(OUT bson_dollar_all boolean).
func BsonDollarAll(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarAll bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_all", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_all FROM documentdb_api_catalog.bson_dollar_all()")
	if err = row.Scan(&outBsonDollarAll); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_all", l)
	}
	return
}

// BsonDollarBitsAllClear is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_bits_all_clear(OUT bson_dollar_bits_all_clear boolean).
func BsonDollarBitsAllClear(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarBitsAllClear bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_bits_all_clear", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_bits_all_clear FROM documentdb_api_catalog.bson_dollar_bits_all_clear()")
	if err = row.Scan(&outBsonDollarBitsAllClear); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_bits_all_clear", l)
	}
	return
}

// BsonDollarBitsAllSet is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_bits_all_set(OUT bson_dollar_bits_all_set boolean).
func BsonDollarBitsAllSet(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarBitsAllSet bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_bits_all_set", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_bits_all_set FROM documentdb_api_catalog.bson_dollar_bits_all_set()")
	if err = row.Scan(&outBsonDollarBitsAllSet); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_bits_all_set", l)
	}
	return
}

// BsonDollarBitsAnyClear is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_bits_any_clear(OUT bson_dollar_bits_any_clear boolean).
func BsonDollarBitsAnyClear(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarBitsAnyClear bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_bits_any_clear", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_bits_any_clear FROM documentdb_api_catalog.bson_dollar_bits_any_clear()")
	if err = row.Scan(&outBsonDollarBitsAnyClear); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_bits_any_clear", l)
	}
	return
}

// BsonDollarBitsAnySet is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_bits_any_set(OUT bson_dollar_bits_any_set boolean).
func BsonDollarBitsAnySet(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarBitsAnySet bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_bits_any_set", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_bits_any_set FROM documentdb_api_catalog.bson_dollar_bits_any_set()")
	if err = row.Scan(&outBsonDollarBitsAnySet); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_bits_any_set", l)
	}
	return
}

// BsonDollarElemmatch is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_elemmatch(OUT bson_dollar_elemmatch boolean).
func BsonDollarElemmatch(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarElemmatch bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_elemmatch", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_elemmatch FROM documentdb_api_catalog.bson_dollar_elemmatch()")
	if err = row.Scan(&outBsonDollarElemmatch); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_elemmatch", l)
	}
	return
}

// BsonDollarEq is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_eq(OUT bson_dollar_eq boolean).
func BsonDollarEq(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarEq bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_eq", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_eq FROM documentdb_api_catalog.bson_dollar_eq()")
	if err = row.Scan(&outBsonDollarEq); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_eq", l)
	}
	return
}

// BsonDollarEq1 is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_eq(OUT bson_dollar_eq boolean).
func BsonDollarEq1(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarEq bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_eq", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_eq FROM documentdb_api_catalog.bson_dollar_eq()")
	if err = row.Scan(&outBsonDollarEq); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_eq", l)
	}
	return
}

// BsonDollarExists is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_exists(OUT bson_dollar_exists boolean).
func BsonDollarExists(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarExists bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_exists", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_exists FROM documentdb_api_catalog.bson_dollar_exists()")
	if err = row.Scan(&outBsonDollarExists); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_exists", l)
	}
	return
}

// BsonDollarExpr is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_expr(OUT bson_dollar_expr boolean).
func BsonDollarExpr(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarExpr bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_expr", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_expr FROM documentdb_api_catalog.bson_dollar_expr()")
	if err = row.Scan(&outBsonDollarExpr); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_expr", l)
	}
	return
}

// BsonDollarFacetProject is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_facet_project(OUT bson_dollar_facet_project documentdb_core.bson).
func BsonDollarFacetProject(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarFacetProject wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_facet_project", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_facet_project::bytea FROM documentdb_api_catalog.bson_dollar_facet_project()")
	if err = row.Scan(&outBsonDollarFacetProject); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_facet_project", l)
	}
	return
}

// BsonDollarGeointersects is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_geointersects(OUT bson_dollar_geointersects boolean).
func BsonDollarGeointersects(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarGeointersects bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_geointersects", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_geointersects FROM documentdb_api_catalog.bson_dollar_geointersects()")
	if err = row.Scan(&outBsonDollarGeointersects); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_geointersects", l)
	}
	return
}

// BsonDollarGeowithin is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_geowithin(OUT bson_dollar_geowithin boolean).
func BsonDollarGeowithin(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarGeowithin bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_geowithin", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_geowithin FROM documentdb_api_catalog.bson_dollar_geowithin()")
	if err = row.Scan(&outBsonDollarGeowithin); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_geowithin", l)
	}
	return
}

// BsonDollarGt is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_gt(OUT bson_dollar_gt boolean).
func BsonDollarGt(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarGt bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_gt", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_gt FROM documentdb_api_catalog.bson_dollar_gt()")
	if err = row.Scan(&outBsonDollarGt); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_gt", l)
	}
	return
}

// BsonDollarGt1 is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_gt(OUT bson_dollar_gt boolean).
func BsonDollarGt1(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarGt bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_gt", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_gt FROM documentdb_api_catalog.bson_dollar_gt()")
	if err = row.Scan(&outBsonDollarGt); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_gt", l)
	}
	return
}

// BsonDollarGte is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_gte(OUT bson_dollar_gte boolean).
func BsonDollarGte(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarGte bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_gte", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_gte FROM documentdb_api_catalog.bson_dollar_gte()")
	if err = row.Scan(&outBsonDollarGte); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_gte", l)
	}
	return
}

// BsonDollarGte1 is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_gte(OUT bson_dollar_gte boolean).
func BsonDollarGte1(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarGte bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_gte", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_gte FROM documentdb_api_catalog.bson_dollar_gte()")
	if err = row.Scan(&outBsonDollarGte); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_gte", l)
	}
	return
}

// BsonDollarIn is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_in(OUT bson_dollar_in boolean).
func BsonDollarIn(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarIn bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_in", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_in FROM documentdb_api_catalog.bson_dollar_in()")
	if err = row.Scan(&outBsonDollarIn); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_in", l)
	}
	return
}

// BsonDollarJsonSchema is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_json_schema(OUT bson_dollar_json_schema boolean).
func BsonDollarJsonSchema(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarJsonSchema bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_json_schema", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_json_schema FROM documentdb_api_catalog.bson_dollar_json_schema()")
	if err = row.Scan(&outBsonDollarJsonSchema); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_json_schema", l)
	}
	return
}

// BsonDollarLt is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_lt(OUT bson_dollar_lt boolean).
func BsonDollarLt(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarLt bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_lt", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_lt FROM documentdb_api_catalog.bson_dollar_lt()")
	if err = row.Scan(&outBsonDollarLt); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_lt", l)
	}
	return
}

// BsonDollarLt1 is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_lt(OUT bson_dollar_lt boolean).
func BsonDollarLt1(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarLt bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_lt", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_lt FROM documentdb_api_catalog.bson_dollar_lt()")
	if err = row.Scan(&outBsonDollarLt); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_lt", l)
	}
	return
}

// BsonDollarLte is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_lte(OUT bson_dollar_lte boolean).
func BsonDollarLte(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarLte bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_lte", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_lte FROM documentdb_api_catalog.bson_dollar_lte()")
	if err = row.Scan(&outBsonDollarLte); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_lte", l)
	}
	return
}

// BsonDollarLte1 is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_lte(OUT bson_dollar_lte boolean).
func BsonDollarLte1(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarLte bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_lte", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_lte FROM documentdb_api_catalog.bson_dollar_lte()")
	if err = row.Scan(&outBsonDollarLte); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_lte", l)
	}
	return
}

// BsonDollarMod is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_mod(OUT bson_dollar_mod boolean).
func BsonDollarMod(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarMod bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_mod", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_mod FROM documentdb_api_catalog.bson_dollar_mod()")
	if err = row.Scan(&outBsonDollarMod); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_mod", l)
	}
	return
}

// BsonDollarNe is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_ne(OUT bson_dollar_ne boolean).
func BsonDollarNe(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarNe bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_ne", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_ne FROM documentdb_api_catalog.bson_dollar_ne()")
	if err = row.Scan(&outBsonDollarNe); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_ne", l)
	}
	return
}

// BsonDollarNin is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_nin(OUT bson_dollar_nin boolean).
func BsonDollarNin(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarNin bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_nin", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_nin FROM documentdb_api_catalog.bson_dollar_nin()")
	if err = row.Scan(&outBsonDollarNin); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_nin", l)
	}
	return
}

// BsonDollarProject is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_project(document documentdb_core.bson, pathspec documentdb_core.bson, OUT bson_dollar_project documentdb_core.bson).
func BsonDollarProject(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, pathSpec wirebson.RawDocument) (outBsonDollarProject wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_project", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_project::bytea FROM documentdb_api_catalog.bson_dollar_project($1::bytea, $2::bytea)", document, pathSpec)
	if err = row.Scan(&outBsonDollarProject); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_project", l)
	}
	return
}

// BsonDollarProjectFind is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_project_find(document documentdb_core.bson, pathspec documentdb_core.bson, queryspec documentdb_core.bson DEFAULT NULL, OUT bson_dollar_project_find documentdb_core.bson).
func BsonDollarProjectFind(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, pathSpec wirebson.RawDocument, querySpec wirebson.RawDocument) (outBsonDollarProjectFind wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_project_find", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_project_find::bytea FROM documentdb_api_catalog.bson_dollar_project_find($1::bytea, $2::bytea, $3::bytea)", document, pathSpec, querySpec)
	if err = row.Scan(&outBsonDollarProjectFind); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_project_find", l)
	}
	return
}

// BsonDollarProjectGeonear is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_project_geonear(OUT bson_dollar_project_geonear documentdb_core.bson).
func BsonDollarProjectGeonear(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarProjectGeonear wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_project_geonear", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_project_geonear::bytea FROM documentdb_api_catalog.bson_dollar_project_geonear()")
	if err = row.Scan(&outBsonDollarProjectGeonear); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_project_geonear", l)
	}
	return
}

// BsonDollarRegex is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_regex(OUT bson_dollar_regex boolean).
func BsonDollarRegex(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarRegex bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_regex", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_regex FROM documentdb_api_catalog.bson_dollar_regex()")
	if err = row.Scan(&outBsonDollarRegex); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_regex", l)
	}
	return
}

// BsonDollarReplaceRoot is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_replace_root(document documentdb_core.bson, pathspec documentdb_core.bson, OUT bson_dollar_replace_root documentdb_core.bson).
func BsonDollarReplaceRoot(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, pathSpec wirebson.RawDocument) (outBsonDollarReplaceRoot wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_replace_root", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_replace_root::bytea FROM documentdb_api_catalog.bson_dollar_replace_root($1::bytea, $2::bytea)", document, pathSpec)
	if err = row.Scan(&outBsonDollarReplaceRoot); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_replace_root", l)
	}
	return
}

// BsonDollarSet is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_set(document documentdb_core.bson, pathspec documentdb_core.bson, OUT bson_dollar_set documentdb_core.bson).
func BsonDollarSet(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, pathSpec wirebson.RawDocument) (outBsonDollarSet wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_set", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_set::bytea FROM documentdb_api_catalog.bson_dollar_set($1::bytea, $2::bytea)", document, pathSpec)
	if err = row.Scan(&outBsonDollarSet); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_set", l)
	}
	return
}

// BsonDollarSize is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_size(OUT bson_dollar_size boolean).
func BsonDollarSize(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarSize bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_size", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_size FROM documentdb_api_catalog.bson_dollar_size()")
	if err = row.Scan(&outBsonDollarSize); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_size", l)
	}
	return
}

// BsonDollarType is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_type(OUT bson_dollar_type boolean).
func BsonDollarType(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarType bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_type", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_type FROM documentdb_api_catalog.bson_dollar_type()")
	if err = row.Scan(&outBsonDollarType); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_type", l)
	}
	return
}

// BsonDollarUnset is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_unset(document documentdb_core.bson, pathspec documentdb_core.bson, OUT bson_dollar_unset documentdb_core.bson).
func BsonDollarUnset(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, pathSpec wirebson.RawDocument) (outBsonDollarUnset wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_unset", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_unset::bytea FROM documentdb_api_catalog.bson_dollar_unset($1::bytea, $2::bytea)", document, pathSpec)
	if err = row.Scan(&outBsonDollarUnset); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_unset", l)
	}
	return
}

// BsonDollarUnwind is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_unwind(OUT bson_dollar_unwind documentdb_core.bson).
func BsonDollarUnwind(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarUnwind wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_unwind", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_unwind::bytea FROM documentdb_api_catalog.bson_dollar_unwind()")
	if err = row.Scan(&outBsonDollarUnwind); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_unwind", l)
	}
	return
}

// BsonDollarUnwind1 is a wrapper for
//
//	documentdb_api_catalog.bson_dollar_unwind(OUT bson_dollar_unwind documentdb_core.bson).
func BsonDollarUnwind1(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonDollarUnwind wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_dollar_unwind", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_unwind::bytea FROM documentdb_api_catalog.bson_dollar_unwind()")
	if err = row.Scan(&outBsonDollarUnwind); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_dollar_unwind", l)
	}
	return
}

// BsonExpressionGet is a wrapper for
//
//	documentdb_api_catalog.bson_expression_get(document documentdb_core.bson, expressionspec documentdb_core.bson, isnullonempty boolean DEFAULT false, OUT bson_expression_get documentdb_core.bson).
func BsonExpressionGet(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, expressionSpec wirebson.RawDocument, isnullonempty bool) (outBsonExpressionGet wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_expression_get", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_expression_get::bytea FROM documentdb_api_catalog.bson_expression_get($1::bytea, $2::bytea, $3)", document, expressionSpec, isnullonempty)
	if err = row.Scan(&outBsonExpressionGet); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_expression_get", l)
	}
	return
}

// BsonExpressionMap is a wrapper for
//
//	documentdb_api_catalog.bson_expression_map(document documentdb_core.bson, sourcearrayname text, expressionspec documentdb_core.bson, isnullonempty boolean DEFAULT false, OUT bson_expression_map documentdb_core.bson).
func BsonExpressionMap(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, sourcearrayname string, expressionSpec wirebson.RawDocument, isnullonempty bool) (outBsonExpressionMap wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_expression_map", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_expression_map::bytea FROM documentdb_api_catalog.bson_expression_map($1::bytea, $2, $3::bytea, $4)", document, sourcearrayname, expressionSpec, isnullonempty)
	if err = row.Scan(&outBsonExpressionMap); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_expression_map", l)
	}
	return
}

// BsonFirstCombine is a wrapper for
//
//	documentdb_api_catalog.bson_first_combine(OUT bson_first_combine bytea).
func BsonFirstCombine(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonFirstCombine struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_first_combine", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_first_combine FROM documentdb_api_catalog.bson_first_combine()")
	if err = row.Scan(&outBsonFirstCombine); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_first_combine", l)
	}
	return
}

// BsonFirstLastFinal is a wrapper for
//
//	documentdb_api_catalog.bson_first_last_final(OUT bson_first_last_final documentdb_core.bson).
func BsonFirstLastFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonFirstLastFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_first_last_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_first_last_final::bytea FROM documentdb_api_catalog.bson_first_last_final()")
	if err = row.Scan(&outBsonFirstLastFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_first_last_final", l)
	}
	return
}

// BsonFirstLastFinalOnSorted is a wrapper for
//
//	documentdb_api_catalog.bson_first_last_final_on_sorted(OUT bson_first_last_final_on_sorted documentdb_core.bson).
func BsonFirstLastFinalOnSorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonFirstLastFinalOnSorted wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_first_last_final_on_sorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_first_last_final_on_sorted::bytea FROM documentdb_api_catalog.bson_first_last_final_on_sorted()")
	if err = row.Scan(&outBsonFirstLastFinalOnSorted); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_first_last_final_on_sorted", l)
	}
	return
}

// BsonFirstTransition is a wrapper for
//
//	documentdb_api_catalog.bson_first_transition(OUT bson_first_transition bytea).
func BsonFirstTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonFirstTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_first_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_first_transition FROM documentdb_api_catalog.bson_first_transition()")
	if err = row.Scan(&outBsonFirstTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_first_transition", l)
	}
	return
}

// BsonFirstTransitionOnSorted is a wrapper for
//
//	documentdb_api_catalog.bson_first_transition_on_sorted(OUT bson_first_transition_on_sorted bytea).
func BsonFirstTransitionOnSorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonFirstTransitionOnSorted struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_first_transition_on_sorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_first_transition_on_sorted FROM documentdb_api_catalog.bson_first_transition_on_sorted()")
	if err = row.Scan(&outBsonFirstTransitionOnSorted); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_first_transition_on_sorted", l)
	}
	return
}

// BsonFirstnCombine is a wrapper for
//
//	documentdb_api_catalog.bson_firstn_combine(OUT bson_firstn_combine bytea).
func BsonFirstnCombine(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonFirstnCombine struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_firstn_combine", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_firstn_combine FROM documentdb_api_catalog.bson_firstn_combine()")
	if err = row.Scan(&outBsonFirstnCombine); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_firstn_combine", l)
	}
	return
}

// BsonFirstnLastnFinal is a wrapper for
//
//	documentdb_api_catalog.bson_firstn_lastn_final(OUT bson_firstn_lastn_final documentdb_core.bson).
func BsonFirstnLastnFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonFirstnLastnFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_firstn_lastn_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_firstn_lastn_final::bytea FROM documentdb_api_catalog.bson_firstn_lastn_final()")
	if err = row.Scan(&outBsonFirstnLastnFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_firstn_lastn_final", l)
	}
	return
}

// BsonFirstnLastnFinalOnSorted is a wrapper for
//
//	documentdb_api_catalog.bson_firstn_lastn_final_on_sorted(OUT bson_firstn_lastn_final_on_sorted documentdb_core.bson).
func BsonFirstnLastnFinalOnSorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonFirstnLastnFinalOnSorted wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_firstn_lastn_final_on_sorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_firstn_lastn_final_on_sorted::bytea FROM documentdb_api_catalog.bson_firstn_lastn_final_on_sorted()")
	if err = row.Scan(&outBsonFirstnLastnFinalOnSorted); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_firstn_lastn_final_on_sorted", l)
	}
	return
}

// BsonFirstnTransition is a wrapper for
//
//	documentdb_api_catalog.bson_firstn_transition(OUT bson_firstn_transition bytea).
func BsonFirstnTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonFirstnTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_firstn_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_firstn_transition FROM documentdb_api_catalog.bson_firstn_transition()")
	if err = row.Scan(&outBsonFirstnTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_firstn_transition", l)
	}
	return
}

// BsonFirstnTransitionOnSorted is a wrapper for
//
//	documentdb_api_catalog.bson_firstn_transition_on_sorted(OUT bson_firstn_transition_on_sorted bytea).
func BsonFirstnTransitionOnSorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonFirstnTransitionOnSorted struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_firstn_transition_on_sorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_firstn_transition_on_sorted FROM documentdb_api_catalog.bson_firstn_transition_on_sorted()")
	if err = row.Scan(&outBsonFirstnTransitionOnSorted); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_firstn_transition_on_sorted", l)
	}
	return
}

// BsonGeonearDistance is a wrapper for
//
//	documentdb_api_catalog.bson_geonear_distance(OUT bson_geonear_distance double precision).
func BsonGeonearDistance(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonGeonearDistance float64, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_geonear_distance", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_geonear_distance FROM documentdb_api_catalog.bson_geonear_distance()")
	if err = row.Scan(&outBsonGeonearDistance); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_geonear_distance", l)
	}
	return
}

// BsonGistGeographyCompress is a wrapper for
//
//	documentdb_api_catalog.bson_gist_geography_compress(OUT bson_gist_geography_compress internal).
func BsonGistGeographyCompress(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonGistGeographyCompress struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_gist_geography_compress", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_gist_geography_compress FROM documentdb_api_catalog.bson_gist_geography_compress()")
	if err = row.Scan(&outBsonGistGeographyCompress); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_gist_geography_compress", l)
	}
	return
}

// BsonGistGeographyConsistent is a wrapper for
//
//	documentdb_api_catalog.bson_gist_geography_consistent(OUT bson_gist_geography_consistent boolean).
func BsonGistGeographyConsistent(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonGistGeographyConsistent bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_gist_geography_consistent", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_gist_geography_consistent FROM documentdb_api_catalog.bson_gist_geography_consistent()")
	if err = row.Scan(&outBsonGistGeographyConsistent); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_gist_geography_consistent", l)
	}
	return
}

// BsonGistGeographyDistance is a wrapper for
//
//	documentdb_api_catalog.bson_gist_geography_distance(OUT bson_gist_geography_distance double precision).
func BsonGistGeographyDistance(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonGistGeographyDistance float64, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_gist_geography_distance", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_gist_geography_distance FROM documentdb_api_catalog.bson_gist_geography_distance()")
	if err = row.Scan(&outBsonGistGeographyDistance); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_gist_geography_distance", l)
	}
	return
}

// BsonGistGeographyOptions is a wrapper for
//
//	documentdb_api_catalog.bson_gist_geography_options(OUT bson_gist_geography_options void).
func BsonGistGeographyOptions(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonGistGeographyOptions struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_gist_geography_options", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_gist_geography_options FROM documentdb_api_catalog.bson_gist_geography_options()")
	if err = row.Scan(&outBsonGistGeographyOptions); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_gist_geography_options", l)
	}
	return
}

// BsonGistGeometry2dCompress is a wrapper for
//
//	documentdb_api_catalog.bson_gist_geometry_2d_compress(OUT bson_gist_geometry_2d_compress internal).
func BsonGistGeometry2dCompress(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonGistGeometry2dCompress struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_gist_geometry_2d_compress", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_gist_geometry_2d_compress FROM documentdb_api_catalog.bson_gist_geometry_2d_compress()")
	if err = row.Scan(&outBsonGistGeometry2dCompress); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_gist_geometry_2d_compress", l)
	}
	return
}

// BsonGistGeometry2dOptions is a wrapper for
//
//	documentdb_api_catalog.bson_gist_geometry_2d_options(OUT bson_gist_geometry_2d_options void).
func BsonGistGeometry2dOptions(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonGistGeometry2dOptions struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_gist_geometry_2d_options", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_gist_geometry_2d_options FROM documentdb_api_catalog.bson_gist_geometry_2d_options()")
	if err = row.Scan(&outBsonGistGeometry2dOptions); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_gist_geometry_2d_options", l)
	}
	return
}

// BsonGistGeometryConsistent2d is a wrapper for
//
//	documentdb_api_catalog.bson_gist_geometry_consistent_2d(OUT bson_gist_geometry_consistent_2d boolean).
func BsonGistGeometryConsistent2d(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonGistGeometryConsistent2d bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_gist_geometry_consistent_2d", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_gist_geometry_consistent_2d FROM documentdb_api_catalog.bson_gist_geometry_consistent_2d()")
	if err = row.Scan(&outBsonGistGeometryConsistent2d); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_gist_geometry_consistent_2d", l)
	}
	return
}

// BsonGistGeometryDistance2d is a wrapper for
//
//	documentdb_api_catalog.bson_gist_geometry_distance_2d(OUT bson_gist_geometry_distance_2d double precision).
func BsonGistGeometryDistance2d(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonGistGeometryDistance2d float64, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_gist_geometry_distance_2d", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_gist_geometry_distance_2d FROM documentdb_api_catalog.bson_gist_geometry_distance_2d()")
	if err = row.Scan(&outBsonGistGeometryDistance2d); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_gist_geometry_distance_2d", l)
	}
	return
}

// BsonLastCombine is a wrapper for
//
//	documentdb_api_catalog.bson_last_combine(OUT bson_last_combine bytea).
func BsonLastCombine(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonLastCombine struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_last_combine", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_last_combine FROM documentdb_api_catalog.bson_last_combine()")
	if err = row.Scan(&outBsonLastCombine); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_last_combine", l)
	}
	return
}

// BsonLastTransition is a wrapper for
//
//	documentdb_api_catalog.bson_last_transition(OUT bson_last_transition bytea).
func BsonLastTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonLastTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_last_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_last_transition FROM documentdb_api_catalog.bson_last_transition()")
	if err = row.Scan(&outBsonLastTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_last_transition", l)
	}
	return
}

// BsonLastTransitionOnSorted is a wrapper for
//
//	documentdb_api_catalog.bson_last_transition_on_sorted(OUT bson_last_transition_on_sorted bytea).
func BsonLastTransitionOnSorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonLastTransitionOnSorted struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_last_transition_on_sorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_last_transition_on_sorted FROM documentdb_api_catalog.bson_last_transition_on_sorted()")
	if err = row.Scan(&outBsonLastTransitionOnSorted); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_last_transition_on_sorted", l)
	}
	return
}

// BsonLastnCombine is a wrapper for
//
//	documentdb_api_catalog.bson_lastn_combine(OUT bson_lastn_combine bytea).
func BsonLastnCombine(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonLastnCombine struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_lastn_combine", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_lastn_combine FROM documentdb_api_catalog.bson_lastn_combine()")
	if err = row.Scan(&outBsonLastnCombine); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_lastn_combine", l)
	}
	return
}

// BsonLastnTransition is a wrapper for
//
//	documentdb_api_catalog.bson_lastn_transition(OUT bson_lastn_transition bytea).
func BsonLastnTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonLastnTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_lastn_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_lastn_transition FROM documentdb_api_catalog.bson_lastn_transition()")
	if err = row.Scan(&outBsonLastnTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_lastn_transition", l)
	}
	return
}

// BsonLastnTransitionOnSorted is a wrapper for
//
//	documentdb_api_catalog.bson_lastn_transition_on_sorted(OUT bson_lastn_transition_on_sorted bytea).
func BsonLastnTransitionOnSorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonLastnTransitionOnSorted struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_lastn_transition_on_sorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_lastn_transition_on_sorted FROM documentdb_api_catalog.bson_lastn_transition_on_sorted()")
	if err = row.Scan(&outBsonLastnTransitionOnSorted); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_lastn_transition_on_sorted", l)
	}
	return
}

// BsonLookupUnwind is a wrapper for
//
//	documentdb_api_catalog.bson_lookup_unwind(OUT bson_lookup_unwind documentdb_core.bson).
func BsonLookupUnwind(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonLookupUnwind wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_lookup_unwind", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_lookup_unwind::bytea FROM documentdb_api_catalog.bson_lookup_unwind()")
	if err = row.Scan(&outBsonLookupUnwind); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_lookup_unwind", l)
	}
	return
}

// BsonMaxCombine is a wrapper for
//
//	documentdb_api_catalog.bson_max_combine(OUT bson_max_combine documentdb_core.bson).
func BsonMaxCombine(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonMaxCombine wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_max_combine", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_max_combine::bytea FROM documentdb_api_catalog.bson_max_combine()")
	if err = row.Scan(&outBsonMaxCombine); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_max_combine", l)
	}
	return
}

// BsonMaxTransition is a wrapper for
//
//	documentdb_api_catalog.bson_max_transition(OUT bson_max_transition documentdb_core.bson).
func BsonMaxTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonMaxTransition wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_max_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_max_transition::bytea FROM documentdb_api_catalog.bson_max_transition()")
	if err = row.Scan(&outBsonMaxTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_max_transition", l)
	}
	return
}

// BsonMinCombine is a wrapper for
//
//	documentdb_api_catalog.bson_min_combine(OUT bson_min_combine documentdb_core.bson).
func BsonMinCombine(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonMinCombine wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_min_combine", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_min_combine::bytea FROM documentdb_api_catalog.bson_min_combine()")
	if err = row.Scan(&outBsonMinCombine); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_min_combine", l)
	}
	return
}

// BsonMinMaxFinal is a wrapper for
//
//	documentdb_api_catalog.bson_min_max_final(OUT bson_min_max_final documentdb_core.bson).
func BsonMinMaxFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonMinMaxFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_min_max_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_min_max_final::bytea FROM documentdb_api_catalog.bson_min_max_final()")
	if err = row.Scan(&outBsonMinMaxFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_min_max_final", l)
	}
	return
}

// BsonMinTransition is a wrapper for
//
//	documentdb_api_catalog.bson_min_transition(OUT bson_min_transition documentdb_core.bson).
func BsonMinTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonMinTransition wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_min_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_min_transition::bytea FROM documentdb_api_catalog.bson_min_transition()")
	if err = row.Scan(&outBsonMinTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_min_transition", l)
	}
	return
}

// BsonObjectAgg is a wrapper for
//
//	documentdb_api_catalog.bson_object_agg().
func BsonObjectAgg(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_object_agg", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT  FROM documentdb_api_catalog.bson_object_agg()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_object_agg", l)
	}
	return
}

// BsonObjectAggFinal is a wrapper for
//
//	documentdb_api_catalog.bson_object_agg_final(OUT bson_object_agg_final documentdb_core.bson).
func BsonObjectAggFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonObjectAggFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_object_agg_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_object_agg_final::bytea FROM documentdb_api_catalog.bson_object_agg_final()")
	if err = row.Scan(&outBsonObjectAggFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_object_agg_final", l)
	}
	return
}

// BsonObjectAggTransition is a wrapper for
//
//	documentdb_api_catalog.bson_object_agg_transition(OUT bson_object_agg_transition bytea).
func BsonObjectAggTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonObjectAggTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_object_agg_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_object_agg_transition FROM documentdb_api_catalog.bson_object_agg_transition()")
	if err = row.Scan(&outBsonObjectAggTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_object_agg_transition", l)
	}
	return
}

// BsonOrderby is a wrapper for
//
//	documentdb_api_catalog.bson_orderby(OUT bson_orderby documentdb_core.bson).
func BsonOrderby(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonOrderby wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_orderby", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_orderby::bytea FROM documentdb_api_catalog.bson_orderby()")
	if err = row.Scan(&outBsonOrderby); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_orderby", l)
	}
	return
}

// BsonOut is a wrapper for
//
//	documentdb_api_catalog.bson_out().
func BsonOut(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_out", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT  FROM documentdb_api_catalog.bson_out()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_out", l)
	}
	return
}

// BsonOutFinal is a wrapper for
//
//	documentdb_api_catalog.bson_out_final(OUT bson_out_final documentdb_core.bson).
func BsonOutFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonOutFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_out_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_out_final::bytea FROM documentdb_api_catalog.bson_out_final()")
	if err = row.Scan(&outBsonOutFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_out_final", l)
	}
	return
}

// BsonOutTransition is a wrapper for
//
//	documentdb_api_catalog.bson_out_transition(OUT bson_out_transition bytea).
func BsonOutTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonOutTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_out_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_out_transition FROM documentdb_api_catalog.bson_out_transition()")
	if err = row.Scan(&outBsonOutTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_out_transition", l)
	}
	return
}

// BsonQueryMatch is a wrapper for
//
//	documentdb_api_catalog.bson_query_match(OUT bson_query_match boolean).
func BsonQueryMatch(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonQueryMatch bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_query_match", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_query_match FROM documentdb_api_catalog.bson_query_match()")
	if err = row.Scan(&outBsonQueryMatch); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_query_match", l)
	}
	return
}

// BsonSumAvgCombine is a wrapper for
//
//	documentdb_api_catalog.bson_sum_avg_combine(OUT bson_sum_avg_combine bytea).
func BsonSumAvgCombine(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonSumAvgCombine struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_sum_avg_combine", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_sum_avg_combine FROM documentdb_api_catalog.bson_sum_avg_combine()")
	if err = row.Scan(&outBsonSumAvgCombine); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_sum_avg_combine", l)
	}
	return
}

// BsonSumAvgTransition is a wrapper for
//
//	documentdb_api_catalog.bson_sum_avg_transition(OUT bson_sum_avg_transition bytea).
func BsonSumAvgTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonSumAvgTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_sum_avg_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_sum_avg_transition FROM documentdb_api_catalog.bson_sum_avg_transition()")
	if err = row.Scan(&outBsonSumAvgTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_sum_avg_transition", l)
	}
	return
}

// BsonSumFinal is a wrapper for
//
//	documentdb_api_catalog.bson_sum_final(OUT bson_sum_final documentdb_core.bson).
func BsonSumFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonSumFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_sum_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_sum_final::bytea FROM documentdb_api_catalog.bson_sum_final()")
	if err = row.Scan(&outBsonSumFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_sum_final", l)
	}
	return
}

// BsonTrueMatch is a wrapper for
//
//	documentdb_api_catalog.bson_true_match(OUT bson_true_match boolean).
func BsonTrueMatch(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outBsonTrueMatch bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_true_match", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_true_match FROM documentdb_api_catalog.bson_true_match()")
	if err = row.Scan(&outBsonTrueMatch); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_true_match", l)
	}
	return
}

// BsonValidateGeography is a wrapper for
//
//	documentdb_api_catalog.bson_validate_geography(p_document documentdb_core.bson, p_keypath text, OUT bson_validate_geography documentdb_core.bson).
func BsonValidateGeography(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, keypath string) (outBsonValidateGeography wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_validate_geography", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_validate_geography::bytea FROM documentdb_api_catalog.bson_validate_geography($1::bytea, $2)", document, keypath)
	if err = row.Scan(&outBsonValidateGeography); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_validate_geography", l)
	}
	return
}

// BsonValidateGeometry is a wrapper for
//
//	documentdb_api_catalog.bson_validate_geometry(p_document documentdb_core.bson, p_keypath text, OUT bson_validate_geometry documentdb_core.bson).
func BsonValidateGeometry(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, keypath string) (outBsonValidateGeometry wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bson_validate_geometry", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_validate_geometry::bytea FROM documentdb_api_catalog.bson_validate_geometry($1::bytea, $2)", document, keypath)
	if err = row.Scan(&outBsonValidateGeometry); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bson_validate_geometry", l)
	}
	return
}

// Bsonaverage is a wrapper for
//
//	documentdb_api_catalog.bsonaverage().
func Bsonaverage(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonaverage", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT  FROM documentdb_api_catalog.bsonaverage()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonaverage", l)
	}
	return
}

// Bsonfirst is a wrapper for
//
//	documentdb_api_catalog.bsonfirst().
func Bsonfirst(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonfirst", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT  FROM documentdb_api_catalog.bsonfirst()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonfirst", l)
	}
	return
}

// Bsonfirstn is a wrapper for
//
//	documentdb_api_catalog.bsonfirstn().
func Bsonfirstn(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonfirstn", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT  FROM documentdb_api_catalog.bsonfirstn()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonfirstn", l)
	}
	return
}

// Bsonfirstnonsorted is a wrapper for
//
//	documentdb_api_catalog.bsonfirstnonsorted().
func Bsonfirstnonsorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonfirstnonsorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT  FROM documentdb_api_catalog.bsonfirstnonsorted()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonfirstnonsorted", l)
	}
	return
}

// Bsonfirstonsorted is a wrapper for
//
//	documentdb_api_catalog.bsonfirstonsorted().
func Bsonfirstonsorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonfirstonsorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT  FROM documentdb_api_catalog.bsonfirstonsorted()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonfirstonsorted", l)
	}
	return
}

// Bsonlast is a wrapper for
//
//	documentdb_api_catalog.bsonlast().
func Bsonlast(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonlast", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT  FROM documentdb_api_catalog.bsonlast()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonlast", l)
	}
	return
}

// Bsonlastn is a wrapper for
//
//	documentdb_api_catalog.bsonlastn().
func Bsonlastn(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonlastn", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT  FROM documentdb_api_catalog.bsonlastn()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonlastn", l)
	}
	return
}

// Bsonlastnonsorted is a wrapper for
//
//	documentdb_api_catalog.bsonlastnonsorted().
func Bsonlastnonsorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonlastnonsorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT  FROM documentdb_api_catalog.bsonlastnonsorted()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonlastnonsorted", l)
	}
	return
}

// Bsonlastonsorted is a wrapper for
//
//	documentdb_api_catalog.bsonlastonsorted().
func Bsonlastonsorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonlastonsorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT  FROM documentdb_api_catalog.bsonlastonsorted()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonlastonsorted", l)
	}
	return
}

// Bsonmax is a wrapper for
//
//	documentdb_api_catalog.bsonmax().
func Bsonmax(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonmax", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT  FROM documentdb_api_catalog.bsonmax()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonmax", l)
	}
	return
}

// Bsonmin is a wrapper for
//
//	documentdb_api_catalog.bsonmin().
func Bsonmin(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonmin", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT  FROM documentdb_api_catalog.bsonmin()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonmin", l)
	}
	return
}

// Bsonsum is a wrapper for
//
//	documentdb_api_catalog.bsonsum().
func Bsonsum(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.bsonsum", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT  FROM documentdb_api_catalog.bsonsum()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.bsonsum", l)
	}
	return
}

// Documentdbrumhandler is a wrapper for
//
//	documentdb_api_catalog.documentdbrumhandler(OUT documentdbrumhandler index_am_handler).
func Documentdbrumhandler(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outDocumentdbrumhandler struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.documentdbrumhandler", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT documentdbrumhandler FROM documentdb_api_catalog.documentdbrumhandler()")
	if err = row.Scan(&outDocumentdbrumhandler); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.documentdbrumhandler", l)
	}
	return
}

// DollarSupport is a wrapper for
//
//	documentdb_api_catalog.dollar_support(OUT dollar_support internal).
func DollarSupport(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outDollarSupport struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.dollar_support", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT dollar_support FROM documentdb_api_catalog.dollar_support()")
	if err = row.Scan(&outDollarSupport); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.dollar_support", l)
	}
	return
}

// GinBsonCanPreConsistent is a wrapper for
//
//	documentdb_api_catalog.gin_bson_can_pre_consistent(OUT gin_bson_can_pre_consistent boolean).
func GinBsonCanPreConsistent(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outGinBsonCanPreConsistent bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_can_pre_consistent", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_can_pre_consistent FROM documentdb_api_catalog.gin_bson_can_pre_consistent()")
	if err = row.Scan(&outGinBsonCanPreConsistent); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_can_pre_consistent", l)
	}
	return
}

// GinBsonCompare is a wrapper for
//
//	documentdb_api_catalog.gin_bson_compare(OUT gin_bson_compare boolean).
func GinBsonCompare(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outGinBsonCompare bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_compare", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_compare FROM documentdb_api_catalog.gin_bson_compare()")
	if err = row.Scan(&outGinBsonCompare); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_compare", l)
	}
	return
}

// GinBsonComparePartial is a wrapper for
//
//	documentdb_api_catalog.gin_bson_compare_partial(OUT gin_bson_compare_partial integer).
func GinBsonComparePartial(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outGinBsonComparePartial struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_compare_partial", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_compare_partial FROM documentdb_api_catalog.gin_bson_compare_partial()")
	if err = row.Scan(&outGinBsonComparePartial); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_compare_partial", l)
	}
	return
}

// GinBsonConsistent is a wrapper for
//
//	documentdb_api_catalog.gin_bson_consistent(OUT gin_bson_consistent boolean).
func GinBsonConsistent(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outGinBsonConsistent bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_consistent", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_consistent FROM documentdb_api_catalog.gin_bson_consistent()")
	if err = row.Scan(&outGinBsonConsistent); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_consistent", l)
	}
	return
}

// GinBsonExclusionPreConsistent is a wrapper for
//
//	documentdb_api_catalog.gin_bson_exclusion_pre_consistent(OUT gin_bson_exclusion_pre_consistent void).
func GinBsonExclusionPreConsistent(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outGinBsonExclusionPreConsistent struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_exclusion_pre_consistent", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_exclusion_pre_consistent FROM documentdb_api_catalog.gin_bson_exclusion_pre_consistent()")
	if err = row.Scan(&outGinBsonExclusionPreConsistent); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_exclusion_pre_consistent", l)
	}
	return
}

// GinBsonExtractQuery is a wrapper for
//
//	documentdb_api_catalog.gin_bson_extract_query(OUT gin_bson_extract_query internal).
func GinBsonExtractQuery(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outGinBsonExtractQuery struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_extract_query", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_extract_query FROM documentdb_api_catalog.gin_bson_extract_query()")
	if err = row.Scan(&outGinBsonExtractQuery); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_extract_query", l)
	}
	return
}

// GinBsonPreConsistent is a wrapper for
//
//	documentdb_api_catalog.gin_bson_pre_consistent(OUT gin_bson_pre_consistent void).
func GinBsonPreConsistent(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outGinBsonPreConsistent struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_pre_consistent", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_pre_consistent FROM documentdb_api_catalog.gin_bson_pre_consistent()")
	if err = row.Scan(&outGinBsonPreConsistent); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_pre_consistent", l)
	}
	return
}

// GinBsonSinglePathExtractValue is a wrapper for
//
//	documentdb_api_catalog.gin_bson_single_path_extract_value(OUT gin_bson_single_path_extract_value internal).
func GinBsonSinglePathExtractValue(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outGinBsonSinglePathExtractValue struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_single_path_extract_value", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_single_path_extract_value FROM documentdb_api_catalog.gin_bson_single_path_extract_value()")
	if err = row.Scan(&outGinBsonSinglePathExtractValue); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_single_path_extract_value", l)
	}
	return
}

// GinBsonSinglePathOptions is a wrapper for
//
//	documentdb_api_catalog.gin_bson_single_path_options(OUT gin_bson_single_path_options void).
func GinBsonSinglePathOptions(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outGinBsonSinglePathOptions struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_single_path_options", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_single_path_options FROM documentdb_api_catalog.gin_bson_single_path_options()")
	if err = row.Scan(&outGinBsonSinglePathOptions); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_single_path_options", l)
	}
	return
}

// GinBsonWildcardProjectExtractValue is a wrapper for
//
//	documentdb_api_catalog.gin_bson_wildcard_project_extract_value(OUT gin_bson_wildcard_project_extract_value internal).
func GinBsonWildcardProjectExtractValue(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outGinBsonWildcardProjectExtractValue struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_wildcard_project_extract_value", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_wildcard_project_extract_value FROM documentdb_api_catalog.gin_bson_wildcard_project_extract_value()")
	if err = row.Scan(&outGinBsonWildcardProjectExtractValue); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_wildcard_project_extract_value", l)
	}
	return
}

// GinBsonWildcardProjectOptions is a wrapper for
//
//	documentdb_api_catalog.gin_bson_wildcard_project_options(OUT gin_bson_wildcard_project_options void).
func GinBsonWildcardProjectOptions(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outGinBsonWildcardProjectOptions struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.gin_bson_wildcard_project_options", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_wildcard_project_options FROM documentdb_api_catalog.gin_bson_wildcard_project_options()")
	if err = row.Scan(&outGinBsonWildcardProjectOptions); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.gin_bson_wildcard_project_options", l)
	}
	return
}

// QueryMatchSupport is a wrapper for
//
//	documentdb_api_catalog.query_match_support(OUT query_match_support internal).
func QueryMatchSupport(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outQueryMatchSupport struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_catalog.query_match_support", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT query_match_support FROM documentdb_api_catalog.query_match_support()")
	if err = row.Scan(&outQueryMatchSupport); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_catalog.query_match_support", l)
	}
	return
}
