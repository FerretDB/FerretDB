---
title: "How MongoDB compares arrays"
slug: ferretdb-compare-arrays
authors: [chi tag]
description: Find out how arrays are compared at FerretDB.
keywords:
  - MongoDB sorting
  - MongoDB comparison
  - MongoDB array comparison
image: /img/blog/ferretdb-how-mongodb-compares-arrays.jpg
tags: [tag1, tag2]
unlisted: true
---

Find out how BSON arrays are compared at FerretDB.

![Image alt description](/img/blog/ferretdb-how-mongodb-compares-arrays.jpg)

<!--truncate-->

## BSON Comparison Order {#bson-comparison-order}

Different BSON values are have comparison order from the lowest to the highest as it's listed in following.
It's documented in [MongoDB Comparison/Sort Order](https://www.mongodb.com/docs/manual/reference/bson-type-comparison-order/).

1. Null
2. Numbers (ints, longs, doubles, decimals)
3. Symbol, String
4. Object
5. Array
6. BinData
7. ObjectId
8. Boolean
9. Date
10. Timestamp
11. Regular Expression

The comparison of BSON uses BSON comparison order,
when the BSON type is the same, then the comparison specific to that type is used.
## How array is compared

Array is no exception when comparing two arrays. It iterates each index to compare
BSON comparison order, when they are the say value of the type is compared.
As soon as they are different, that is used for the result of the comparison.

At any point during iterating arrays, if no more element exists in next index,
then that array is smaller.

### Compare two arrays
Two arrays compare each element of the array, until they are not the same.
For example comparing `[3, 1, 'b']` and `[3, 'b', 'a']` takes following steps.
1. Compare `[3, 1, 'b']` and `[3, 2, 'a']` using comparison order. They are the same, both are arrays.
2. Compare first index `3` and `3` using comparison order, they are the same, both are numbers.
3. Compare first index `3` and `3` using number comparison, they are the same.
4. Compare next index, `1` and `b` using comparison order, `1` is number and less than string `b`.
So `[3, 1, 'b']` is less than `[3, 'b', 'a']`.

If an array has no more element to compare, the one with more element is greater.
For example comparing `[3, 1]` and `[3]` takes following steps.
1. Compare `[3, 1]` and `[3]` using comparison order, they are both arrays.
2. Compare first index `3` and `3` using comparison order, they are the same, both are numbers.
3. Compare first index `3` and `3` using number comparison, they are the same.
4. Compare next index, first array has `1` but second array does not have any element.
If one array no longer has index to compare, that array is less.
So `[3, 1]` is greater than `[3]`.

For the same reason empty array is less than arrays with elements.

### Compare array and other BSON type
Comparing array with other BSON types, it doesn't _always_ use comparison order of array BSON type.
There is a case where comparison order is used in
[$max and $min update operator](#max-min-update-operator).
For other cases [sorting](#sorting), [#gt and #lt filter operators](#gt-lt-filter-operator),
array uses an element inside an array to compare with other BSON type.
For example, comparing `2` and `[3, 1]` the result is different based on ascending sort or descending sort.

Let's use ascending sort to compare `2` and `[3, 1]`.
1. It gets the smallest element of array `[3, 1]` which is `1`
2. It compares `2` and `1` and `1` is less.
So `[3, 1]` is less than `2`.

Let's use descending sort to compare `2` and `[3, 1]`.
1. It gets the largest element of array `[3, 1]` which is `3`
2. It compares `2` and `3`, `3` is greater.
So `[3, 1]` is greater than `2`.

It might seem confusing at first, but ascending sort uses the smallest element
from the array and descending sort uses the largest element from the array.

For an empty array, it's a special case where empty array less than any BSON type.
So `[]` is less than even `null` for [sorting](#sorting),
[#gt and #lt filter operators](#gt-lt-filter-operator).

## sorting {#sorting}
Sorting records by ascending or descending order uses comparison order,
but array behaves specially.
Ascending sort is indicated by `1`, and the smallest element from the array
is used for comparison.
`db.<<ollections>>.find({}).sort({<<field>>: 1})`

### sorting array
Let's look at how ascending sort orders records.
The ascending sort uses the smallest element from array BSON type.
For example, `array-mixed` record gets its smallest element `0` and uses
that to compare against other records.
Even though array is greater than string in [BSON comparison order](#bson-comparison-order),
`{ _id: 'array-mixed', v: [ 0, 'a', 'z' ] }` record is smaller than
`{ _id: 'string', v: 'b' }` record using the smallest element from the array.
```
test> db.random.insertMany([{_id:'array-empty',v:[]}, {_id:'array-mixed',v:[0,'a','z']}, {_id:'array-strings',v:['a']}, {_id:'array-numbers',v:[10,5]}, {_id:'string',v:'b'}, {_id:'null',v:null}])
test> db.random.find({}).sort({v: 1})
[
  { _id: 'array-empty', v: [] },              // empty array is the smallest
  { _id: 'null', v: null },                   // null is used for comparison
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // 0 is used for comparison
  { _id: 'array-numbers', v: [ 10, 5 ] },     // 5 is used for comparison
  { _id: 'array-strings', v: [ 'a' ] },       // `a` is used for comparison
  { _id: 'string', v: 'b' }                   // `b` is used for comparison
]
```

For descending sort, the largest element of the array is used for comparison.
`db.collections.find({}).sort({<<field>>: -1})`

Let's look at how descending sort orders elements.
The ascending sort uses the largest element of an array BSON type.
For example, `array-mixed` record gets its largest element `z` and uses
that to compare against other records.
So descending sort is not the opposite order of ascending sort,
because the comparison element used from the array is different.
```
test> db.random.find({}).sort({v: -1})
[
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // `z` is used for comparison
  { _id: 'string', v: 'b' },                  // `b` is used for comparison
  { _id: 'array-strings', v: [ 'a' ] },       // `a` is used for comparison
  { _id: 'array-numbers', v: [ 10, 5 ] },     // 10 is used for comparison
  { _id: 'null', v: null },                   // null is used for comparison
  { _id: 'array-empty', v: [] }               // empty array is the smallest
]
```
### sorting nested array

Unlike array comparison {### sorting array} which uses the largest or smallest element
from an array, nested array compares each index using comparison order
then compares the value.

For example, comparing `nested-number` and `nested-null`,
although `nested-null` has the smallest BSON type `null` in the nested array,
it is greater than `nested-number`.
Let's compare `nested-number` and `nested-null` step by step using ascending sort.
1. Compare the smallest element of nested array, they are `[ 6, 1 ]` and `[ 6, 2, null ]` and both are arrays.
2. Compare the first index of the array, they are `6` and `6` and the same.
3. Compare the second index of the array, first nested array has `1` and second has `2`
So `nested-number` is less than `nested-null`.

```
test> db.nestedsort.insertMany([{_id:'nested-number','v':[[6, 1]]}, {_id:'nested-empty','v':[[]]}, {_id:'nested-mixed','v':[[true,0,'g']]}, {_id:'nested-null',v:[[6,2,null]]}])
[
  { _id: 'nested-empty', v: [ [] ] },              // empty nested array is smaller
  { _id: 'nested-number', v: [ [ 6, 1 ] ] },       // compares each element of [ 6, 1 ]
  { _id: 'nested-null', v: [ [ 6, 2, null ] ] },   // compares each element of [ 6, 2, null ]
  { _id: 'nested-mixed', v: [ [ true, 0, 'g' ] ] } // compares each element of [ true, 0, 'g' ]
]
```

## $gt and $lt filter operators {#gt-lt-filter-operator}
[$gt, $lt, $gte and $lte](https://docs.ferretdb.io/basic_operations/read/#retrieve-documents-using-operator-queries) operators
select records that satisfy comparison condition.

For `$lt` the records that are less than a specific value is selected.
Let's look at filtering less than `c`.
`db.<<ollections>>.find({v: {$lt: 'c'}})`

```
test> db.random.find({})
[
  { _id: 'array-empty', v: [] },
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] },
  { _id: 'array-strings', v: [ 'a' ] },
  { _id: 'array-numbers', v: [ 10, 5 ] },
  { _id: 'string', v: 'b' },
  { _id: 'null', v: null }
]
test> db.random.find({v: {$lt: 'c'}})
[
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }, // uses smallest string element 'a'
  { _id: 'array-strings', v: [ 'a' ] },       // uses smallest element `a`
  { _id: 'string', v: 'b' }
]
```
The records selected are string value and also array values.
But it does not contain `[]`, `null` and `[10 5]`.
It's because `$lt` is applied only to the same BSON type.
If an array does not contain string BSON type, `$lt` does not match the filter.

```
test> db.random.find({})
[
  { _id: 'array-empty', v: [] },
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] },
  { _id: 'array-strings', v: [ 'a' ] },
  { _id: 'array-numbers', v: [ 10, 5 ] },
  { _id: 'string', v: 'b' },
  { _id: 'null', v: null }
]
test> db.random.find({v:{$lt:[6,'']}})
[
  { _id: 'array-empty', v: [] },
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }
]
test> db.random.find({v:{$lt:[0,'']}})
[ { _id: 'array-empty', v: [] } ]
test> db.random.find({v:{$lt:[0,null]}})
[ { _id: 'array-empty', v: [] } ]
test> db.random.find({v:{$lt:[0,'z']}})
[
  { _id: 'array-empty', v: [] },
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }
]
test> db.random.find({v:{$lt:[0,{foo:'bar'}]}})
[
  { _id: 'array-empty', v: [] },
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] }
]
```

Non-empty array is greater than empty array.
```
test> db.random.find({v:{$gt:[]}})
[
  { _id: 'array-mixed', v: [ 0, 'a', 'z' ] },
  { _id: 'array-strings', v: [ 'a' ] },
  { _id: 'array-numbers', v: [ 10, 5 ] }
]
```

#### $max and $min update operators {#max-min-update-operator}
$max and $min update operators compares the same BSON type.

For example, using update operator 
`db.<<ollections>>.update({},{v: {$lt: 'c'}})`

```
test> db.sample.insertMany([{_id: 'bool', v: true,op:true},{_id: 'array', v: ['g',1],op:true},{_id: 'number', v: 4, op:true}])
{
  acknowledged: true,
  insertedIds: { '0': 'bool', '1': 'array', '2': 'number' }
}
test> db.sample.find({})
[
  { _id: 'bool', v: true, op: true },
  { _id: 'array', v: [ 'g', 1 ], op: true },
  { _id: 'number', v: 4, op: true }
]
test> db.sample.updateMany({op:true},{$max: {v: ['z']}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 3,
  modifiedCount: 2,
  upsertedCount: 0
}
test> db.sample.find({})
[
  { _id: 'bool', v: true, op: true },
  { _id: 'array', v: [ 'z' ], op: true },
  { _id: 'number', v: [ 'z' ], op: true }
]
test> db.sample.drop({})
true
test> db.sample.insertMany([{_id: 'bool', v: true,op:true},{_id: 'array', v: ['g',1],op:true},{_id: 'number', v: 4, op:true}])
{
  acknowledged: true,
  insertedIds: { '0': 'bool', '1': 'array', '2': 'number' }
}
test> db.sample.find({})
[
  { _id: 'bool', v: true, op: true },
  { _id: 'array', v: [ 'g', 1 ], op: true },
  { _id: 'number', v: 4, op: true }
]
test> db.sample.updateMany({op:true},{$max: {v: 'z'}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 3,
  modifiedCount: 1,
  upsertedCount: 0
}
test> db.sample.find({})
[
  { _id: 'bool', v: true, op: true },
  { _id: 'array', v: [ 'g', 1 ], op: true },
  { _id: 'number', v: 'z', op: true }
]
test> 

```
