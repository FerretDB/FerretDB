// Code generated by "genwrap -debug -schemas=documentdb_api,documentdb_api_catalog,documentdb_api_internal,documentdb_core"; DO NOT EDIT.

package documentdb_api_internal

import (
	"context"
	"log/slog"

	"github.com/FerretDB/wire/wirebson"
	"github.com/jackc/pgx/v5"
	"go.opentelemetry.io/otel"
	oteltrace "go.opentelemetry.io/otel/trace"

	"github.com/FerretDB/FerretDB/v2/internal/mongoerrors"
)

// AggregationSupport is a wrapper for
//
//	documentdb_api_internal.aggregation_support(anonymous internal, OUT aggregation_support internal).
func AggregationSupport(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outAggregationSupport struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.aggregation_support", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT aggregation_support FROM documentdb_api_internal.aggregation_support($1)", anonymous)
	if err = row.Scan(&outAggregationSupport); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.aggregation_support", l)
	}
	return
}

// AuthenticateWithScramSha256 is a wrapper for
//
//	documentdb_api_internal.authenticate_with_scram_sha256(p_user_name text, p_auth_msg text, p_client_proof text, OUT authenticate_with_scram_sha256 documentdb_core.bson).
func AuthenticateWithScramSha256(ctx context.Context, conn *pgx.Conn, l *slog.Logger, userName string, authMsg string, clientProof string) (outAuthenticateWithScramSha256 wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.authenticate_with_scram_sha256", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT authenticate_with_scram_sha256::bytea FROM documentdb_api_internal.authenticate_with_scram_sha256($1, $2, $3)", userName, authMsg, clientProof)
	if err = row.Scan(&outAuthenticateWithScramSha256); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.authenticate_with_scram_sha256", l)
	}
	return
}

// BsonAddToSet is a wrapper for
//
//	documentdb_api_internal.bson_add_to_set(anonymous documentdb_core.bson).
func BsonAddToSet(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_add_to_set", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bson_add_to_set($1::bytea)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_add_to_set", l)
	}
	return
}

// BsonAddToSetFinal is a wrapper for
//
//	documentdb_api_internal.bson_add_to_set_final(anonymous bytea, OUT bson_add_to_set_final documentdb_core.bson).
func BsonAddToSetFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonAddToSetFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_add_to_set_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_add_to_set_final::bytea FROM documentdb_api_internal.bson_add_to_set_final($1)", anonymous)
	if err = row.Scan(&outBsonAddToSetFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_add_to_set_final", l)
	}
	return
}

// BsonAddToSetTransition is a wrapper for
//
//	documentdb_api_internal.bson_add_to_set_transition(anonymous bytea, anonymous1 documentdb_core.bson, OUT bson_add_to_set_transition bytea).
func BsonAddToSetTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonAddToSetTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_add_to_set_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_add_to_set_transition FROM documentdb_api_internal.bson_add_to_set_transition($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonAddToSetTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_add_to_set_transition", l)
	}
	return
}

// BsonArrayAggMinvtransition is a wrapper for
//
//	documentdb_api_internal.bson_array_agg_minvtransition(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 text, anonymous123 boolean, OUT bson_array_agg_minvtransition bytea).
func BsonArrayAggMinvtransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 string, anonymous123 bool) (outBsonArrayAggMinvtransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_array_agg_minvtransition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_array_agg_minvtransition FROM documentdb_api_internal.bson_array_agg_minvtransition($1, $2::bytea, $3, $4)", anonymous, anonymous1, anonymous12, anonymous123)
	if err = row.Scan(&outBsonArrayAggMinvtransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_array_agg_minvtransition", l)
	}
	return
}

// BsonConstFill is a wrapper for
//
//	documentdb_api_internal.bson_const_fill(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson).
func BsonConstFill(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_const_fill", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bson_const_fill($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_const_fill", l)
	}
	return
}

// BsonCovariancePopFinal is a wrapper for
//
//	documentdb_api_internal.bson_covariance_pop_final(anonymous bytea, OUT bson_covariance_pop_final documentdb_core.bson).
func BsonCovariancePopFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonCovariancePopFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_covariance_pop_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_covariance_pop_final::bytea FROM documentdb_api_internal.bson_covariance_pop_final($1)", anonymous)
	if err = row.Scan(&outBsonCovariancePopFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_covariance_pop_final", l)
	}
	return
}

// BsonCovariancePopSampCombine is a wrapper for
//
//	documentdb_api_internal.bson_covariance_pop_samp_combine(anonymous bytea, anonymous1 bytea, OUT bson_covariance_pop_samp_combine bytea).
func BsonCovariancePopSampCombine(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}) (outBsonCovariancePopSampCombine struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_covariance_pop_samp_combine", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_covariance_pop_samp_combine FROM documentdb_api_internal.bson_covariance_pop_samp_combine($1, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonCovariancePopSampCombine); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_covariance_pop_samp_combine", l)
	}
	return
}

// BsonCovariancePopSampInvtransition is a wrapper for
//
//	documentdb_api_internal.bson_covariance_pop_samp_invtransition(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 documentdb_core.bson, OUT bson_covariance_pop_samp_invtransition bytea).
func BsonCovariancePopSampInvtransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 wirebson.RawDocument) (outBsonCovariancePopSampInvtransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_covariance_pop_samp_invtransition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_covariance_pop_samp_invtransition FROM documentdb_api_internal.bson_covariance_pop_samp_invtransition($1, $2::bytea, $3::bytea)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(&outBsonCovariancePopSampInvtransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_covariance_pop_samp_invtransition", l)
	}
	return
}

// BsonCovariancePopSampTransition is a wrapper for
//
//	documentdb_api_internal.bson_covariance_pop_samp_transition(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 documentdb_core.bson, OUT bson_covariance_pop_samp_transition bytea).
func BsonCovariancePopSampTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 wirebson.RawDocument) (outBsonCovariancePopSampTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_covariance_pop_samp_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_covariance_pop_samp_transition FROM documentdb_api_internal.bson_covariance_pop_samp_transition($1, $2::bytea, $3::bytea)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(&outBsonCovariancePopSampTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_covariance_pop_samp_transition", l)
	}
	return
}

// BsonCovarianceSampFinal is a wrapper for
//
//	documentdb_api_internal.bson_covariance_samp_final(anonymous bytea, OUT bson_covariance_samp_final documentdb_core.bson).
func BsonCovarianceSampFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonCovarianceSampFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_covariance_samp_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_covariance_samp_final::bytea FROM documentdb_api_internal.bson_covariance_samp_final($1)", anonymous)
	if err = row.Scan(&outBsonCovarianceSampFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_covariance_samp_final", l)
	}
	return
}

// BsonDenseRank is a wrapper for
//
//	documentdb_api_internal.bson_dense_rank().
func BsonDenseRank(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dense_rank", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bson_dense_rank()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dense_rank", l)
	}
	return
}

// BsonDensifyFull is a wrapper for
//
//	documentdb_api_internal.bson_densify_full(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson).
func BsonDensifyFull(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_densify_full", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bson_densify_full($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_densify_full", l)
	}
	return
}

// BsonDensifyPartition is a wrapper for
//
//	documentdb_api_internal.bson_densify_partition(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson).
func BsonDensifyPartition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_densify_partition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bson_densify_partition($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_densify_partition", l)
	}
	return
}

// BsonDensifyRange is a wrapper for
//
//	documentdb_api_internal.bson_densify_range(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson).
func BsonDensifyRange(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_densify_range", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bson_densify_range($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_densify_range", l)
	}
	return
}

// BsonDerivativeTransition is a wrapper for
//
//	documentdb_api_internal.bson_derivative_transition(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 documentdb_core.bson, anonymous123 bigint, OUT bson_derivative_transition bytea).
func BsonDerivativeTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 wirebson.RawDocument, anonymous123 int64) (outBsonDerivativeTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_derivative_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_derivative_transition FROM documentdb_api_internal.bson_derivative_transition($1, $2::bytea, $3::bytea, $4)", anonymous, anonymous1, anonymous12, anonymous123)
	if err = row.Scan(&outBsonDerivativeTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_derivative_transition", l)
	}
	return
}

// BsonDistinctArrayAggFinal is a wrapper for
//
//	documentdb_api_internal.bson_distinct_array_agg_final(anonymous bytea, OUT bson_distinct_array_agg_final documentdb_core.bson).
func BsonDistinctArrayAggFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonDistinctArrayAggFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_distinct_array_agg_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_distinct_array_agg_final::bytea FROM documentdb_api_internal.bson_distinct_array_agg_final($1)", anonymous)
	if err = row.Scan(&outBsonDistinctArrayAggFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_distinct_array_agg_final", l)
	}
	return
}

// BsonDistinctArrayAggTransition is a wrapper for
//
//	documentdb_api_internal.bson_distinct_array_agg_transition(anonymous bytea, anonymous1 documentdb_core.bson, OUT bson_distinct_array_agg_transition bytea).
func BsonDistinctArrayAggTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonDistinctArrayAggTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_distinct_array_agg_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_distinct_array_agg_transition FROM documentdb_api_internal.bson_distinct_array_agg_transition($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDistinctArrayAggTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_distinct_array_agg_transition", l)
	}
	return
}

// BsonDocumentAddScoreField is a wrapper for
//
//	documentdb_api_internal.bson_document_add_score_field(anonymous documentdb_core.bson, anonymous1 double precision, OUT bson_document_add_score_field documentdb_core.bson).
func BsonDocumentAddScoreField(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 float64) (outBsonDocumentAddScoreField wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_document_add_score_field", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_document_add_score_field::bytea FROM documentdb_api_internal.bson_document_add_score_field($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDocumentAddScoreField); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_document_add_score_field", l)
	}
	return
}

// BsonDocumentNumber is a wrapper for
//
//	documentdb_api_internal.bson_document_number().
func BsonDocumentNumber(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_document_number", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bson_document_number()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_document_number", l)
	}
	return
}

// BsonDollarAddFields is a wrapper for
//
//	documentdb_api_internal.bson_dollar_add_fields(document documentdb_core.bson, pathspec documentdb_core.bson, letvariablespec documentdb_core.bson, OUT bson_dollar_add_fields documentdb_core.bson).
func BsonDollarAddFields(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, pathSpec wirebson.RawDocument, letVariableSpec wirebson.RawDocument) (outBsonDollarAddFields wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_add_fields", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_add_fields::bytea FROM documentdb_api_internal.bson_dollar_add_fields($1::bytea, $2::bytea, $3::bytea)", document, pathSpec, letVariableSpec)
	if err = row.Scan(&outBsonDollarAddFields); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_add_fields", l)
	}
	return
}

// BsonDollarExpr is a wrapper for
//
//	documentdb_api_internal.bson_dollar_expr(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, anonymous12 documentdb_core.bson, OUT bson_dollar_expr boolean).
func BsonDollarExpr(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument, anonymous12 wirebson.RawDocument) (outBsonDollarExpr bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_expr", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_expr FROM documentdb_api_internal.bson_dollar_expr($1::bytea, $2::bytea, $3::bytea)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(&outBsonDollarExpr); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_expr", l)
	}
	return
}

// BsonDollarExtractMergeFilter is a wrapper for
//
//	documentdb_api_internal.bson_dollar_extract_merge_filter(anonymous documentdb_core.bson, anonymous1 text, OUT bson_dollar_extract_merge_filter documentdb_core.bson).
func BsonDollarExtractMergeFilter(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 string) (outBsonDollarExtractMergeFilter wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_extract_merge_filter", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_extract_merge_filter::bytea FROM documentdb_api_internal.bson_dollar_extract_merge_filter($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarExtractMergeFilter); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_extract_merge_filter", l)
	}
	return
}

// BsonDollarInverseMatch is a wrapper for
//
//	documentdb_api_internal.bson_dollar_inverse_match(document documentdb_core.bson, spec documentdb_core.bson, OUT bson_dollar_inverse_match boolean).
func BsonDollarInverseMatch(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, spec wirebson.RawDocument) (outBsonDollarInverseMatch bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_inverse_match", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_inverse_match FROM documentdb_api_internal.bson_dollar_inverse_match($1::bytea, $2::bytea)", document, spec)
	if err = row.Scan(&outBsonDollarInverseMatch); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_inverse_match", l)
	}
	return
}

// BsonDollarLookupExpressionEvalMerge is a wrapper for
//
//	documentdb_api_internal.bson_dollar_lookup_expression_eval_merge(document documentdb_core.bson, pathspec documentdb_core.bson, variablespec documentdb_core.bson, OUT bson_dollar_lookup_expression_eval_merge documentdb_core.bson).
func BsonDollarLookupExpressionEvalMerge(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, pathSpec wirebson.RawDocument, variableSpec wirebson.RawDocument) (outBsonDollarLookupExpressionEvalMerge wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_lookup_expression_eval_merge", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_lookup_expression_eval_merge::bytea FROM documentdb_api_internal.bson_dollar_lookup_expression_eval_merge($1::bytea, $2::bytea, $3::bytea)", document, pathSpec, variableSpec)
	if err = row.Scan(&outBsonDollarLookupExpressionEvalMerge); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_lookup_expression_eval_merge", l)
	}
	return
}

// BsonDollarLookupExtractFilterArray is a wrapper for
//
//	documentdb_api_internal.bson_dollar_lookup_extract_filter_array(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_lookup_extract_filter_array ARRAY).
func BsonDollarLookupExtractFilterArray(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarLookupExtractFilterArray struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_lookup_extract_filter_array", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_lookup_extract_filter_array FROM documentdb_api_internal.bson_dollar_lookup_extract_filter_array($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarLookupExtractFilterArray); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_lookup_extract_filter_array", l)
	}
	return
}

// BsonDollarLookupExtractFilterExpression is a wrapper for
//
//	documentdb_api_internal.bson_dollar_lookup_extract_filter_expression(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_lookup_extract_filter_expression documentdb_core.bson).
func BsonDollarLookupExtractFilterExpression(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarLookupExtractFilterExpression wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_lookup_extract_filter_expression", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_lookup_extract_filter_expression::bytea FROM documentdb_api_internal.bson_dollar_lookup_extract_filter_expression($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarLookupExtractFilterExpression); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_lookup_extract_filter_expression", l)
	}
	return
}

// BsonDollarLookupFilterSupport is a wrapper for
//
//	documentdb_api_internal.bson_dollar_lookup_filter_support(anonymous internal, OUT bson_dollar_lookup_filter_support internal).
func BsonDollarLookupFilterSupport(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonDollarLookupFilterSupport struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_lookup_filter_support", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_lookup_filter_support FROM documentdb_api_internal.bson_dollar_lookup_filter_support($1)", anonymous)
	if err = row.Scan(&outBsonDollarLookupFilterSupport); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_lookup_filter_support", l)
	}
	return
}

// BsonDollarLookupJoinFilter is a wrapper for
//
//	documentdb_api_internal.bson_dollar_lookup_join_filter(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, anonymous12 text, OUT bson_dollar_lookup_join_filter boolean).
func BsonDollarLookupJoinFilter(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument, anonymous12 string) (outBsonDollarLookupJoinFilter bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_lookup_join_filter", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_lookup_join_filter FROM documentdb_api_internal.bson_dollar_lookup_join_filter($1::bytea, $2::bytea, $3)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(&outBsonDollarLookupJoinFilter); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_lookup_join_filter", l)
	}
	return
}

// BsonDollarLookupProject is a wrapper for
//
//	documentdb_api_internal.bson_dollar_lookup_project(anonymous documentdb_core.bson, anonymous1 ARRAY, anonymous12 text, OUT bson_dollar_lookup_project documentdb_core.bson).
func BsonDollarLookupProject(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 struct{}, anonymous12 string) (outBsonDollarLookupProject wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_lookup_project", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_lookup_project::bytea FROM documentdb_api_internal.bson_dollar_lookup_project($1::bytea, $2, $3)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(&outBsonDollarLookupProject); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_lookup_project", l)
	}
	return
}

// BsonDollarMergeAddObjectId is a wrapper for
//
//	documentdb_api_internal.bson_dollar_merge_add_object_id(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_merge_add_object_id documentdb_core.bson).
func BsonDollarMergeAddObjectId(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarMergeAddObjectId wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_merge_add_object_id", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_merge_add_object_id::bytea FROM documentdb_api_internal.bson_dollar_merge_add_object_id($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarMergeAddObjectId); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_merge_add_object_id", l)
	}
	return
}

// BsonDollarMergeDocuments is a wrapper for
//
//	documentdb_api_internal.bson_dollar_merge_documents(document documentdb_core.bson, pathspec documentdb_core.bson, OUT bson_dollar_merge_documents documentdb_core.bson).
func BsonDollarMergeDocuments(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, pathSpec wirebson.RawDocument) (outBsonDollarMergeDocuments wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_merge_documents", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_merge_documents::bytea FROM documentdb_api_internal.bson_dollar_merge_documents($1::bytea, $2::bytea)", document, pathSpec)
	if err = row.Scan(&outBsonDollarMergeDocuments); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_merge_documents", l)
	}
	return
}

// BsonDollarMergeDocumentsAtPath is a wrapper for
//
//	documentdb_api_internal.bson_dollar_merge_documents_at_path(leftdocument documentdb_core.bson, rightdocument documentdb_core.bson, fieldpath text, OUT bson_dollar_merge_documents_at_path documentdb_core.bson).
func BsonDollarMergeDocumentsAtPath(ctx context.Context, conn *pgx.Conn, l *slog.Logger, leftdocument wirebson.RawDocument, rightdocument wirebson.RawDocument, fieldpath string) (outBsonDollarMergeDocumentsAtPath wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_merge_documents_at_path", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_merge_documents_at_path::bytea FROM documentdb_api_internal.bson_dollar_merge_documents_at_path($1::bytea, $2::bytea, $3)", leftdocument, rightdocument, fieldpath)
	if err = row.Scan(&outBsonDollarMergeDocumentsAtPath); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_merge_documents_at_path", l)
	}
	return
}

// BsonDollarMergeFailWhenNotMatched is a wrapper for
//
//	documentdb_api_internal.bson_dollar_merge_fail_when_not_matched(anonymous documentdb_core.bson, anonymous1 text, OUT bson_dollar_merge_fail_when_not_matched documentdb_core.bson).
func BsonDollarMergeFailWhenNotMatched(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 string) (outBsonDollarMergeFailWhenNotMatched wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_merge_fail_when_not_matched", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_merge_fail_when_not_matched::bytea FROM documentdb_api_internal.bson_dollar_merge_fail_when_not_matched($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarMergeFailWhenNotMatched); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_merge_fail_when_not_matched", l)
	}
	return
}

// BsonDollarMergeFilterSupport is a wrapper for
//
//	documentdb_api_internal.bson_dollar_merge_filter_support(anonymous internal, OUT bson_dollar_merge_filter_support internal).
func BsonDollarMergeFilterSupport(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonDollarMergeFilterSupport struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_merge_filter_support", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_merge_filter_support FROM documentdb_api_internal.bson_dollar_merge_filter_support($1)", anonymous)
	if err = row.Scan(&outBsonDollarMergeFilterSupport); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_merge_filter_support", l)
	}
	return
}

// BsonDollarMergeGenerateObjectId is a wrapper for
//
//	documentdb_api_internal.bson_dollar_merge_generate_object_id(anonymous documentdb_core.bson, OUT bson_dollar_merge_generate_object_id documentdb_core.bson).
func BsonDollarMergeGenerateObjectId(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument) (outBsonDollarMergeGenerateObjectId wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_merge_generate_object_id", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_merge_generate_object_id::bytea FROM documentdb_api_internal.bson_dollar_merge_generate_object_id($1::bytea)", anonymous)
	if err = row.Scan(&outBsonDollarMergeGenerateObjectId); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_merge_generate_object_id", l)
	}
	return
}

// BsonDollarMergeHandleWhenMatched is a wrapper for
//
//	documentdb_api_internal.bson_dollar_merge_handle_when_matched(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, anonymous12 integer, OUT bson_dollar_merge_handle_when_matched documentdb_core.bson).
func BsonDollarMergeHandleWhenMatched(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument, anonymous12 int32) (outBsonDollarMergeHandleWhenMatched wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_merge_handle_when_matched", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_merge_handle_when_matched::bytea FROM documentdb_api_internal.bson_dollar_merge_handle_when_matched($1::bytea, $2::bytea, $3)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(&outBsonDollarMergeHandleWhenMatched); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_merge_handle_when_matched", l)
	}
	return
}

// BsonDollarMergeJoin is a wrapper for
//
//	documentdb_api_internal.bson_dollar_merge_join(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, anonymous12 text, OUT bson_dollar_merge_join boolean).
func BsonDollarMergeJoin(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument, anonymous12 string) (outBsonDollarMergeJoin bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_merge_join", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_merge_join FROM documentdb_api_internal.bson_dollar_merge_join($1::bytea, $2::bytea, $3)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(&outBsonDollarMergeJoin); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_merge_join", l)
	}
	return
}

// BsonDollarNotGt is a wrapper for
//
//	documentdb_api_internal.bson_dollar_not_gt(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_not_gt boolean).
func BsonDollarNotGt(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarNotGt bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_not_gt", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_not_gt FROM documentdb_api_internal.bson_dollar_not_gt($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarNotGt); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_not_gt", l)
	}
	return
}

// BsonDollarNotGte is a wrapper for
//
//	documentdb_api_internal.bson_dollar_not_gte(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_not_gte boolean).
func BsonDollarNotGte(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarNotGte bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_not_gte", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_not_gte FROM documentdb_api_internal.bson_dollar_not_gte($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarNotGte); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_not_gte", l)
	}
	return
}

// BsonDollarNotLt is a wrapper for
//
//	documentdb_api_internal.bson_dollar_not_lt(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_not_lt boolean).
func BsonDollarNotLt(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarNotLt bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_not_lt", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_not_lt FROM documentdb_api_internal.bson_dollar_not_lt($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarNotLt); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_not_lt", l)
	}
	return
}

// BsonDollarNotLte is a wrapper for
//
//	documentdb_api_internal.bson_dollar_not_lte(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_not_lte boolean).
func BsonDollarNotLte(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarNotLte bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_not_lte", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_not_lte FROM documentdb_api_internal.bson_dollar_not_lte($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarNotLte); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_not_lte", l)
	}
	return
}

// BsonDollarProject is a wrapper for
//
//	documentdb_api_internal.bson_dollar_project(document documentdb_core.bson, pathspec documentdb_core.bson, variablespec documentdb_core.bson, OUT bson_dollar_project documentdb_core.bson).
func BsonDollarProject(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, pathSpec wirebson.RawDocument, variableSpec wirebson.RawDocument) (outBsonDollarProject wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_project", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_project::bytea FROM documentdb_api_internal.bson_dollar_project($1::bytea, $2::bytea, $3::bytea)", document, pathSpec, variableSpec)
	if err = row.Scan(&outBsonDollarProject); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_project", l)
	}
	return
}

// BsonDollarProjectFind is a wrapper for
//
//	documentdb_api_internal.bson_dollar_project_find(document documentdb_core.bson, pathspec documentdb_core.bson, queryspec documentdb_core.bson, letvariablespec documentdb_core.bson, OUT bson_dollar_project_find documentdb_core.bson).
func BsonDollarProjectFind(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, pathSpec wirebson.RawDocument, querySpec wirebson.RawDocument, letVariableSpec wirebson.RawDocument) (outBsonDollarProjectFind wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_project_find", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_project_find::bytea FROM documentdb_api_internal.bson_dollar_project_find($1::bytea, $2::bytea, $3::bytea, $4::bytea)", document, pathSpec, querySpec, letVariableSpec)
	if err = row.Scan(&outBsonDollarProjectFind); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_project_find", l)
	}
	return
}

// BsonDollarRange is a wrapper for
//
//	documentdb_api_internal.bson_dollar_range(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_range boolean).
func BsonDollarRange(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarRange bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_range", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_range FROM documentdb_api_internal.bson_dollar_range($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarRange); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_range", l)
	}
	return
}

// BsonDollarRedact is a wrapper for
//
//	documentdb_api_internal.bson_dollar_redact(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, anonymous12 text, anonymous123 documentdb_core.bson, OUT bson_dollar_redact documentdb_core.bson).
func BsonDollarRedact(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument, anonymous12 string, anonymous123 wirebson.RawDocument) (outBsonDollarRedact wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_redact", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_redact::bytea FROM documentdb_api_internal.bson_dollar_redact($1::bytea, $2::bytea, $3, $4::bytea)", anonymous, anonymous1, anonymous12, anonymous123)
	if err = row.Scan(&outBsonDollarRedact); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_redact", l)
	}
	return
}

// BsonDollarReplaceRoot is a wrapper for
//
//	documentdb_api_internal.bson_dollar_replace_root(document documentdb_core.bson, pathspec documentdb_core.bson, variablespec documentdb_core.bson, OUT bson_dollar_replace_root documentdb_core.bson).
func BsonDollarReplaceRoot(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, pathSpec wirebson.RawDocument, variableSpec wirebson.RawDocument) (outBsonDollarReplaceRoot wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_replace_root", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_replace_root::bytea FROM documentdb_api_internal.bson_dollar_replace_root($1::bytea, $2::bytea, $3::bytea)", document, pathSpec, variableSpec)
	if err = row.Scan(&outBsonDollarReplaceRoot); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_replace_root", l)
	}
	return
}

// BsonDollarSelectivity is a wrapper for
//
//	documentdb_api_internal.bson_dollar_selectivity(anonymous internal, anonymous1 oid, anonymous12 internal, anonymous123 integer, OUT bson_dollar_selectivity double precision).
func BsonDollarSelectivity(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}, anonymous12 struct{}, anonymous123 int32) (outBsonDollarSelectivity float64, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_selectivity", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_selectivity FROM documentdb_api_internal.bson_dollar_selectivity($1, $2, $3, $4)", anonymous, anonymous1, anonymous12, anonymous123)
	if err = row.Scan(&outBsonDollarSelectivity); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_selectivity", l)
	}
	return
}

// BsonDollarText is a wrapper for
//
//	documentdb_api_internal.bson_dollar_text(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_dollar_text boolean).
func BsonDollarText(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonDollarText bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_dollar_text", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_dollar_text FROM documentdb_api_internal.bson_dollar_text($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonDollarText); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_dollar_text", l)
	}
	return
}

// BsonExpMovingAvg is a wrapper for
//
//	documentdb_api_internal.bson_exp_moving_avg(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, anonymous12 boolean).
func BsonExpMovingAvg(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument, anonymous12 bool) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_exp_moving_avg", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bson_exp_moving_avg($1::bytea, $2::bytea, $3)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_exp_moving_avg", l)
	}
	return
}

// BsonExpressionGet is a wrapper for
//
//	documentdb_api_internal.bson_expression_get(document documentdb_core.bson, expressionspec documentdb_core.bson, isnullonempty boolean, variablespec documentdb_core.bson, OUT bson_expression_get documentdb_core.bson).
func BsonExpressionGet(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, expressionSpec wirebson.RawDocument, isnullonempty bool, variableSpec wirebson.RawDocument) (outBsonExpressionGet wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_expression_get", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_expression_get::bytea FROM documentdb_api_internal.bson_expression_get($1::bytea, $2::bytea, $3, $4::bytea)", document, expressionSpec, isnullonempty, variableSpec)
	if err = row.Scan(&outBsonExpressionGet); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_expression_get", l)
	}
	return
}

// BsonExpressionMap is a wrapper for
//
//	documentdb_api_internal.bson_expression_map(document documentdb_core.bson, sourcearrayname text, expressionspec documentdb_core.bson, isnullonempty boolean, variablespec documentdb_core.bson, OUT bson_expression_map documentdb_core.bson).
func BsonExpressionMap(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, sourcearrayname string, expressionSpec wirebson.RawDocument, isnullonempty bool, variableSpec wirebson.RawDocument) (outBsonExpressionMap wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_expression_map", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_expression_map::bytea FROM documentdb_api_internal.bson_expression_map($1::bytea, $2, $3::bytea, $4, $5::bytea)", document, sourcearrayname, expressionSpec, isnullonempty, variableSpec)
	if err = row.Scan(&outBsonExpressionMap); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_expression_map", l)
	}
	return
}

// BsonExpressionPartitionByFieldsGet is a wrapper for
//
//	documentdb_api_internal.bson_expression_partition_by_fields_get(document documentdb_core.bson, expressionspec documentdb_core.bson, OUT bson_expression_partition_by_fields_get documentdb_core.bson).
func BsonExpressionPartitionByFieldsGet(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, expressionSpec wirebson.RawDocument) (outBsonExpressionPartitionByFieldsGet wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_expression_partition_by_fields_get", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_expression_partition_by_fields_get::bytea FROM documentdb_api_internal.bson_expression_partition_by_fields_get($1::bytea, $2::bytea)", document, expressionSpec)
	if err = row.Scan(&outBsonExpressionPartitionByFieldsGet); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_expression_partition_by_fields_get", l)
	}
	return
}

// BsonExpressionPartitionGet is a wrapper for
//
//	documentdb_api_internal.bson_expression_partition_get(document documentdb_core.bson, expressionspec documentdb_core.bson, isnullonempty boolean DEFAULT false, OUT bson_expression_partition_get documentdb_core.bson).
func BsonExpressionPartitionGet(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, expressionSpec wirebson.RawDocument, isnullonempty bool) (outBsonExpressionPartitionGet wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_expression_partition_get", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_expression_partition_get::bytea FROM documentdb_api_internal.bson_expression_partition_get($1::bytea, $2::bytea, $3)", document, expressionSpec, isnullonempty)
	if err = row.Scan(&outBsonExpressionPartitionGet); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_expression_partition_get", l)
	}
	return
}

// BsonExpressionPartitionGet1 is a wrapper for
//
//	documentdb_api_internal.bson_expression_partition_get(document documentdb_core.bson, expressionspec documentdb_core.bson, isnullonempty boolean, variablespec documentdb_core.bson, OUT bson_expression_partition_get documentdb_core.bson).
func BsonExpressionPartitionGet1(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, expressionSpec wirebson.RawDocument, isnullonempty bool, variableSpec wirebson.RawDocument) (outBsonExpressionPartitionGet wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_expression_partition_get", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_expression_partition_get::bytea FROM documentdb_api_internal.bson_expression_partition_get($1::bytea, $2::bytea, $3, $4::bytea)", document, expressionSpec, isnullonempty, variableSpec)
	if err = row.Scan(&outBsonExpressionPartitionGet); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_expression_partition_get", l)
	}
	return
}

// BsonExtractVector is a wrapper for
//
//	documentdb_api_internal.bson_extract_vector(document documentdb_core.bson, path text, OUT bson_extract_vector public.vector).
func BsonExtractVector(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, path string) (outBsonExtractVector struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_extract_vector", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_extract_vector FROM documentdb_api_internal.bson_extract_vector($1::bytea, $2)", document, path)
	if err = row.Scan(&outBsonExtractVector); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_extract_vector", l)
	}
	return
}

// BsonFirstTransition is a wrapper for
//
//	documentdb_api_internal.bson_first_transition(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 ARRAY, anonymous123 documentdb_core.bson DEFAULT NULL, OUT bson_first_transition bytea).
func BsonFirstTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 struct{}, anonymous123 wirebson.RawDocument) (outBsonFirstTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_first_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_first_transition FROM documentdb_api_internal.bson_first_transition($1, $2::bytea, $3, $4::bytea)", anonymous, anonymous1, anonymous12, anonymous123)
	if err = row.Scan(&outBsonFirstTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_first_transition", l)
	}
	return
}

// BsonFirstTransitionOnSorted is a wrapper for
//
//	documentdb_api_internal.bson_first_transition_on_sorted(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 documentdb_core.bson DEFAULT NULL, OUT bson_first_transition_on_sorted bytea).
func BsonFirstTransitionOnSorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 wirebson.RawDocument) (outBsonFirstTransitionOnSorted struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_first_transition_on_sorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_first_transition_on_sorted FROM documentdb_api_internal.bson_first_transition_on_sorted($1, $2::bytea, $3::bytea)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(&outBsonFirstTransitionOnSorted); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_first_transition_on_sorted", l)
	}
	return
}

// BsonFirstnTransition is a wrapper for
//
//	documentdb_api_internal.bson_firstn_transition(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 bigint, anonymous123 ARRAY, anonymous1234 documentdb_core.bson DEFAULT NULL, OUT bson_firstn_transition bytea).
func BsonFirstnTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 int64, anonymous123 struct{}, anonymous1234 wirebson.RawDocument) (outBsonFirstnTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_firstn_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_firstn_transition FROM documentdb_api_internal.bson_firstn_transition($1, $2::bytea, $3, $4, $5::bytea)", anonymous, anonymous1, anonymous12, anonymous123, anonymous1234)
	if err = row.Scan(&outBsonFirstnTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_firstn_transition", l)
	}
	return
}

// BsonFirstnTransitionOnSorted is a wrapper for
//
//	documentdb_api_internal.bson_firstn_transition_on_sorted(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 bigint, anonymous123 documentdb_core.bson DEFAULT NULL, OUT bson_firstn_transition_on_sorted bytea).
func BsonFirstnTransitionOnSorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 int64, anonymous123 wirebson.RawDocument) (outBsonFirstnTransitionOnSorted struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_firstn_transition_on_sorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_firstn_transition_on_sorted FROM documentdb_api_internal.bson_firstn_transition_on_sorted($1, $2::bytea, $3, $4::bytea)", anonymous, anonymous1, anonymous12, anonymous123)
	if err = row.Scan(&outBsonFirstnTransitionOnSorted); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_firstn_transition_on_sorted", l)
	}
	return
}

// BsonGeonearWithinRange is a wrapper for
//
//	documentdb_api_internal.bson_geonear_within_range(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_geonear_within_range boolean).
func BsonGeonearWithinRange(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonGeonearWithinRange bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_geonear_within_range", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_geonear_within_range FROM documentdb_api_internal.bson_geonear_within_range($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonGeonearWithinRange); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_geonear_within_range", l)
	}
	return
}

// BsonIntegralDerivativeFinal is a wrapper for
//
//	documentdb_api_internal.bson_integral_derivative_final(anonymous bytea, OUT bson_integral_derivative_final documentdb_core.bson).
func BsonIntegralDerivativeFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonIntegralDerivativeFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_integral_derivative_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_integral_derivative_final::bytea FROM documentdb_api_internal.bson_integral_derivative_final($1)", anonymous)
	if err = row.Scan(&outBsonIntegralDerivativeFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_integral_derivative_final", l)
	}
	return
}

// BsonIntegralTransition is a wrapper for
//
//	documentdb_api_internal.bson_integral_transition(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 documentdb_core.bson, anonymous123 bigint, OUT bson_integral_transition bytea).
func BsonIntegralTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 wirebson.RawDocument, anonymous123 int64) (outBsonIntegralTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_integral_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_integral_transition FROM documentdb_api_internal.bson_integral_transition($1, $2::bytea, $3::bytea, $4)", anonymous, anonymous1, anonymous12, anonymous123)
	if err = row.Scan(&outBsonIntegralTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_integral_transition", l)
	}
	return
}

// BsonLastTransition is a wrapper for
//
//	documentdb_api_internal.bson_last_transition(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 ARRAY, anonymous123 documentdb_core.bson DEFAULT NULL, OUT bson_last_transition bytea).
func BsonLastTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 struct{}, anonymous123 wirebson.RawDocument) (outBsonLastTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_last_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_last_transition FROM documentdb_api_internal.bson_last_transition($1, $2::bytea, $3, $4::bytea)", anonymous, anonymous1, anonymous12, anonymous123)
	if err = row.Scan(&outBsonLastTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_last_transition", l)
	}
	return
}

// BsonLastTransitionOnSorted is a wrapper for
//
//	documentdb_api_internal.bson_last_transition_on_sorted(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 documentdb_core.bson DEFAULT NULL, OUT bson_last_transition_on_sorted bytea).
func BsonLastTransitionOnSorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 wirebson.RawDocument) (outBsonLastTransitionOnSorted struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_last_transition_on_sorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_last_transition_on_sorted FROM documentdb_api_internal.bson_last_transition_on_sorted($1, $2::bytea, $3::bytea)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(&outBsonLastTransitionOnSorted); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_last_transition_on_sorted", l)
	}
	return
}

// BsonLastnTransition is a wrapper for
//
//	documentdb_api_internal.bson_lastn_transition(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 bigint, anonymous123 ARRAY, anonymous1234 documentdb_core.bson DEFAULT NULL, OUT bson_lastn_transition bytea).
func BsonLastnTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 int64, anonymous123 struct{}, anonymous1234 wirebson.RawDocument) (outBsonLastnTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_lastn_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_lastn_transition FROM documentdb_api_internal.bson_lastn_transition($1, $2::bytea, $3, $4, $5::bytea)", anonymous, anonymous1, anonymous12, anonymous123, anonymous1234)
	if err = row.Scan(&outBsonLastnTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_lastn_transition", l)
	}
	return
}

// BsonLastnTransitionOnSorted is a wrapper for
//
//	documentdb_api_internal.bson_lastn_transition_on_sorted(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 bigint, anonymous123 documentdb_core.bson DEFAULT NULL, OUT bson_lastn_transition_on_sorted bytea).
func BsonLastnTransitionOnSorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 int64, anonymous123 wirebson.RawDocument) (outBsonLastnTransitionOnSorted struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_lastn_transition_on_sorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_lastn_transition_on_sorted FROM documentdb_api_internal.bson_lastn_transition_on_sorted($1, $2::bytea, $3, $4::bytea)", anonymous, anonymous1, anonymous12, anonymous123)
	if err = row.Scan(&outBsonLastnTransitionOnSorted); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_lastn_transition_on_sorted", l)
	}
	return
}

// BsonLinearFill is a wrapper for
//
//	documentdb_api_internal.bson_linear_fill(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson).
func BsonLinearFill(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_linear_fill", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bson_linear_fill($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_linear_fill", l)
	}
	return
}

// BsonLocfFill is a wrapper for
//
//	documentdb_api_internal.bson_locf_fill(anonymous documentdb_core.bson).
func BsonLocfFill(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_locf_fill", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bson_locf_fill($1::bytea)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_locf_fill", l)
	}
	return
}

// BsonMaxminnCombine is a wrapper for
//
//	documentdb_api_internal.bson_maxminn_combine(anonymous bytea, anonymous1 bytea, OUT bson_maxminn_combine bytea).
func BsonMaxminnCombine(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}) (outBsonMaxminnCombine struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_maxminn_combine", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_maxminn_combine FROM documentdb_api_internal.bson_maxminn_combine($1, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonMaxminnCombine); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_maxminn_combine", l)
	}
	return
}

// BsonMaxminnFinal is a wrapper for
//
//	documentdb_api_internal.bson_maxminn_final(anonymous bytea, OUT bson_maxminn_final documentdb_core.bson).
func BsonMaxminnFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonMaxminnFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_maxminn_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_maxminn_final::bytea FROM documentdb_api_internal.bson_maxminn_final($1)", anonymous)
	if err = row.Scan(&outBsonMaxminnFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_maxminn_final", l)
	}
	return
}

// BsonMaxnTransition is a wrapper for
//
//	documentdb_api_internal.bson_maxn_transition(anonymous bytea, anonymous1 documentdb_core.bson, OUT bson_maxn_transition bytea).
func BsonMaxnTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonMaxnTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_maxn_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_maxn_transition FROM documentdb_api_internal.bson_maxn_transition($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonMaxnTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_maxn_transition", l)
	}
	return
}

// BsonMergeObjects is a wrapper for
//
//	documentdb_api_internal.bson_merge_objects(anonymous documentdb_core.bson, anonymous1 bigint, anonymous12 ARRAY, anonymous123 documentdb_core.bson).
func BsonMergeObjects(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 int64, anonymous12 struct{}, anonymous123 wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_merge_objects", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bson_merge_objects($1::bytea, $2, $3, $4::bytea)", anonymous, anonymous1, anonymous12, anonymous123)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_merge_objects", l)
	}
	return
}

// BsonMergeObjectsFinal is a wrapper for
//
//	documentdb_api_internal.bson_merge_objects_final(anonymous bytea, OUT bson_merge_objects_final documentdb_core.bson).
func BsonMergeObjectsFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonMergeObjectsFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_merge_objects_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_merge_objects_final::bytea FROM documentdb_api_internal.bson_merge_objects_final($1)", anonymous)
	if err = row.Scan(&outBsonMergeObjectsFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_merge_objects_final", l)
	}
	return
}

// BsonMergeObjectsOnSorted is a wrapper for
//
//	documentdb_api_internal.bson_merge_objects_on_sorted(anonymous documentdb_core.bson).
func BsonMergeObjectsOnSorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_merge_objects_on_sorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bson_merge_objects_on_sorted($1::bytea)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_merge_objects_on_sorted", l)
	}
	return
}

// BsonMergeObjectsTransition is a wrapper for
//
//	documentdb_api_internal.bson_merge_objects_transition(anonymous bytea, anonymous1 documentdb_core.bson, anonymous12 bigint, anonymous123 ARRAY, anonymous1234 documentdb_core.bson, OUT bson_merge_objects_transition bytea).
func BsonMergeObjectsTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 int64, anonymous123 struct{}, anonymous1234 wirebson.RawDocument) (outBsonMergeObjectsTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_merge_objects_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_merge_objects_transition FROM documentdb_api_internal.bson_merge_objects_transition($1, $2::bytea, $3, $4, $5::bytea)", anonymous, anonymous1, anonymous12, anonymous123, anonymous1234)
	if err = row.Scan(&outBsonMergeObjectsTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_merge_objects_transition", l)
	}
	return
}

// BsonMergeObjectsTransitionOnSorted is a wrapper for
//
//	documentdb_api_internal.bson_merge_objects_transition_on_sorted(anonymous bytea, anonymous1 documentdb_core.bson, OUT bson_merge_objects_transition_on_sorted bytea).
func BsonMergeObjectsTransitionOnSorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonMergeObjectsTransitionOnSorted struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_merge_objects_transition_on_sorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_merge_objects_transition_on_sorted FROM documentdb_api_internal.bson_merge_objects_transition_on_sorted($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonMergeObjectsTransitionOnSorted); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_merge_objects_transition_on_sorted", l)
	}
	return
}

// BsonMinnTransition is a wrapper for
//
//	documentdb_api_internal.bson_minn_transition(anonymous bytea, anonymous1 documentdb_core.bson, OUT bson_minn_transition bytea).
func BsonMinnTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonMinnTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_minn_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_minn_transition FROM documentdb_api_internal.bson_minn_transition($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonMinnTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_minn_transition", l)
	}
	return
}

// BsonOrderbyPartition is a wrapper for
//
//	documentdb_api_internal.bson_orderby_partition(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, anonymous12 boolean, OUT bson_orderby_partition documentdb_core.bson).
func BsonOrderbyPartition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument, anonymous12 bool) (outBsonOrderbyPartition wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_orderby_partition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_orderby_partition::bytea FROM documentdb_api_internal.bson_orderby_partition($1::bytea, $2::bytea, $3)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(&outBsonOrderbyPartition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_orderby_partition", l)
	}
	return
}

// BsonQueryToTsquery is a wrapper for
//
//	documentdb_api_internal.bson_query_to_tsquery(query documentdb_core.bson, textsearch text DEFAULT NULL, OUT bson_query_to_tsquery tsquery).
func BsonQueryToTsquery(ctx context.Context, conn *pgx.Conn, l *slog.Logger, query wirebson.RawDocument, textsearch string) (outBsonQueryToTsquery struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_query_to_tsquery", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_query_to_tsquery FROM documentdb_api_internal.bson_query_to_tsquery($1::bytea, $2)", query, textsearch)
	if err = row.Scan(&outBsonQueryToTsquery); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_query_to_tsquery", l)
	}
	return
}

// BsonRank is a wrapper for
//
//	documentdb_api_internal.bson_rank().
func BsonRank(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_rank", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bson_rank()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_rank", l)
	}
	return
}

// BsonSearchParam is a wrapper for
//
//	documentdb_api_internal.bson_search_param(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_search_param boolean).
func BsonSearchParam(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonSearchParam bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_search_param", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_search_param FROM documentdb_api_internal.bson_search_param($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonSearchParam); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_search_param", l)
	}
	return
}

// BsonShift is a wrapper for
//
//	documentdb_api_internal.bson_shift(anonymous documentdb_core.bson, anonymous1 integer, anonymous12 documentdb_core.bson).
func BsonShift(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 int32, anonymous12 wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_shift", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bson_shift($1::bytea, $2, $3::bytea)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_shift", l)
	}
	return
}

// BsonStdDevPopFinal is a wrapper for
//
//	documentdb_api_internal.bson_std_dev_pop_final(anonymous bytea, OUT bson_std_dev_pop_final documentdb_core.bson).
func BsonStdDevPopFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonStdDevPopFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_std_dev_pop_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_std_dev_pop_final::bytea FROM documentdb_api_internal.bson_std_dev_pop_final($1)", anonymous)
	if err = row.Scan(&outBsonStdDevPopFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_std_dev_pop_final", l)
	}
	return
}

// BsonStdDevPopSampCombine is a wrapper for
//
//	documentdb_api_internal.bson_std_dev_pop_samp_combine(anonymous bytea, anonymous1 bytea, OUT bson_std_dev_pop_samp_combine bytea).
func BsonStdDevPopSampCombine(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}) (outBsonStdDevPopSampCombine struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_std_dev_pop_samp_combine", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_std_dev_pop_samp_combine FROM documentdb_api_internal.bson_std_dev_pop_samp_combine($1, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonStdDevPopSampCombine); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_std_dev_pop_samp_combine", l)
	}
	return
}

// BsonStdDevPopSampTransition is a wrapper for
//
//	documentdb_api_internal.bson_std_dev_pop_samp_transition(anonymous bytea, anonymous1 documentdb_core.bson, OUT bson_std_dev_pop_samp_transition bytea).
func BsonStdDevPopSampTransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonStdDevPopSampTransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_std_dev_pop_samp_transition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_std_dev_pop_samp_transition FROM documentdb_api_internal.bson_std_dev_pop_samp_transition($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonStdDevPopSampTransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_std_dev_pop_samp_transition", l)
	}
	return
}

// BsonStdDevPopSampWinfuncInvtransition is a wrapper for
//
//	documentdb_api_internal.bson_std_dev_pop_samp_winfunc_invtransition(anonymous bytea, anonymous1 documentdb_core.bson, OUT bson_std_dev_pop_samp_winfunc_invtransition bytea).
func BsonStdDevPopSampWinfuncInvtransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonStdDevPopSampWinfuncInvtransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_std_dev_pop_samp_winfunc_invtransition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_std_dev_pop_samp_winfunc_invtransition FROM documentdb_api_internal.bson_std_dev_pop_samp_winfunc_invtransition($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonStdDevPopSampWinfuncInvtransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_std_dev_pop_samp_winfunc_invtransition", l)
	}
	return
}

// BsonStdDevPopWinfuncFinal is a wrapper for
//
//	documentdb_api_internal.bson_std_dev_pop_winfunc_final(anonymous bytea, OUT bson_std_dev_pop_winfunc_final documentdb_core.bson).
func BsonStdDevPopWinfuncFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonStdDevPopWinfuncFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_std_dev_pop_winfunc_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_std_dev_pop_winfunc_final::bytea FROM documentdb_api_internal.bson_std_dev_pop_winfunc_final($1)", anonymous)
	if err = row.Scan(&outBsonStdDevPopWinfuncFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_std_dev_pop_winfunc_final", l)
	}
	return
}

// BsonStdDevSampFinal is a wrapper for
//
//	documentdb_api_internal.bson_std_dev_samp_final(anonymous bytea, OUT bson_std_dev_samp_final documentdb_core.bson).
func BsonStdDevSampFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonStdDevSampFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_std_dev_samp_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_std_dev_samp_final::bytea FROM documentdb_api_internal.bson_std_dev_samp_final($1)", anonymous)
	if err = row.Scan(&outBsonStdDevSampFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_std_dev_samp_final", l)
	}
	return
}

// BsonStdDevSampWinfuncFinal is a wrapper for
//
//	documentdb_api_internal.bson_std_dev_samp_winfunc_final(anonymous bytea, OUT bson_std_dev_samp_winfunc_final documentdb_core.bson).
func BsonStdDevSampWinfuncFinal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outBsonStdDevSampWinfuncFinal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_std_dev_samp_winfunc_final", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_std_dev_samp_winfunc_final::bytea FROM documentdb_api_internal.bson_std_dev_samp_winfunc_final($1)", anonymous)
	if err = row.Scan(&outBsonStdDevSampWinfuncFinal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_std_dev_samp_winfunc_final", l)
	}
	return
}

// BsonSumAvgMinvtransition is a wrapper for
//
//	documentdb_api_internal.bson_sum_avg_minvtransition(anonymous bytea, anonymous1 documentdb_core.bson, OUT bson_sum_avg_minvtransition bytea).
func BsonSumAvgMinvtransition(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonSumAvgMinvtransition struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_sum_avg_minvtransition", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_sum_avg_minvtransition FROM documentdb_api_internal.bson_sum_avg_minvtransition($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonSumAvgMinvtransition); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_sum_avg_minvtransition", l)
	}
	return
}

// BsonTextMetaQual is a wrapper for
//
//	documentdb_api_internal.bson_text_meta_qual(anonymous documentdb_core.bson, anonymous1 tsquery, anonymous12 bytea, anonymous123 boolean, OUT bson_text_meta_qual boolean).
func BsonTextMetaQual(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 struct{}, anonymous12 struct{}, anonymous123 bool) (outBsonTextMetaQual bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_text_meta_qual", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_text_meta_qual FROM documentdb_api_internal.bson_text_meta_qual($1::bytea, $2, $3, $4)", anonymous, anonymous1, anonymous12, anonymous123)
	if err = row.Scan(&outBsonTextMetaQual); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_text_meta_qual", l)
	}
	return
}

// BsonTextTsquery is a wrapper for
//
//	documentdb_api_internal.bson_text_tsquery(anonymous documentdb_core.bson, anonymous1 tsquery, OUT bson_text_tsquery boolean).
func BsonTextTsquery(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 struct{}) (outBsonTextTsquery bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_text_tsquery", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_text_tsquery FROM documentdb_api_internal.bson_text_tsquery($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonTextTsquery); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_text_tsquery", l)
	}
	return
}

// BsonUniqueExclusionIndexEqual is a wrapper for
//
//	documentdb_api_internal.bson_unique_exclusion_index_equal(anonymous documentdb_api_catalog.shard_key_and_document, anonymous1 documentdb_api_catalog.shard_key_and_document, OUT bson_unique_exclusion_index_equal boolean).
func BsonUniqueExclusionIndexEqual(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}) (outBsonUniqueExclusionIndexEqual bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_unique_exclusion_index_equal", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_unique_exclusion_index_equal FROM documentdb_api_internal.bson_unique_exclusion_index_equal($1, $2)", anonymous, anonymous1)
	if err = row.Scan(&outBsonUniqueExclusionIndexEqual); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_unique_exclusion_index_equal", l)
	}
	return
}

// BsonUniqueIndexEqual is a wrapper for
//
//	documentdb_api_internal.bson_unique_index_equal(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_unique_index_equal boolean).
func BsonUniqueIndexEqual(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonUniqueIndexEqual bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_unique_index_equal", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_unique_index_equal FROM documentdb_api_internal.bson_unique_index_equal($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonUniqueIndexEqual); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_unique_index_equal", l)
	}
	return
}

// BsonUniqueShardPathEqual is a wrapper for
//
//	documentdb_api_internal.bson_unique_shard_path_equal(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT bson_unique_shard_path_equal boolean).
func BsonUniqueShardPathEqual(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outBsonUniqueShardPathEqual bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_unique_shard_path_equal", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_unique_shard_path_equal FROM documentdb_api_internal.bson_unique_shard_path_equal($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonUniqueShardPathEqual); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_unique_shard_path_equal", l)
	}
	return
}

// BsonUpdateDocument is a wrapper for
//
//	documentdb_api_internal.bson_update_document(document documentdb_core.bson, updatespec documentdb_core.bson, queryspec documentdb_core.bson, arrayfilters documentdb_core.bson DEFAULT NULL, buildupdatedesc boolean DEFAULT false, OUT newdocument documentdb_core.bson, OUT updatedesc documentdb_core.bson).
func BsonUpdateDocument(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, updateSpec wirebson.RawDocument, querySpec wirebson.RawDocument, arrayfilters wirebson.RawDocument, buildupdatedesc bool) (outNewdocument wirebson.RawDocument, outUpdatedesc wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_update_document", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT newdocument::bytea, updatedesc::bytea FROM documentdb_api_internal.bson_update_document($1::bytea, $2::bytea, $3::bytea, $4::bytea, $5)", document, updateSpec, querySpec, arrayfilters, buildupdatedesc)
	if err = row.Scan(&outNewdocument, &outUpdatedesc); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_update_document", l)
	}
	return
}

// BsonUpdateReturnedValue is a wrapper for
//
//	documentdb_api_internal.bson_update_returned_value(shard_key_id bigint, OUT bson_update_returned_value integer).
func BsonUpdateReturnedValue(ctx context.Context, conn *pgx.Conn, l *slog.Logger, shardKeyId int64) (outBsonUpdateReturnedValue int32, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_update_returned_value", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_update_returned_value FROM documentdb_api_internal.bson_update_returned_value($1)", shardKeyId)
	if err = row.Scan(&outBsonUpdateReturnedValue); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_update_returned_value", l)
	}
	return
}

// BsonValueDollarAll is a wrapper for
//
//	documentdb_api_internal.bson_value_dollar_all(anonymous internal, anonymous1 documentdb_core.bson, OUT bson_value_dollar_all internal).
func BsonValueDollarAll(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonValueDollarAll struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_value_dollar_all", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_value_dollar_all FROM documentdb_api_internal.bson_value_dollar_all($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonValueDollarAll); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_value_dollar_all", l)
	}
	return
}

// BsonValueDollarBitsAllClear is a wrapper for
//
//	documentdb_api_internal.bson_value_dollar_bits_all_clear(anonymous internal, anonymous1 documentdb_core.bson, OUT bson_value_dollar_bits_all_clear internal).
func BsonValueDollarBitsAllClear(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonValueDollarBitsAllClear struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_value_dollar_bits_all_clear", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_value_dollar_bits_all_clear FROM documentdb_api_internal.bson_value_dollar_bits_all_clear($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonValueDollarBitsAllClear); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_value_dollar_bits_all_clear", l)
	}
	return
}

// BsonValueDollarBitsAllSet is a wrapper for
//
//	documentdb_api_internal.bson_value_dollar_bits_all_set(anonymous internal, anonymous1 documentdb_core.bson, OUT bson_value_dollar_bits_all_set internal).
func BsonValueDollarBitsAllSet(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonValueDollarBitsAllSet struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_value_dollar_bits_all_set", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_value_dollar_bits_all_set FROM documentdb_api_internal.bson_value_dollar_bits_all_set($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonValueDollarBitsAllSet); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_value_dollar_bits_all_set", l)
	}
	return
}

// BsonValueDollarBitsAnyClear is a wrapper for
//
//	documentdb_api_internal.bson_value_dollar_bits_any_clear(anonymous internal, anonymous1 documentdb_core.bson, OUT bson_value_dollar_bits_any_clear internal).
func BsonValueDollarBitsAnyClear(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonValueDollarBitsAnyClear struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_value_dollar_bits_any_clear", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_value_dollar_bits_any_clear FROM documentdb_api_internal.bson_value_dollar_bits_any_clear($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonValueDollarBitsAnyClear); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_value_dollar_bits_any_clear", l)
	}
	return
}

// BsonValueDollarBitsAnySet is a wrapper for
//
//	documentdb_api_internal.bson_value_dollar_bits_any_set(anonymous internal, anonymous1 documentdb_core.bson, OUT bson_value_dollar_bits_any_set internal).
func BsonValueDollarBitsAnySet(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonValueDollarBitsAnySet struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_value_dollar_bits_any_set", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_value_dollar_bits_any_set FROM documentdb_api_internal.bson_value_dollar_bits_any_set($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonValueDollarBitsAnySet); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_value_dollar_bits_any_set", l)
	}
	return
}

// BsonValueDollarElemmatch is a wrapper for
//
//	documentdb_api_internal.bson_value_dollar_elemmatch(anonymous internal, anonymous1 documentdb_core.bson, OUT bson_value_dollar_elemmatch internal).
func BsonValueDollarElemmatch(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonValueDollarElemmatch struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_value_dollar_elemmatch", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_value_dollar_elemmatch FROM documentdb_api_internal.bson_value_dollar_elemmatch($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonValueDollarElemmatch); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_value_dollar_elemmatch", l)
	}
	return
}

// BsonValueDollarEq is a wrapper for
//
//	documentdb_api_internal.bson_value_dollar_eq(anonymous internal, anonymous1 documentdb_core.bson, OUT bson_value_dollar_eq internal).
func BsonValueDollarEq(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonValueDollarEq struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_value_dollar_eq", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_value_dollar_eq FROM documentdb_api_internal.bson_value_dollar_eq($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonValueDollarEq); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_value_dollar_eq", l)
	}
	return
}

// BsonValueDollarExists is a wrapper for
//
//	documentdb_api_internal.bson_value_dollar_exists(anonymous internal, anonymous1 documentdb_core.bson, OUT bson_value_dollar_exists internal).
func BsonValueDollarExists(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonValueDollarExists struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_value_dollar_exists", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_value_dollar_exists FROM documentdb_api_internal.bson_value_dollar_exists($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonValueDollarExists); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_value_dollar_exists", l)
	}
	return
}

// BsonValueDollarGt is a wrapper for
//
//	documentdb_api_internal.bson_value_dollar_gt(anonymous internal, anonymous1 documentdb_core.bson, OUT bson_value_dollar_gt internal).
func BsonValueDollarGt(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonValueDollarGt struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_value_dollar_gt", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_value_dollar_gt FROM documentdb_api_internal.bson_value_dollar_gt($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonValueDollarGt); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_value_dollar_gt", l)
	}
	return
}

// BsonValueDollarGte is a wrapper for
//
//	documentdb_api_internal.bson_value_dollar_gte(anonymous internal, anonymous1 documentdb_core.bson, OUT bson_value_dollar_gte internal).
func BsonValueDollarGte(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonValueDollarGte struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_value_dollar_gte", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_value_dollar_gte FROM documentdb_api_internal.bson_value_dollar_gte($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonValueDollarGte); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_value_dollar_gte", l)
	}
	return
}

// BsonValueDollarIn is a wrapper for
//
//	documentdb_api_internal.bson_value_dollar_in(anonymous internal, anonymous1 documentdb_core.bson, OUT bson_value_dollar_in internal).
func BsonValueDollarIn(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonValueDollarIn struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_value_dollar_in", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_value_dollar_in FROM documentdb_api_internal.bson_value_dollar_in($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonValueDollarIn); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_value_dollar_in", l)
	}
	return
}

// BsonValueDollarLt is a wrapper for
//
//	documentdb_api_internal.bson_value_dollar_lt(anonymous internal, anonymous1 documentdb_core.bson, OUT bson_value_dollar_lt internal).
func BsonValueDollarLt(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonValueDollarLt struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_value_dollar_lt", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_value_dollar_lt FROM documentdb_api_internal.bson_value_dollar_lt($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonValueDollarLt); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_value_dollar_lt", l)
	}
	return
}

// BsonValueDollarLte is a wrapper for
//
//	documentdb_api_internal.bson_value_dollar_lte(anonymous internal, anonymous1 documentdb_core.bson, OUT bson_value_dollar_lte internal).
func BsonValueDollarLte(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonValueDollarLte struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_value_dollar_lte", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_value_dollar_lte FROM documentdb_api_internal.bson_value_dollar_lte($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonValueDollarLte); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_value_dollar_lte", l)
	}
	return
}

// BsonValueDollarMod is a wrapper for
//
//	documentdb_api_internal.bson_value_dollar_mod(anonymous internal, anonymous1 documentdb_core.bson, OUT bson_value_dollar_mod internal).
func BsonValueDollarMod(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonValueDollarMod struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_value_dollar_mod", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_value_dollar_mod FROM documentdb_api_internal.bson_value_dollar_mod($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonValueDollarMod); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_value_dollar_mod", l)
	}
	return
}

// BsonValueDollarNe is a wrapper for
//
//	documentdb_api_internal.bson_value_dollar_ne(anonymous internal, anonymous1 documentdb_core.bson, OUT bson_value_dollar_ne internal).
func BsonValueDollarNe(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonValueDollarNe struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_value_dollar_ne", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_value_dollar_ne FROM documentdb_api_internal.bson_value_dollar_ne($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonValueDollarNe); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_value_dollar_ne", l)
	}
	return
}

// BsonValueDollarNin is a wrapper for
//
//	documentdb_api_internal.bson_value_dollar_nin(anonymous internal, anonymous1 documentdb_core.bson, OUT bson_value_dollar_nin internal).
func BsonValueDollarNin(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonValueDollarNin struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_value_dollar_nin", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_value_dollar_nin FROM documentdb_api_internal.bson_value_dollar_nin($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonValueDollarNin); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_value_dollar_nin", l)
	}
	return
}

// BsonValueDollarRegex is a wrapper for
//
//	documentdb_api_internal.bson_value_dollar_regex(anonymous internal, anonymous1 documentdb_core.bson, OUT bson_value_dollar_regex internal).
func BsonValueDollarRegex(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonValueDollarRegex struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_value_dollar_regex", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_value_dollar_regex FROM documentdb_api_internal.bson_value_dollar_regex($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonValueDollarRegex); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_value_dollar_regex", l)
	}
	return
}

// BsonValueDollarSize is a wrapper for
//
//	documentdb_api_internal.bson_value_dollar_size(anonymous internal, anonymous1 documentdb_core.bson, OUT bson_value_dollar_size internal).
func BsonValueDollarSize(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonValueDollarSize struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_value_dollar_size", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_value_dollar_size FROM documentdb_api_internal.bson_value_dollar_size($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonValueDollarSize); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_value_dollar_size", l)
	}
	return
}

// BsonValueDollarType is a wrapper for
//
//	documentdb_api_internal.bson_value_dollar_type(anonymous internal, anonymous1 documentdb_core.bson, OUT bson_value_dollar_type internal).
func BsonValueDollarType(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument) (outBsonValueDollarType struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bson_value_dollar_type", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT bson_value_dollar_type FROM documentdb_api_internal.bson_value_dollar_type($1, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outBsonValueDollarType); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bson_value_dollar_type", l)
	}
	return
}

// Bsoncovariancepop is a wrapper for
//
//	documentdb_api_internal.bsoncovariancepop(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson).
func Bsoncovariancepop(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bsoncovariancepop", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bsoncovariancepop($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bsoncovariancepop", l)
	}
	return
}

// Bsoncovariancesamp is a wrapper for
//
//	documentdb_api_internal.bsoncovariancesamp(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson).
func Bsoncovariancesamp(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bsoncovariancesamp", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bsoncovariancesamp($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bsoncovariancesamp", l)
	}
	return
}

// Bsonderivative is a wrapper for
//
//	documentdb_api_internal.bsonderivative(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, anonymous12 bigint).
func Bsonderivative(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument, anonymous12 int64) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bsonderivative", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bsonderivative($1::bytea, $2::bytea, $3)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bsonderivative", l)
	}
	return
}

// Bsonfirst is a wrapper for
//
//	documentdb_api_internal.bsonfirst(anonymous documentdb_core.bson, anonymous1 ARRAY, anonymous12 documentdb_core.bson).
func Bsonfirst(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 struct{}, anonymous12 wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bsonfirst", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bsonfirst($1::bytea, $2, $3::bytea)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bsonfirst", l)
	}
	return
}

// Bsonfirstn is a wrapper for
//
//	documentdb_api_internal.bsonfirstn(anonymous documentdb_core.bson, anonymous1 bigint, anonymous12 ARRAY, anonymous123 documentdb_core.bson).
func Bsonfirstn(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 int64, anonymous12 struct{}, anonymous123 wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bsonfirstn", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bsonfirstn($1::bytea, $2, $3, $4::bytea)", anonymous, anonymous1, anonymous12, anonymous123)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bsonfirstn", l)
	}
	return
}

// Bsonfirstnonsorted is a wrapper for
//
//	documentdb_api_internal.bsonfirstnonsorted(anonymous documentdb_core.bson, anonymous1 bigint, anonymous12 documentdb_core.bson).
func Bsonfirstnonsorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 int64, anonymous12 wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bsonfirstnonsorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bsonfirstnonsorted($1::bytea, $2, $3::bytea)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bsonfirstnonsorted", l)
	}
	return
}

// Bsonfirstonsorted is a wrapper for
//
//	documentdb_api_internal.bsonfirstonsorted(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson).
func Bsonfirstonsorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bsonfirstonsorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bsonfirstonsorted($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bsonfirstonsorted", l)
	}
	return
}

// Bsonintegral is a wrapper for
//
//	documentdb_api_internal.bsonintegral(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, anonymous12 bigint).
func Bsonintegral(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument, anonymous12 int64) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bsonintegral", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bsonintegral($1::bytea, $2::bytea, $3)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bsonintegral", l)
	}
	return
}

// Bsonlast is a wrapper for
//
//	documentdb_api_internal.bsonlast(anonymous documentdb_core.bson, anonymous1 ARRAY, anonymous12 documentdb_core.bson).
func Bsonlast(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 struct{}, anonymous12 wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bsonlast", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bsonlast($1::bytea, $2, $3::bytea)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bsonlast", l)
	}
	return
}

// Bsonlastn is a wrapper for
//
//	documentdb_api_internal.bsonlastn(anonymous documentdb_core.bson, anonymous1 bigint, anonymous12 ARRAY, anonymous123 documentdb_core.bson).
func Bsonlastn(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 int64, anonymous12 struct{}, anonymous123 wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bsonlastn", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bsonlastn($1::bytea, $2, $3, $4::bytea)", anonymous, anonymous1, anonymous12, anonymous123)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bsonlastn", l)
	}
	return
}

// Bsonlastnonsorted is a wrapper for
//
//	documentdb_api_internal.bsonlastnonsorted(anonymous documentdb_core.bson, anonymous1 bigint, anonymous12 documentdb_core.bson).
func Bsonlastnonsorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 int64, anonymous12 wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bsonlastnonsorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bsonlastnonsorted($1::bytea, $2, $3::bytea)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bsonlastnonsorted", l)
	}
	return
}

// Bsonlastonsorted is a wrapper for
//
//	documentdb_api_internal.bsonlastonsorted(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson).
func Bsonlastonsorted(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bsonlastonsorted", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bsonlastonsorted($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bsonlastonsorted", l)
	}
	return
}

// Bsonmaxn is a wrapper for
//
//	documentdb_api_internal.bsonmaxn(anonymous documentdb_core.bson).
func Bsonmaxn(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bsonmaxn", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bsonmaxn($1::bytea)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bsonmaxn", l)
	}
	return
}

// Bsonmedian is a wrapper for
//
//	documentdb_api_internal.bsonmedian(anonymous documentdb_core.bson, anonymous1 integer, anonymous12 documentdb_core.bson).
func Bsonmedian(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 int32, anonymous12 wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bsonmedian", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bsonmedian($1::bytea, $2, $3::bytea)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bsonmedian", l)
	}
	return
}

// Bsonminn is a wrapper for
//
//	documentdb_api_internal.bsonminn(anonymous documentdb_core.bson).
func Bsonminn(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bsonminn", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bsonminn($1::bytea)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bsonminn", l)
	}
	return
}

// Bsonpercentile is a wrapper for
//
//	documentdb_api_internal.bsonpercentile(anonymous documentdb_core.bson, anonymous1 integer, anonymous12 documentdb_core.bson).
func Bsonpercentile(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 int32, anonymous12 wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bsonpercentile", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bsonpercentile($1::bytea, $2, $3::bytea)", anonymous, anonymous1, anonymous12)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bsonpercentile", l)
	}
	return
}

// Bsonstddevpop is a wrapper for
//
//	documentdb_api_internal.bsonstddevpop(anonymous documentdb_core.bson).
func Bsonstddevpop(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bsonstddevpop", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bsonstddevpop($1::bytea)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bsonstddevpop", l)
	}
	return
}

// Bsonstddevsamp is a wrapper for
//
//	documentdb_api_internal.bsonstddevsamp(anonymous documentdb_core.bson).
func Bsonstddevsamp(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.bsonstddevsamp", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.bsonstddevsamp($1::bytea)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.bsonstddevsamp", l)
	}
	return
}

// BuildIndexConcurrently is a wrapper for
//
//	documentdb_api_internal.build_index_concurrently(p_job_index integer).
func BuildIndexConcurrently(ctx context.Context, conn *pgx.Conn, l *slog.Logger, jobIndex int32) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.build_index_concurrently", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "CALL documentdb_api_internal.build_index_concurrently($1)", jobIndex)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.build_index_concurrently", l)
	}
	return
}

// CheckBuildIndexStatus is a wrapper for
//
//	documentdb_api_internal.check_build_index_status(p_arg documentdb_core.bson, OUT retval documentdb_core.bson, OUT ok boolean, OUT complete boolean).
func CheckBuildIndexStatus(ctx context.Context, conn *pgx.Conn, l *slog.Logger, arg wirebson.RawDocument) (outRetVal wirebson.RawDocument, outOk bool, outComplete bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.check_build_index_status", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT retval::bytea, ok, complete FROM documentdb_api_internal.check_build_index_status($1::bytea)", arg)
	if err = row.Scan(&outRetVal, &outOk, &outComplete); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.check_build_index_status", l)
	}
	return
}

// CheckBuildIndexStatusInternal is a wrapper for
//
//	documentdb_api_internal.check_build_index_status_internal(p_arg documentdb_core.bson, OUT check_build_index_status_internal documentdb_core.bson).
func CheckBuildIndexStatusInternal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, arg wirebson.RawDocument) (outCheckBuildIndexStatusInternal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.check_build_index_status_internal", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT check_build_index_status_internal::bytea FROM documentdb_api_internal.check_build_index_status_internal($1::bytea)", arg)
	if err = row.Scan(&outCheckBuildIndexStatusInternal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.check_build_index_status_internal", l)
	}
	return
}

// CollStatsAggregation is a wrapper for
//
//	documentdb_api_internal.coll_stats_aggregation(p_database_name text, p_collection_name text, p_collstatsspec documentdb_core.bson, OUT coll_stats_aggregation documentdb_core.bson).
func CollStatsAggregation(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, collectionName string, collstatsSpec wirebson.RawDocument) (outCollStatsAggregation wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.coll_stats_aggregation", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT coll_stats_aggregation::bytea FROM documentdb_api_internal.coll_stats_aggregation($1, $2, $3::bytea)", databaseName, collectionName, collstatsSpec)
	if err = row.Scan(&outCollStatsAggregation); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.coll_stats_aggregation", l)
	}
	return
}

// CollStatsWorker is a wrapper for
//
//	documentdb_api_internal.coll_stats_worker(p_database_name text, p_collection_name text, p_scale double precision DEFAULT 1, OUT coll_stats_worker documentdb_core.bson).
func CollStatsWorker(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, collectionName string, scale float64) (outCollStatsWorker wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.coll_stats_worker", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT coll_stats_worker::bytea FROM documentdb_api_internal.coll_stats_worker($1, $2, $3)", databaseName, collectionName, scale)
	if err = row.Scan(&outCollStatsWorker); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.coll_stats_worker", l)
	}
	return
}

// CollectionUpdateTrigger is a wrapper for
//
//	documentdb_api_internal.collection_update_trigger(OUT collection_update_trigger trigger).
func CollectionUpdateTrigger(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outCollectionUpdateTrigger struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.collection_update_trigger", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT collection_update_trigger FROM documentdb_api_internal.collection_update_trigger()")
	if err = row.Scan(&outCollectionUpdateTrigger); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.collection_update_trigger", l)
	}
	return
}

// CommandFeatureCounterStats is a wrapper for
//
//	documentdb_api_internal.command_feature_counter_stats(reset_stats_after_read boolean, OUT feature_name text, OUT usage_count integer).
func CommandFeatureCounterStats(ctx context.Context, conn *pgx.Conn, l *slog.Logger, resetStatsAfterRead bool) (outFeatureName string, outUsageCount int32, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.command_feature_counter_stats", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT feature_name, usage_count FROM documentdb_api_internal.command_feature_counter_stats($1)", resetStatsAfterRead)
	if err = row.Scan(&outFeatureName, &outUsageCount); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.command_feature_counter_stats", l)
	}
	return
}

// CreateBuiltinIdIndex is a wrapper for
//
//	documentdb_api_internal.create_builtin_id_index(collection_id bigint, register_id_index boolean DEFAULT true).
func CreateBuiltinIdIndex(ctx context.Context, conn *pgx.Conn, l *slog.Logger, collectionId int64, registerIdIndex bool) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.create_builtin_id_index", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.create_builtin_id_index($1, $2)", collectionId, registerIdIndex)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.create_builtin_id_index", l)
	}
	return
}

// CreateIndexesBackgroundInternal is a wrapper for
//
//	documentdb_api_internal.create_indexes_background_internal(p_database_name text, p_arg documentdb_core.bson, OUT create_indexes_background_internal documentdb_core.bson).
func CreateIndexesBackgroundInternal(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, arg wirebson.RawDocument) (outCreateIndexesBackgroundInternal wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.create_indexes_background_internal", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT create_indexes_background_internal::bytea FROM documentdb_api_internal.create_indexes_background_internal($1, $2::bytea)", databaseName, arg)
	if err = row.Scan(&outCreateIndexesBackgroundInternal); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.create_indexes_background_internal", l)
	}
	return
}

// CreateIndexesNonConcurrently is a wrapper for
//
//	documentdb_api_internal.create_indexes_non_concurrently(p_database_name text, p_arg documentdb_core.bson, p_skip_check_collection_create boolean DEFAULT false, OUT create_indexes_non_concurrently documentdb_core.bson).
func CreateIndexesNonConcurrently(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, arg wirebson.RawDocument, skipCheckCollectionCreate bool) (outCreateIndexesNonConcurrently wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.create_indexes_non_concurrently", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT create_indexes_non_concurrently::bytea FROM documentdb_api_internal.create_indexes_non_concurrently($1, $2::bytea, $3)", databaseName, arg, skipCheckCollectionCreate)
	if err = row.Scan(&outCreateIndexesNonConcurrently); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.create_indexes_non_concurrently", l)
	}
	return
}

// CurrentCursorState is a wrapper for
//
//	documentdb_api_internal.current_cursor_state(anonymous documentdb_core.bson, OUT current_cursor_state documentdb_core.bson).
func CurrentCursorState(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument) (outCurrentCursorState wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.current_cursor_state", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT current_cursor_state::bytea FROM documentdb_api_internal.current_cursor_state($1::bytea)", anonymous)
	if err = row.Scan(&outCurrentCursorState); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.current_cursor_state", l)
	}
	return
}

// CursorState is a wrapper for
//
//	documentdb_api_internal.cursor_state(anonymous documentdb_core.bson, anonymous1 documentdb_core.bson, OUT cursor_state boolean).
func CursorState(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 wirebson.RawDocument) (outCursorState bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.cursor_state", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT cursor_state FROM documentdb_api_internal.cursor_state($1::bytea, $2::bytea)", anonymous, anonymous1)
	if err = row.Scan(&outCursorState); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.cursor_state", l)
	}
	return
}

// DbStatsWorker is a wrapper for
//
//	documentdb_api_internal.db_stats_worker(p_collection_ids ARRAY, OUT db_stats_worker documentdb_core.bson).
func DbStatsWorker(ctx context.Context, conn *pgx.Conn, l *slog.Logger, collectionIds struct{}) (outDbStatsWorker wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.db_stats_worker", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT db_stats_worker::bytea FROM documentdb_api_internal.db_stats_worker($1)", collectionIds)
	if err = row.Scan(&outDbStatsWorker); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.db_stats_worker", l)
	}
	return
}

// DeleteExpiredRows is a wrapper for
//
//	documentdb_api_internal.delete_expired_rows(p_batch_size integer DEFAULT '-1').
func DeleteExpiredRows(ctx context.Context, conn *pgx.Conn, l *slog.Logger, batchSize int32) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.delete_expired_rows", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "CALL documentdb_api_internal.delete_expired_rows($1)", batchSize)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.delete_expired_rows", l)
	}
	return
}

// DeleteExpiredRowsForIndex is a wrapper for
//
//	documentdb_api_internal.delete_expired_rows_for_index(collection_id bigint, index_id bigint, index_key documentdb_core.bson, index_pfe documentdb_core.bson, current_datetime bigint, index_expiry integer, ttl_batch_size integer, shard_id bigint, OUT delete_expired_rows_for_index bigint).
func DeleteExpiredRowsForIndex(ctx context.Context, conn *pgx.Conn, l *slog.Logger, collectionId int64, indexId int64, indexKey wirebson.RawDocument, indexPfe wirebson.RawDocument, currentDatetime int64, indexExpiry int32, ttlBatchSize int32, shardId int64) (outDeleteExpiredRowsForIndex int64, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.delete_expired_rows_for_index", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT delete_expired_rows_for_index FROM documentdb_api_internal.delete_expired_rows_for_index($1, $2, $3::bytea, $4::bytea, $5, $6, $7, $8)", collectionId, indexId, indexKey, indexPfe, currentDatetime, indexExpiry, ttlBatchSize, shardId)
	if err = row.Scan(&outDeleteExpiredRowsForIndex); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.delete_expired_rows_for_index", l)
	}
	return
}

// DeleteOne is a wrapper for
//
//	documentdb_api_internal.delete_one(p_collection_id bigint, p_shard_key_value bigint, p_query documentdb_core.bson, p_sort documentdb_core.bson, p_return_document boolean, p_return_fields documentdb_core.bson, OUT o_is_row_deleted boolean, OUT o_result_deleted_document documentdb_core.bson).
func DeleteOne(ctx context.Context, conn *pgx.Conn, l *slog.Logger, collectionId int64, shardKeyValue int64, query wirebson.RawDocument, sort wirebson.RawDocument, returnDocument bool, returnFields wirebson.RawDocument) (outOIsRowDeleted bool, outOResultDeletedDocument wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.delete_one", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT o_is_row_deleted, o_result_deleted_document::bytea FROM documentdb_api_internal.delete_one($1, $2, $3::bytea, $4::bytea, $5, $6::bytea)", collectionId, shardKeyValue, query, sort, returnDocument, returnFields)
	if err = row.Scan(&outOIsRowDeleted, &outOResultDeletedDocument); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.delete_one", l)
	}
	return
}

// DeleteWorker is a wrapper for
//
//	documentdb_api_internal.delete_worker(p_collection_id bigint, p_shard_key_value bigint, p_shard_oid regclass, p_update_internal_spec documentdb_core.bson, p_update_internal_docs documentdb_core.bsonsequence, OUT delete_worker documentdb_core.bson).
func DeleteWorker(ctx context.Context, conn *pgx.Conn, l *slog.Logger, collectionId int64, shardKeyValue int64, shardOid struct{}, updateInternalSpec wirebson.RawDocument, updateInternalDocs []byte) (outDeleteWorker wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.delete_worker", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT delete_worker::bytea FROM documentdb_api_internal.delete_worker($1, $2, $3, $4::bytea, $5::bytea)", collectionId, shardKeyValue, shardOid, updateInternalSpec, updateInternalDocs)
	if err = row.Scan(&outDeleteWorker); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.delete_worker", l)
	}
	return
}

// DocumentdbCoreBsonToBson is a wrapper for
//
//	documentdb_api_internal.documentdb_core_bson_to_bson(anonymous documentdb_core.bson, OUT documentdb_core_bson_to_bson documentdb_core.bson).
func DocumentdbCoreBsonToBson(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument) (outDocumentdbCoreBsonToBson wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.documentdb_core_bson_to_bson", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT documentdb_core_bson_to_bson::bytea FROM documentdb_api_internal.documentdb_core_bson_to_bson($1::bytea)", anonymous)
	if err = row.Scan(&outDocumentdbCoreBsonToBson); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.documentdb_core_bson_to_bson", l)
	}
	return
}

// DocumentdbGetNextCollectionId is a wrapper for
//
//	documentdb_api_internal.documentdb_get_next_collection_id(OUT documentdb_get_next_collection_id bigint).
func DocumentdbGetNextCollectionId(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outDocumentdbGetNextCollectionId int64, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.documentdb_get_next_collection_id", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT documentdb_get_next_collection_id FROM documentdb_api_internal.documentdb_get_next_collection_id()")
	if err = row.Scan(&outDocumentdbGetNextCollectionId); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.documentdb_get_next_collection_id", l)
	}
	return
}

// DocumentdbGetNextCollectionIndexId is a wrapper for
//
//	documentdb_api_internal.documentdb_get_next_collection_index_id(OUT documentdb_get_next_collection_index_id integer).
func DocumentdbGetNextCollectionIndexId(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outDocumentdbGetNextCollectionIndexId int32, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.documentdb_get_next_collection_index_id", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT documentdb_get_next_collection_index_id FROM documentdb_api_internal.documentdb_get_next_collection_index_id()")
	if err = row.Scan(&outDocumentdbGetNextCollectionIndexId); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.documentdb_get_next_collection_index_id", l)
	}
	return
}

// EmptyDataTable is a wrapper for
//
//	documentdb_api_internal.empty_data_table(OUT shard_key_value bigint, OUT object_id documentdb_core.bson, OUT document documentdb_core.bson, OUT creation_time timestamp with time zone).
func EmptyDataTable(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outShardKeyValue int64, outObjectID wirebson.RawDocument, outDocument wirebson.RawDocument, outCreationTime struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.empty_data_table", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT shard_key_value, object_id::bytea, document::bytea, creation_time FROM documentdb_api_internal.empty_data_table()")
	if err = row.Scan(&outShardKeyValue, &outObjectID, &outDocument, &outCreationTime); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.empty_data_table", l)
	}
	return
}

// EnsureValidDbColl is a wrapper for
//
//	documentdb_api_internal.ensure_valid_db_coll(anonymous text, anonymous1 text, OUT ensure_valid_db_coll boolean).
func EnsureValidDbColl(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous string, anonymous1 string) (outEnsureValidDbColl bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.ensure_valid_db_coll", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT ensure_valid_db_coll FROM documentdb_api_internal.ensure_valid_db_coll($1, $2)", anonymous, anonymous1)
	if err = row.Scan(&outEnsureValidDbColl); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.ensure_valid_db_coll", l)
	}
	return
}

// GenerateUniqueShardDocument is a wrapper for
//
//	documentdb_api_internal.generate_unique_shard_document(p_document documentdb_core.bson, p_shard_key_value bigint, p_unique_spec documentdb_core.bson, p_sparse boolean, OUT generate_unique_shard_document documentdb_core.bson).
func GenerateUniqueShardDocument(ctx context.Context, conn *pgx.Conn, l *slog.Logger, document wirebson.RawDocument, shardKeyValue int64, uniqueSpec wirebson.RawDocument, sparse bool) (outGenerateUniqueShardDocument wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.generate_unique_shard_document", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT generate_unique_shard_document::bytea FROM documentdb_api_internal.generate_unique_shard_document($1::bytea, $2, $3::bytea, $4)", document, shardKeyValue, uniqueSpec, sparse)
	if err = row.Scan(&outGenerateUniqueShardDocument); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.generate_unique_shard_document", l)
	}
	return
}

// GetShardKeyValue is a wrapper for
//
//	documentdb_api_internal.get_shard_key_value(p_shard_key documentdb_core.bson, p_collection_id bigint, p_document documentdb_core.bson, OUT get_shard_key_value bigint).
func GetShardKeyValue(ctx context.Context, conn *pgx.Conn, l *slog.Logger, shardKey wirebson.RawDocument, collectionId int64, document wirebson.RawDocument) (outGetShardKeyValue int64, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.get_shard_key_value", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT get_shard_key_value FROM documentdb_api_internal.get_shard_key_value($1::bytea, $2, $3::bytea)", shardKey, collectionId, document)
	if err = row.Scan(&outGetShardKeyValue); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.get_shard_key_value", l)
	}
	return
}

// GinBsonExclusionConsistent is a wrapper for
//
//	documentdb_api_internal.gin_bson_exclusion_consistent(anonymous internal, anonymous1 smallint, anonymous12 anyelement, anonymous123 integer, anonymous1234 internal, anonymous12345 internal, OUT gin_bson_exclusion_consistent boolean).
func GinBsonExclusionConsistent(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}, anonymous12 struct{}, anonymous123 int32, anonymous1234 struct{}, anonymous12345 struct{}) (outGinBsonExclusionConsistent bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.gin_bson_exclusion_consistent", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_exclusion_consistent FROM documentdb_api_internal.gin_bson_exclusion_consistent($1, $2, $3, $4, $5, $6)", anonymous, anonymous1, anonymous12, anonymous123, anonymous1234, anonymous12345)
	if err = row.Scan(&outGinBsonExclusionConsistent); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.gin_bson_exclusion_consistent", l)
	}
	return
}

// GinBsonExclusionExtractQuery is a wrapper for
//
//	documentdb_api_internal.gin_bson_exclusion_extract_query(anonymous documentdb_api_catalog.shard_key_and_document, anonymous1 internal, anonymous12 smallint, anonymous123 internal, anonymous1234 internal, anonymous12345 internal, anonymous123456 internal).
func GinBsonExclusionExtractQuery(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}, anonymous12 struct{}, anonymous123 struct{}, anonymous1234 struct{}, anonymous12345 struct{}, anonymous123456 struct{}) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.gin_bson_exclusion_extract_query", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.gin_bson_exclusion_extract_query($1, $2, $3, $4, $5, $6, $7)", anonymous, anonymous1, anonymous12, anonymous123, anonymous1234, anonymous12345, anonymous123456)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.gin_bson_exclusion_extract_query", l)
	}
	return
}

// GinBsonExclusionExtractValue is a wrapper for
//
//	documentdb_api_internal.gin_bson_exclusion_extract_value(anonymous documentdb_api_catalog.shard_key_and_document, anonymous1 internal, OUT gin_bson_exclusion_extract_value internal).
func GinBsonExclusionExtractValue(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}) (outGinBsonExclusionExtractValue struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.gin_bson_exclusion_extract_value", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_exclusion_extract_value FROM documentdb_api_internal.gin_bson_exclusion_extract_value($1, $2)", anonymous, anonymous1)
	if err = row.Scan(&outGinBsonExclusionExtractValue); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.gin_bson_exclusion_extract_value", l)
	}
	return
}

// GinBsonExclusionOptions is a wrapper for
//
//	documentdb_api_internal.gin_bson_exclusion_options(anonymous internal).
func GinBsonExclusionOptions(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.gin_bson_exclusion_options", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.gin_bson_exclusion_options($1)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.gin_bson_exclusion_options", l)
	}
	return
}

// GinBsonHashedConsistent is a wrapper for
//
//	documentdb_api_internal.gin_bson_hashed_consistent(anonymous internal, anonymous1 smallint, anonymous12 anyelement, anonymous123 integer, anonymous1234 internal, anonymous12345 internal, OUT gin_bson_hashed_consistent boolean).
func GinBsonHashedConsistent(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}, anonymous12 struct{}, anonymous123 int32, anonymous1234 struct{}, anonymous12345 struct{}) (outGinBsonHashedConsistent bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.gin_bson_hashed_consistent", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_hashed_consistent FROM documentdb_api_internal.gin_bson_hashed_consistent($1, $2, $3, $4, $5, $6)", anonymous, anonymous1, anonymous12, anonymous123, anonymous1234, anonymous12345)
	if err = row.Scan(&outGinBsonHashedConsistent); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.gin_bson_hashed_consistent", l)
	}
	return
}

// GinBsonHashedExtractQuery is a wrapper for
//
//	documentdb_api_internal.gin_bson_hashed_extract_query(anonymous documentdb_core.bson, anonymous1 internal, anonymous12 smallint, anonymous123 internal, anonymous1234 internal, anonymous12345 internal, anonymous123456 internal).
func GinBsonHashedExtractQuery(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 struct{}, anonymous12 struct{}, anonymous123 struct{}, anonymous1234 struct{}, anonymous12345 struct{}, anonymous123456 struct{}) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.gin_bson_hashed_extract_query", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.gin_bson_hashed_extract_query($1::bytea, $2, $3, $4, $5, $6, $7)", anonymous, anonymous1, anonymous12, anonymous123, anonymous1234, anonymous12345, anonymous123456)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.gin_bson_hashed_extract_query", l)
	}
	return
}

// GinBsonHashedExtractValue is a wrapper for
//
//	documentdb_api_internal.gin_bson_hashed_extract_value(anonymous documentdb_core.bson, anonymous1 internal, OUT gin_bson_hashed_extract_value internal).
func GinBsonHashedExtractValue(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 struct{}) (outGinBsonHashedExtractValue struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.gin_bson_hashed_extract_value", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_hashed_extract_value FROM documentdb_api_internal.gin_bson_hashed_extract_value($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(&outGinBsonHashedExtractValue); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.gin_bson_hashed_extract_value", l)
	}
	return
}

// GinBsonHashedOptions is a wrapper for
//
//	documentdb_api_internal.gin_bson_hashed_options(anonymous internal).
func GinBsonHashedOptions(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.gin_bson_hashed_options", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.gin_bson_hashed_options($1)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.gin_bson_hashed_options", l)
	}
	return
}

// GinBsonUniqueShardConsistent is a wrapper for
//
//	documentdb_api_internal.gin_bson_unique_shard_consistent(anonymous internal, anonymous1 smallint, anonymous12 anyelement, anonymous123 integer, anonymous1234 internal, anonymous12345 internal, OUT gin_bson_unique_shard_consistent boolean).
func GinBsonUniqueShardConsistent(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}, anonymous12 struct{}, anonymous123 int32, anonymous1234 struct{}, anonymous12345 struct{}) (outGinBsonUniqueShardConsistent bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.gin_bson_unique_shard_consistent", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_unique_shard_consistent FROM documentdb_api_internal.gin_bson_unique_shard_consistent($1, $2, $3, $4, $5, $6)", anonymous, anonymous1, anonymous12, anonymous123, anonymous1234, anonymous12345)
	if err = row.Scan(&outGinBsonUniqueShardConsistent); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.gin_bson_unique_shard_consistent", l)
	}
	return
}

// GinBsonUniqueShardExtractQuery is a wrapper for
//
//	documentdb_api_internal.gin_bson_unique_shard_extract_query(anonymous documentdb_core.bson, anonymous1 internal, anonymous12 smallint, anonymous123 internal, anonymous1234 internal, anonymous12345 internal, anonymous123456 internal).
func GinBsonUniqueShardExtractQuery(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 struct{}, anonymous12 struct{}, anonymous123 struct{}, anonymous1234 struct{}, anonymous12345 struct{}, anonymous123456 struct{}) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.gin_bson_unique_shard_extract_query", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.gin_bson_unique_shard_extract_query($1::bytea, $2, $3, $4, $5, $6, $7)", anonymous, anonymous1, anonymous12, anonymous123, anonymous1234, anonymous12345, anonymous123456)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.gin_bson_unique_shard_extract_query", l)
	}
	return
}

// GinBsonUniqueShardExtractValue is a wrapper for
//
//	documentdb_api_internal.gin_bson_unique_shard_extract_value(anonymous documentdb_core.bson, anonymous1 internal, OUT gin_bson_unique_shard_extract_value internal).
func GinBsonUniqueShardExtractValue(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 struct{}) (outGinBsonUniqueShardExtractValue struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.gin_bson_unique_shard_extract_value", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT gin_bson_unique_shard_extract_value FROM documentdb_api_internal.gin_bson_unique_shard_extract_value($1::bytea, $2)", anonymous, anonymous1)
	if err = row.Scan(&outGinBsonUniqueShardExtractValue); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.gin_bson_unique_shard_extract_value", l)
	}
	return
}

// GinBsonUniqueShardPreConsistent is a wrapper for
//
//	documentdb_api_internal.gin_bson_unique_shard_pre_consistent(anonymous internal, anonymous1 smallint, anonymous12 documentdb_core.bson, anonymous123 integer, anonymous1234 internal, anonymous12345 internal, anonymous123456 internal, anonymous1234567 internal).
func GinBsonUniqueShardPreConsistent(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}, anonymous12 wirebson.RawDocument, anonymous123 int32, anonymous1234 struct{}, anonymous12345 struct{}, anonymous123456 struct{}, anonymous1234567 struct{}) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.gin_bson_unique_shard_pre_consistent", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.gin_bson_unique_shard_pre_consistent($1, $2, $3::bytea, $4, $5, $6, $7, $8)", anonymous, anonymous1, anonymous12, anonymous123, anonymous1234, anonymous12345, anonymous123456, anonymous1234567)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.gin_bson_unique_shard_pre_consistent", l)
	}
	return
}

// IndexBuildIsInProgress is a wrapper for
//
//	documentdb_api_internal.index_build_is_in_progress(p_index_id integer, OUT index_build_is_in_progress boolean).
func IndexBuildIsInProgress(ctx context.Context, conn *pgx.Conn, l *slog.Logger, indexId int32) (outIndexBuildIsInProgress bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.index_build_is_in_progress", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT index_build_is_in_progress FROM documentdb_api_internal.index_build_is_in_progress($1)", indexId)
	if err = row.Scan(&outIndexBuildIsInProgress); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.index_build_is_in_progress", l)
	}
	return
}

// IndexSpecAsBson is a wrapper for
//
//	documentdb_api_internal.index_spec_as_bson(index_spec documentdb_api_catalog.index_spec_type, for_get_indexes boolean DEFAULT false, namespacename text DEFAULT NULL, OUT index_spec_as_bson documentdb_core.bson).
func IndexSpecAsBson(ctx context.Context, conn *pgx.Conn, l *slog.Logger, indexSpec struct{}, forGetIndexes bool, namespacename string) (outIndexSpecAsBson wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.index_spec_as_bson", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT index_spec_as_bson::bytea FROM documentdb_api_internal.index_spec_as_bson($1, $2, $3)", indexSpec, forGetIndexes, namespacename)
	if err = row.Scan(&outIndexSpecAsBson); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.index_spec_as_bson", l)
	}
	return
}

// IndexSpecOptionsAreEquivalent is a wrapper for
//
//	documentdb_api_internal.index_spec_options_are_equivalent(left_index_spec documentdb_api_catalog.index_spec_type, right_index_spec documentdb_api_catalog.index_spec_type, OUT index_spec_options_are_equivalent boolean).
func IndexSpecOptionsAreEquivalent(ctx context.Context, conn *pgx.Conn, l *slog.Logger, leftIndexSpec struct{}, rightIndexSpec struct{}) (outIndexSpecOptionsAreEquivalent bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.index_spec_options_are_equivalent", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT index_spec_options_are_equivalent FROM documentdb_api_internal.index_spec_options_are_equivalent($1, $2)", leftIndexSpec, rightIndexSpec)
	if err = row.Scan(&outIndexSpecOptionsAreEquivalent); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.index_spec_options_are_equivalent", l)
	}
	return
}

// IndexStatsAggregation is a wrapper for
//
//	documentdb_api_internal.index_stats_aggregation(p_database_name text, p_collection_name text, OUT index_stats_aggregation documentdb_core.bson).
func IndexStatsAggregation(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, collectionName string) (outIndexStatsAggregation wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.index_stats_aggregation", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT index_stats_aggregation::bytea FROM documentdb_api_internal.index_stats_aggregation($1, $2)", databaseName, collectionName)
	if err = row.Scan(&outIndexStatsAggregation); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.index_stats_aggregation", l)
	}
	return
}

// IndexStatsWorker is a wrapper for
//
//	documentdb_api_internal.index_stats_worker(p_database_name text, p_collection_name text, OUT index_stats_worker documentdb_core.bson).
func IndexStatsWorker(ctx context.Context, conn *pgx.Conn, l *slog.Logger, databaseName string, collectionName string) (outIndexStatsWorker wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.index_stats_worker", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT index_stats_worker::bytea FROM documentdb_api_internal.index_stats_worker($1, $2)", databaseName, collectionName)
	if err = row.Scan(&outIndexStatsWorker); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.index_stats_worker", l)
	}
	return
}

// InsertOne is a wrapper for
//
//	documentdb_api_internal.insert_one(p_collection_id bigint, p_shard_key_value bigint, p_document documentdb_core.bson, OUT insert_one boolean).
func InsertOne(ctx context.Context, conn *pgx.Conn, l *slog.Logger, collectionId int64, shardKeyValue int64, document wirebson.RawDocument) (outInsertOne bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.insert_one", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT insert_one FROM documentdb_api_internal.insert_one($1, $2, $3::bytea)", collectionId, shardKeyValue, document)
	if err = row.Scan(&outInsertOne); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.insert_one", l)
	}
	return
}

// InsertWorker is a wrapper for
//
//	documentdb_api_internal.insert_worker(p_collection_id bigint, p_shard_key_value bigint, p_shard_oid regclass, p_insert_internal_spec documentdb_core.bson, p_insert_internal_docs documentdb_core.bsonsequence, OUT insert_worker documentdb_core.bson).
func InsertWorker(ctx context.Context, conn *pgx.Conn, l *slog.Logger, collectionId int64, shardKeyValue int64, shardOid struct{}, insertInternalSpec wirebson.RawDocument, insertInternalDocs []byte) (outInsertWorker wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.insert_worker", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT insert_worker::bytea FROM documentdb_api_internal.insert_worker($1, $2, $3, $4::bytea, $5::bytea)", collectionId, shardKeyValue, shardOid, insertInternalSpec, insertInternalDocs)
	if err = row.Scan(&outInsertWorker); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.insert_worker", l)
	}
	return
}

// InvalidateCollectionCache is a wrapper for
//
//	documentdb_api_internal.invalidate_collection_cache().
func InvalidateCollectionCache(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.invalidate_collection_cache", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.invalidate_collection_cache()")
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.invalidate_collection_cache", l)
	}
	return
}

// RecordIdIndex is a wrapper for
//
//	documentdb_api_internal.record_id_index(p_collection_id bigint).
func RecordIdIndex(ctx context.Context, conn *pgx.Conn, l *slog.Logger, collectionId int64) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.record_id_index", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.record_id_index($1)", collectionId)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.record_id_index", l)
	}
	return
}

// RumBsonSinglePathExtractTsvector is a wrapper for
//
//	documentdb_api_internal.rum_bson_single_path_extract_tsvector(anonymous documentdb_core.bson, anonymous1 internal, anonymous12 internal, anonymous123 internal, anonymous1234 internal, OUT rum_bson_single_path_extract_tsvector internal).
func RumBsonSinglePathExtractTsvector(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous wirebson.RawDocument, anonymous1 struct{}, anonymous12 struct{}, anonymous123 struct{}, anonymous1234 struct{}) (outRumBsonSinglePathExtractTsvector struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.rum_bson_single_path_extract_tsvector", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT rum_bson_single_path_extract_tsvector FROM documentdb_api_internal.rum_bson_single_path_extract_tsvector($1::bytea, $2, $3, $4, $5)", anonymous, anonymous1, anonymous12, anonymous123, anonymous1234)
	if err = row.Scan(&outRumBsonSinglePathExtractTsvector); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.rum_bson_single_path_extract_tsvector", l)
	}
	return
}

// RumBsonTextPathOptions is a wrapper for
//
//	documentdb_api_internal.rum_bson_text_path_options(anonymous internal).
func RumBsonTextPathOptions(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.rum_bson_text_path_options", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.rum_bson_text_path_options($1)", anonymous)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.rum_bson_text_path_options", l)
	}
	return
}

// ScheduleBackgroundIndexBuildWorkers is a wrapper for
//
//	documentdb_api_internal.schedule_background_index_build_workers(p_max_num_active_user_index_builds integer DEFAULT (current_setting(('documentdb', p_user_index_build_schedule integer DEFAULT (current_setting(('documentdb').
func ScheduleBackgroundIndexBuildWorkers(ctx context.Context, conn *pgx.Conn, l *slog.Logger, maxNumActiveUserIndexBuilds int32, userIndexBuildSchedule int32) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.schedule_background_index_build_workers", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.schedule_background_index_build_workers($1, $2)", maxNumActiveUserIndexBuilds, userIndexBuildSchedule)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.schedule_background_index_build_workers", l)
	}
	return
}

// SchemaValidationAgainstUpdate is a wrapper for
//
//	documentdb_api_internal.schema_validation_against_update(p_eval_state bytea, p_target_document documentdb_core.bson, p_source_document documentdb_core.bson, p_is_moderate boolean, OUT schema_validation_against_update boolean).
func SchemaValidationAgainstUpdate(ctx context.Context, conn *pgx.Conn, l *slog.Logger, evalState struct{}, targetDocument wirebson.RawDocument, sourceDocument wirebson.RawDocument, isModerate bool) (outSchemaValidationAgainstUpdate bool, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.schema_validation_against_update", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT schema_validation_against_update FROM documentdb_api_internal.schema_validation_against_update($1, $2::bytea, $3::bytea, $4)", evalState, targetDocument, sourceDocument, isModerate)
	if err = row.Scan(&outSchemaValidationAgainstUpdate); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.schema_validation_against_update", l)
	}
	return
}

// ScramSha256GetSaltAndIterations is a wrapper for
//
//	documentdb_api_internal.scram_sha256_get_salt_and_iterations(p_user_name text, OUT scram_sha256_get_salt_and_iterations documentdb_core.bson).
func ScramSha256GetSaltAndIterations(ctx context.Context, conn *pgx.Conn, l *slog.Logger, userName string) (outScramSha256GetSaltAndIterations wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.scram_sha256_get_salt_and_iterations", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT scram_sha256_get_salt_and_iterations::bytea FROM documentdb_api_internal.scram_sha256_get_salt_and_iterations($1)", userName)
	if err = row.Scan(&outScramSha256GetSaltAndIterations); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.scram_sha256_get_salt_and_iterations", l)
	}
	return
}

// TdigestAddDouble is a wrapper for
//
//	documentdb_api_internal.tdigest_add_double(anonymous internal, anonymous1 documentdb_core.bson, anonymous12 integer, anonymous123 documentdb_core.bson, OUT tdigest_add_double internal).
func TdigestAddDouble(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 int32, anonymous123 wirebson.RawDocument) (outTdigestAddDouble struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.tdigest_add_double", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT tdigest_add_double FROM documentdb_api_internal.tdigest_add_double($1, $2::bytea, $3, $4::bytea)", anonymous, anonymous1, anonymous12, anonymous123)
	if err = row.Scan(&outTdigestAddDouble); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.tdigest_add_double", l)
	}
	return
}

// TdigestAddDoubleArray is a wrapper for
//
//	documentdb_api_internal.tdigest_add_double_array(anonymous internal, anonymous1 documentdb_core.bson, anonymous12 integer, anonymous123 documentdb_core.bson, OUT tdigest_add_double_array internal).
func TdigestAddDoubleArray(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 wirebson.RawDocument, anonymous12 int32, anonymous123 wirebson.RawDocument) (outTdigestAddDoubleArray struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.tdigest_add_double_array", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT tdigest_add_double_array FROM documentdb_api_internal.tdigest_add_double_array($1, $2::bytea, $3, $4::bytea)", anonymous, anonymous1, anonymous12, anonymous123)
	if err = row.Scan(&outTdigestAddDoubleArray); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.tdigest_add_double_array", l)
	}
	return
}

// TdigestArrayPercentiles is a wrapper for
//
//	documentdb_api_internal.tdigest_array_percentiles(anonymous internal, OUT tdigest_array_percentiles documentdb_core.bson).
func TdigestArrayPercentiles(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outTdigestArrayPercentiles wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.tdigest_array_percentiles", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT tdigest_array_percentiles::bytea FROM documentdb_api_internal.tdigest_array_percentiles($1)", anonymous)
	if err = row.Scan(&outTdigestArrayPercentiles); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.tdigest_array_percentiles", l)
	}
	return
}

// TdigestCombine is a wrapper for
//
//	documentdb_api_internal.tdigest_combine(anonymous internal, anonymous1 internal, OUT tdigest_combine internal).
func TdigestCombine(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}) (outTdigestCombine struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.tdigest_combine", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT tdigest_combine FROM documentdb_api_internal.tdigest_combine($1, $2)", anonymous, anonymous1)
	if err = row.Scan(&outTdigestCombine); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.tdigest_combine", l)
	}
	return
}

// TdigestDeserial is a wrapper for
//
//	documentdb_api_internal.tdigest_deserial(anonymous bytea, anonymous1 internal, OUT tdigest_deserial internal).
func TdigestDeserial(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}, anonymous1 struct{}) (outTdigestDeserial struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.tdigest_deserial", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT tdigest_deserial FROM documentdb_api_internal.tdigest_deserial($1, $2)", anonymous, anonymous1)
	if err = row.Scan(&outTdigestDeserial); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.tdigest_deserial", l)
	}
	return
}

// TdigestPercentile is a wrapper for
//
//	documentdb_api_internal.tdigest_percentile(anonymous internal, OUT tdigest_percentile documentdb_core.bson).
func TdigestPercentile(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outTdigestPercentile wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.tdigest_percentile", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT tdigest_percentile::bytea FROM documentdb_api_internal.tdigest_percentile($1)", anonymous)
	if err = row.Scan(&outTdigestPercentile); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.tdigest_percentile", l)
	}
	return
}

// TdigestSerial is a wrapper for
//
//	documentdb_api_internal.tdigest_serial(anonymous internal, OUT tdigest_serial bytea).
func TdigestSerial(ctx context.Context, conn *pgx.Conn, l *slog.Logger, anonymous struct{}) (outTdigestSerial struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.tdigest_serial", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT tdigest_serial FROM documentdb_api_internal.tdigest_serial($1)", anonymous)
	if err = row.Scan(&outTdigestSerial); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.tdigest_serial", l)
	}
	return
}

// TriggerValidateDbname is a wrapper for
//
//	documentdb_api_internal.trigger_validate_dbname(OUT trigger_validate_dbname trigger).
func TriggerValidateDbname(ctx context.Context, conn *pgx.Conn, l *slog.Logger) (outTriggerValidateDbname struct{}, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.trigger_validate_dbname", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT trigger_validate_dbname FROM documentdb_api_internal.trigger_validate_dbname()")
	if err = row.Scan(&outTriggerValidateDbname); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.trigger_validate_dbname", l)
	}
	return
}

// UpdateOne is a wrapper for
//
//	documentdb_api_internal.update_one(p_collection_id bigint, p_shard_key_value bigint, p_query documentdb_core.bson, p_update documentdb_core.bson, p_shard_key documentdb_core.bson, p_is_upsert boolean, p_sort documentdb_core.bson, p_return_old_or_new boolean, p_return_fields documentdb_core.bson, p_array_filters documentdb_core.bson, OUT o_is_row_updated boolean, OUT o_update_skipped boolean, OUT o_is_retry boolean, OUT o_reinsert_document documentdb_core.bson, OUT o_upserted_object_id bytea, OUT o_result_document documentdb_core.bson).
func UpdateOne(ctx context.Context, conn *pgx.Conn, l *slog.Logger, collectionId int64, shardKeyValue int64, query wirebson.RawDocument, update wirebson.RawDocument, shardKey wirebson.RawDocument, isUpsert bool, sort wirebson.RawDocument, returnOldOrNew bool, returnFields wirebson.RawDocument, arrayFilters wirebson.RawDocument) (outOIsRowUpdated bool, outOUpdateSkipped bool, outOIsRetry bool, outOReinsertDocument wirebson.RawDocument, outOUpsertedObjectId struct{}, outOResultDocument wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.update_one", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT o_is_row_updated, o_update_skipped, o_is_retry, o_reinsert_document::bytea, o_upserted_object_id, o_result_document::bytea FROM documentdb_api_internal.update_one($1, $2, $3::bytea, $4::bytea, $5::bytea, $6, $7::bytea, $8, $9::bytea, $10::bytea)", collectionId, shardKeyValue, query, update, shardKey, isUpsert, sort, returnOldOrNew, returnFields, arrayFilters)
	if err = row.Scan(&outOIsRowUpdated, &outOUpdateSkipped, &outOIsRetry, &outOReinsertDocument, &outOUpsertedObjectId, &outOResultDocument); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.update_one", l)
	}
	return
}

// UpdateWorker is a wrapper for
//
//	documentdb_api_internal.update_worker(p_collection_id bigint, p_shard_key_value bigint, p_shard_oid regclass, p_update_internal_spec documentdb_core.bson, p_update_internal_docs documentdb_core.bsonsequence, OUT update_worker documentdb_core.bson).
func UpdateWorker(ctx context.Context, conn *pgx.Conn, l *slog.Logger, collectionId int64, shardKeyValue int64, shardOid struct{}, updateInternalSpec wirebson.RawDocument, updateInternalDocs []byte) (outUpdateWorker wirebson.RawDocument, err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.update_worker", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT update_worker::bytea FROM documentdb_api_internal.update_worker($1, $2, $3, $4::bytea, $5::bytea)", collectionId, shardKeyValue, shardOid, updateInternalSpec, updateInternalDocs)
	if err = row.Scan(&outUpdateWorker); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.update_worker", l)
	}
	return
}

// ValidateDbname is a wrapper for
//
//	documentdb_api_internal.validate_dbname(dbname text).
func ValidateDbname(ctx context.Context, conn *pgx.Conn, l *slog.Logger, database string) (err error) {
	ctx, span := otel.Tracer("").Start(ctx, "documentdb_api_internal.validate_dbname", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	defer span.End()

	row := conn.QueryRow(ctx, "SELECT FROM documentdb_api_internal.validate_dbname($1)", database)
	if err = row.Scan(); err != nil {
		err = mongoerrors.Make(ctx, err, "documentdb_api_internal.validate_dbname", l)
	}
	return
}
